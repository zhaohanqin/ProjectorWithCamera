首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 首页 

# 概述 

工业相机 SDK 是专门配合工业相机、采集卡、光源控制器、光源控制卡等设备使用的软件开发包 。您可基于该 SDK 轻松搭建满足特定场景需求的视觉应用程序，实现设备控制、设备参数配置、 获取数据、保存数据等功能。 

该SDK 兼容 GigE Vision 、USB3 Vision 、Camera Link 、CoaXPress 和XoFlink 协议。 

# 运行环境 

Windows 7 (32/64) 、Windows 10 (32/64) 、Windows 11 、Windows Server 2008 R2 及以上 

# 使用说明 

客户端默认安装在 C:/Program Files (x86)/ （软件名称） 路径下，您也可指定安装路径。安装后 ，您可在客户端文件夹下访问 Development 文件夹，其中包括 SDK 二次开发的依赖文件。该文件 夹目录结构如下： ￿ Bin （编译后的成果物） 

￿ Documentations （二次开发文档资料，包括 SDK 开发指南和 Demo 使用说明等） 

￿ DotNet （.NET 开发的部分动态库） 

￿ Includes （头文件） 

￿ Libraries （静态库） 

￿ Samples （各种编程语言的示例代码） 

￿ ThirdPartyPlatformAdapter （第三方平台插件） 

注解 

不同版本的客户端开发目录文件可能存在差异，请以实际内容为准。 

工业相机 Windows 版本 SDK 安装包包含了 SDK 接口说明和示例部分及相机驱动两个部分： 

￿ 相机驱动程序 ：在安装工业相机客户端时，您可选择是否安装。若选择安装，您可在 

C:/Program Files (x86)/Common Files/ ( 软件名称） 路径中，找到对应的三个文件夹， 分别是 Drivers （驱动）、 Runtime （包含了 32 位/64 位的动态链接库 DLL ）以及 Service （相机日志服务）。 

￿ SDK 接口 ：以动态链接库 DLL 方式提供函数接口，您可以在 C:/Program Files (x86)/Common Files/ （软件名称） /Runtime 中，找到 Win32_i86 和Win64_x64 版本，分 别支持 32 位和 64 位程序开发。客户端安装时，默认将该路径写入环境变量 Path 内，您无 需额外拷贝。 

# 注意事项 

￿ 本手册中提供的代码段仅作为示例代码提供。不正确的代码可能会导致您的相机功能与预 期不同，并可能危及您的应用程序。为确保代码段在您的应用程序中正常运行，您必须对 其进行调整以满足您的特定需求，并且在使用前对其进行彻底测试； 

￿ 不是所有的接口所有的相机都支持，以实际相机支持的功能为准。 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 发版说明 

# V4.6.0 

V4.6.0 版本发布于 2025 年6月。 

【功能新增】 

￿ 该版本新增支持 PCIe 光源控制卡。 您可通过采集卡相关接口枚举设备（ 

MV_CC_EnumInterfaces() ）、打开设备（ MV_CC_OpenInterface() ）、关闭设备（ 

MV_CC_CloseInterface() ）、配置设备事件（ MV_CC_RegisterAllEventCallBack() /

MV_CC_RegisterEventCallBackEx() ）等功能。 

o 宏定义新增 MV_LC_INTERFACE ，代表光源控制卡。在调用 

MV_CC_EnumInterfaces() 时，您可将该宏定义传入 nTLayerType 以发现光源控 制卡。 

o 新增 ConfigLightController.cpp 示例程序，演示触发参数和 IO 参数控制，包括 常规参数修改，事件及快速软触发等。 

￿ 新增取图回调扩展接口 MV_CC_RegisterImageCallBackEx2() 。该接口支持您在回调 函数外手动调用 MV_CC_FreeImageBuffer() 释放缓存。 

注解 

关于该接口的更多使用说明，请参见接口描述。 

￿ 新增流异常回调相关功能，用于通过回调函数上报取流过程中出现的异常。 

o 新增 MV_CC_RegisterStreamExceptionCallBack() ，用于注册流异常消息回 调。该接口支持 GEV 、U3V 和采集卡下的所有相机。 

o MV_CC_STREAM_EXCEPTION_TYPE 中，新增 流异常类型 。

o 新增 MV_CC_STREAM_EXCEPTION_INFO ，表示流异常回调信息。 ￿ 新增 串口控制相关 接口。在工业相机外接串口设备时（如液态镜头），您可通过该类别 串口控制相关接口，实现与相机外接的串口设备进行通信。 

o 支持通过 MV_CC_SerialPort_Open() 打开串口。 

o 支持读取（ MV_CC_SerialPort_Read() ）、写入（ 

MV_CC_SerialPort_Write() ）、或清空已获取的串口数据（ 

MV_CC_SerialPort_ClearBuffer() ）。 

o 支持通过 MV_CC_SerialPort_Close() 关闭串口。 

￿ 新增 回调函数定义 ，用于注册图像数据、异常消息等。 

￿ MV_CC_ConvertPixelTypeEx() 支持将 Bayer10/12 转为 Bayer16 格式。 

注解 

对于 Bayer10 packed 和Bayer12 packed 格式，您需首先将图像格式转为 Bayer10 和

Bayer12 后，再转为 Bayer16 。

￿ 新增 通用状态码 ：

o 0x80000018 ：DDR 缓存不足。 

o 0x80000019 ：流通道不足。 

【示例程序】 

￿ 新增 ConfigLightController.cpp 示例程序，演示触发参数和 IO 参数控制，包括常规参数 修改，事件及快速软触发等。 

￿ 新增 LineScanSoftwareTrigger.cpp 示例，用于演示控制线阵相机设置帧触发，开启软 触发取图。 

￿ 修改 ParametrizeCamera_LineScanIOSettings.cpp 示例程序，您可参考该程序，了解 如何兼容新版本的相机节点。 

￿ 修改 ChunkData.cpp 、 Grab_Asynchronous.cpp 等示例程序。 

【功能废弃】 

￿ 废弃 MV_USB_RegisterStreamExceptionCallBack() ，您可使用 

MV_CC_RegisterStreamExceptionCallBack() 实现相关需求。 

# V4.5.1 

该版本新增 ISP 配置相关接口，您可在程序调用相应接口对图像进行 ISP 算法处理。 

【功能新增】 

￿ 支持传入 ISP 参数以对图像进行 ISP 算法处理。在通过 ISP 工具配置图像处理参数并保存配 置文件后，您可通过 MV_CC_SetISPConfig() 及 MV_CC_ISP_CONFIG_PARAM 将ISP 配置文件传入程序。之后，您可调用 MV_CC_ISPProcess() 对图像数据进行 ISP 算法 处理。 

# V4.5.0 

【功能新增】 

￿ 新增去紫边接口 MV_CC_PurpleFringing() 和其对应的结构体 

MV_CC_PURPLE_FRINGING_PARAM ，可用于去除图像中物体边缘处由高反差、逆光 等因素导致的紫边。 

￿ 新增虚拟采集卡类型 MV_VIR_INTERFACE 和虚拟设备类型 MV_GENTL_VIR_DEVICE 

，可用于枚举虚拟采集卡和虚拟采集卡下的虚拟设备。 

注解 

不支持枚举虚拟 GEV 采集卡下的设备。 

￿ 新增虚拟相机信息结构体 MV_GENTL_VIR_DEVICE_INFO 。

￿ 帧信息结构体 MV_FRAME_OUT_INFO_EX 中新增成员 SubImageList 和UserPtr 。

o SubImageList 可用于分时频闪场景。当通过采集卡端拆图时，您可使用该成员获取 拆图后的子图信息列表。 

o UserPtr 表示注册外部缓存时自定义的指针。 

￿ 新增去紫边特有错误码。 

o 0x10405000 ：去紫边算法 ROI 原点错误。 

o 0x10405001 ：去紫边算法 ROI 大小错误。 

o 0x10405002 ：去紫边算法滤波核尺寸错误。 

￿ 新增图像高度异常错误码 0x80000017 ，表示图像高度异常（残帧丢弃）。 

￿ 新增控制台示例程序 ParametrizeCamera_AreaScanIOSettings.cpp ，用于演示如何配置 面阵相机触发相关节点 IO 。

【功能更新】 

￿ MV_CC_Image 结构体中的成员 nImageBufLen 的名称更新为 nImageLen 。

￿ 更新部分控制台示例程序，包括 QuickSoftwareTrigger.cpp 和ForceIPEx.cpp 。

【功能废弃】 

￿ 示例程序概览 中，废弃 ForceIP.cpp 示例程序。 

【文档调整】 

￿ 更新控制台示例程序的目录结构，详情请参见 示例程序概览 。V4.4.1 

【功能新增】 

￿ 新增获取 Enum 属性值扩展接口 MV_CC_GetEnumValueEx() 和对应的枚举类型值结构 体 MVCC_ENUMVALUE_EX 。该接口最大支持到 256 个节点。 

￿ 新增保存图像到文件扩展接口 MV_CC_SaveImageToFileEx2() 和对应的保存图片所需 参数结构体 MV_CC_SAVE_IMAGE_PARAM 。该接口支持以 PNG 或TIFF 格式保存 4GB 

以上的超大图。 

￿ 新增通过采集卡句柄枚举相机接口 MV_CC_EnumDevicesByInterface() 。

￿ 新增开启设备指定事件接口 MV_CC_EventNotificationOn() 和关闭设备指定事件接口 

MV_CC_EventNotificationOff() 。

￿ 新增 Windows 控制台 demo ，包含 MultiLightCtrl_ImageStitching.cpp 、

Events_Interface.cpp 、ImageSave.cpp 和

ParametrizeCamera_LineScanIOSettings.cpp 。

￿ 支持 4GB 以上大小的图像取流和渲染。 

o 新增显示一帧图像扩展接口 MV_CC_DisplayOneFrameEx2() 和对应的图像信息 结构体 MV_CC_IMAGE 。该接口支持 4GB 以上超大图渲染。 

o 支持通过 OpenGL 方式渲染 4GB 以上超大图，您可通过 

MV_DISPLAY_FRAME_INFO_EX() 显示帧信息结构体中 enRenderMode 字段实 现该功能。 

o 更新 MV_FRAME_OUT_INFO_EX() 输出帧的信息结构体，添加 nFrameLenEx 

字段，支持输出 4GB 以上图像帧的长度。 

【功能更新】 

￿ 更新部分 Windows 控制台 demo ，包含 GrabImage_Display.cpp 、

InterfaceAndDeviceDemo.cpp 等。 

￿ 新增部分 状态码 。

o 0x80000015 ：表示解码错误。 

o 0x80000016 ：表示图像大小超出 unsigned int 数据类型上限值。 

o 0x8000020E ：表示在固定 IP 模式下不支持修改设备 IP 模式。 

【功能废弃】 ￿ 废弃相机初始化相关接口： MV_CC_EnumerateTls() 和

MV_CC_CreateHandleWithoutLog() 。

￿ 废弃图像采集相关接口： MV_CC_RegisterImageCallBackForRGB() 、

MV_CC_RegisterImageCallBackForBGR() 、 MV_CC_GetImageForRGB() 和

MV_CC_GetImageForBGR() 。

￿ 废弃显示相关接口和结构体： MV_CC_DisplayOneFrame() 和

MV_DISPLAY_FRAME_INFO 。建议您使用 MV_CC_DisplayOneFrameEx() 接口或 

MV_CC_DisplayOneFrameEx2() 接口替代。 

￿ 废弃相机属性相关接口： MV_CC_OpenParamsGUI() 。

￿ 废弃 3D 点云图像相关接口、结构体、枚举类型及控制台 demo ：

MV_CC_SavePointCloudData() 、 MV_SAVE_POINT_CLOUD_PARAM 、

MV_SAVE_POINT_CLOUD_FILE_TYPE() 和SavePointCloudData_3D.cpp 。

# V4.4.0 

【功能新增】 

￿ 新增导入设备属性扩展接口 MV_CC_FeatureLoadEx() 。

￿ 新增节点错误信息结构体 MVCC_NODE_ERROR 、节点错误信息列表结构体 

MVCC_NODE_ERROR_LIST 。

￿ 支持采集卡快速软触发功能，并新增示例程序： QuickSoftwareTrigger.cpp 。

【功能更新】 

￿ 更新部分 Windows 控制台 demo ，包含 GrabImage_Display.cpp 、MultiCast.cpp 等。 

￿ 新增部分 状态码 。

【文档调整】 

￿ 合并 状态码 至接口说明 中介绍。 

# V4.3.0 

【功能新增】 ￿ 新增初始化 SDK 接口 MV_CC_Initialize() 、反初始化 SDK 接口 MV_CC_Finalize() 。

￿ 新增枚举采集卡接口 MV_CC_EnumInterfaces() 、创建采集卡句柄接口 

MV_CC_CreateInterface() 和 MV_CC_CreateInterfaceByID() 。

￿ 新增打开采集卡接口 MV_CC_OpenInterface() 、关闭采集卡接口 

MV_CC_CloseInterface() 、销毁采集卡句柄接口 MV_CC_DestroyInterface() 。

￿ 新增获取串口信息列表接口 MV_CAML_GetSerialPortList() 、设置指定串口列表接口 

MV_CAML_SetEnumSerialPorts() 。

￿ 相机初始化 和 图像采集 接口支持对双 USB3.0 接口工业相机进行枚举、打开、取流、获 取图像、关闭等操作。 

￿ 图像渲染 接口支持对大图（宽高上限为 16384*163840 ）进行渲染。 

￿ 图像处理 中设置插值算法类型接口 MV_CC_SetBayerCvtQuality() 新增 “最优 +” 插值方法 。

￿ 图像处理 和属性配置 接口支持采集卡句柄。 

￿ 设备升级 接口支持采集卡固件升级。 

￿ 事件及异常 接口支持采集卡事件。 

￿ 新增采集卡信息结构体 MV_INTERFACE_INFO 、采集卡信息列表结构体 

MV_INTERFACE_INFO_LIST 。

￿ 新增串口信息结构体 MV_CAML_SERIAL_PORT 、串口信息列表结构体 

MV_CAML_SERIAL_PORT_LIST 。

￿ 新增 CoaXPress 相机信息结构体 MV_CXP_DEVICE_INFO 、CameraLink 相机信息结构 体 MV_CML_DEVICE_INFO 、XoFLink 相机信息结构体 MV_XOF_DEVICE_INFO 。

￿ 新增 Windows 控制台 demo ：ForceIPEx.cpp 、Grab_Asynchronous.cpp 、

InterfaceAndDeviceDemo.cpp 、InterfaceDemo.cpp 。

【功能更新】 

￿ SDK 不再支持 Windows XP 系统。 

￿ 更新保存图片到文件参数结构体 MV_SAVE_IMAGE_TO_FILE_PARAM_EX 、图片保存 参数结构体 MV_SAVE_IMAGE_PARAM_EX3 。

￿ 更新显示帧信息结构体 MV_DISPLAY_FRAME_INFO 和

MV_DISPLAY_FRAME_INFO_EX 。

￿ 更新 CCM 参数结构体 MV_CC_CCM_PARAM 和 MV_CC_CCM_PARAM_EX 。

￿ 更新设备信息结构体 MV_CC_DEVICE_INFO 。

￿ 更新锐化结构体 MV_CC_SHARPEN_PARAM 。￿ 更新 状态码 。

【文档调整】 

￿ 调整 接口说明 的模块划分。 

# V4.2.0 

【功能新增】 

￿ 支持采集卡 GE1104 。

# V4.1.0 

【功能新增】 

￿ 新增图像保存接口： MV_CC_SaveImageEx3() ，废弃旧接口 MV_CC_SaveImageEx2() 

。

￿ 新增保存图像到文件接口： MV_CC_SaveImageToFileEx() ，废弃旧接口 

MV_CC_SaveImageToFile() 。

￿ 新增像素格式转换接口： MV_CC_ConvertPixelTypeEx() ，废弃旧接口 

MV_CC_ConvertPixelType() 。

￿ 新增图片保存参数结构体： MV_SAVE_IMAGE_PARAM_EX3 。

￿ 新增保存图片到文件参数结构体： MV_SAVE_IMAGE_TO_FILE_PARAM_EX 。

￿ 新增像素转换结构体： MV_CC_PIXEL_CONVERT_PARAM_EX 。

￿ 新增 相机参数节点表 章节。 

￿ 增加配置参数， SDK 崩溃时，可配置是否生成 dump 文件。 

# V4.0.1 

【功能新增】 

￿ 新增显示一帧图像接口： MV_CC_DisplayOneFrameEx() 。

￿ 新增设置枚举超时时间接口： MV_GIGE_SetEnumDevTimeout() 。

￿ 新增设置 U3V 相机同步读写超时时间接口： MV_USB_SetSyncTimeOut() 。￿ 新增获取 U3V 相机同步读写超时时间接口： MV_USB_GetSyncTimeOut() 。

￿ 新增设置 Mono8/bayer 格式的 Gamma 值接口： MV_CC_SetGammaValue() 。

￿ 新增从设备读取文件接口： MV_CC_FileAccessReadEx() 。

￿ 新增将文件写入设备接口： MV_CC_FileAccessWriteEx() 。

# V4.0.0 

【功能新增】 

￿ 新增枚举设备的扩展接口： MV_CC_EnumDevicesEx2() 。

￿ 新增获取当前图像缓存区的有效图像个数接口： MV_CC_GetValidImageNum() 。

￿ 新增获取 Enum 型节点指定值符号接口： MV_CC_GetEnumEntrySymbolic() 。

￿ 新增打开获取或设置相机参数的 GUI 界面接口： MV_CC_OpenParamsGUI() 。

￿ 在图像渲染功能中新增绘制矩形接口： MV_CC_DrawRect() 、绘制圆形接口： 

MV_CC_DrawCircle() 和绘制线条接口： MV_CC_DrawLines() 。

￿ 新增重构图像接口： MV_CC_ReconstructImage() 。

￿ 更新图像对比度调节接口： MV_CC_ImageContrast() 。

￿ 新增设置插值算法平滑使能接口： MV_CC_SetBayerFilterEnable() 。

￿ 新增注册流异常消息回调接口： MV_USB_RegisterStreamExceptionCallBack() ，只 支持 U3V 相机。 

￿ 新增设置 U3V 事件缓存节点个数接口： MV_USB_SetEventNodeNum() 。

￿ 新增卸载 cti 库接口： MV_CC_UnloadGenTLLibrary() 。

￿ 组件包中新增采集卡 SDK 的Runtime 和开发包。 

￿ 新增支持 Windows Server 系统。 

￿ 支持 GigE 相机的抢占权限功能。 

￿ 重载 java 注册回调接口，注册的回调函数新增相机句柄形参。 

￿ 新增示例程序： OpenParamsGUI.cpp 。

￿ 支持串口方式配置 Camera Link 相机参数，新增 MvSerial 串口配置工具示例 demo 。

￿ 新增支持虚拟相机。 

# V3.5.0 

【功能新增】 ￿ 支持通过 ISP Tool 实现图像处理： ISP Tool 调用 SDK 生成各种算法的标定文件和算法配置 参数， SDK 通过 ISP Tool 生成的配置文件在所有取图接口（包括主动取图和回调取图）内 部对图像进行 ISP 算法处理，详见 图像采集 。配置文件生成方法见 ISP Tool 使用说明。 

【功能优化】 

￿ 优化 LSC 示例程序，删除色彩校正、图像增强及空域降噪示例。 

￿ 支持 U3V 相机无损码流的获取。 

￿ 支持多线程，实现 ISP 算子效率优化。 

【功能调整】 

￿ 以下接口将逐渐废弃： MV_CC_SetBayerCLUTParam() 、 MV_CC_ImageContrast() 、

MV_CC_ImageSharpen() 、 MV_CC_ColorCorrect() 、 MV_CC_NoiseEstimate() 、

MV_CC_SpatialDenoise() 、 MV_CC_SavePointCloudData() 、

MV_CC_SavePointCloudData() 。

# V3.4.0 

【功能新增】 

￿ 新增设置 Bayer 格式的 Gamma 信息接口： MV_CC_SetBayerGammaParam() 。

￿ 新增设置 Bayer 格式的 CCM 使能和矩阵接口： MV_CC_SetBayerCCMParamEx() 。

￿ 新增设置 Bayer 格式的 CLUT 使能和信息接口： MV_CC_SetBayerCLUTParam() 。

￿ 新增色彩校正（包括 CCM 和CLUT ）接口： MV_CC_ColorCorrect() 。

￿ 新增图像对比度调节接口： MV_CC_ImageContrast() 。

￿ 新增图像锐化接口： MV_CC_ImageSharpen() 。

￿ 新增噪声估计接口： MV_CC_NoiseEstimate() 。

￿ 新增空域降噪接口： MV_CC_SpatialDenoise() 。

￿ 新增 LSC 标定接口： MV_CC_LSCCalib() 。

￿ 新增 LSC 校正接口： MV_CC_LSCCorrect() 。

￿ 新增示例程序：色彩校正、图像增强 、LSC 及空域降噪 。

￿ 新增算法错误码。 

# V3.3.0 【功能新增】 

￿ 新增设置枚举设备回复包是否为广播包接口： MV_GIGE_SetDiscoveryMode() 。

￿ 新增设置 GVSP 取流超时时间接口： MV_GIGE_SetGvspTimeout() 。

￿ 新增获取 GVSP 取流超时时间接口： MV_GIGE_GetGvspTimeout() 。

￿ 新增设置重传命令最大尝试次数接口： MV_GIGE_SetResendMaxRetryTimes() 。

￿ 新增获取重传命令最大尝试次数接口： MV_GIGE_GetResendMaxRetryTimes() 。

￿ 新增设置同一重传包多次请求之间的时间间隔接口： 

MV_GIGE_SetResendTimeInterval() 。

￿ 新增获取同一重传包多次请求之间的时间间隔接口： 

MV_GIGE_GetResendTimeInterval() 。

￿ 新增图像旋转接口： MV_CC_RotateImage() 。

￿ 新增图像翻转接口： MV_CC_FlipImage() 。

￿ 新增设置 Bayer 格式插值后的 Gamma 值接口： MV_CC_SetBayerGammaValue() 。

￿ 新增设置 Bayer 格式插值后的色彩校正使能和矩阵接口： 

MV_CC_SetBayerCCMParam() 。

￿ 新增无损解码接口： MV_CC_HB_Decode() 。

￿ 新增 Bayer 噪声估计接口： MV_CC_BayerNoiseEstimate() 。

￿ 新增 Bayer 空域降噪接口： MV_CC_BayerSpatialDenoise() 。

# V3.2.0 

【功能新增】 

￿ 新增获取组播状态函数接口： MV_GIGE_GetMulticastStatus() 。

￿ 新增保存点云格式函数接口： MV_CC_SavePointCloudData() 。

￿ 新增保存图像到文件函数接口： MV_CC_SaveImageToFile() 。

￿ 新增通过 GenTL 枚举 Interfaces 函数接口： MV_CC_EnumInterfacesByGenTL() 。

￿ 新增通过 GenTL Interface 枚举设备函数接口： MV_CC_EnumDevicesByGenTL() 。

￿ 新增通过 GenTL 设备信息创建设备（句柄）函数接口： 

MV_CC_CreateHandleByGenTL() 。

【文档调整】 

￿ 删除 88 个废弃函数接口。 V3.1.0 

【功能新增】 

￿ 新增设置取流策略函数接口： MV_CC_SetGrabStrategy() 。

￿ 新增设置输出缓存个数函数接口： MV_CC_SetOutputQueueSize() 。

￿ 新增获得当前节点的类型函数接口： MV_XML_GetNodeInterfaceType() 。

￿ 新增获得当前节点的访问模式据函数接口： MV_XML_GetNodeAccessMode() 。

￿ 新增设置重传 GVCP 命令次数函数接口： MV_GIGE_SetRetryGvcpTimes() 。

￿ 新增获取重传 GVCP 命令次数函数接口： MV_GIGE_GetRetryGvcpTimes() 。

￿ 新增获取 GVCP 命令超时时间函数接口： MV_GIGE_GetGvcpTimeout() 。

￿ 新增清除取流数据缓存数接口： MV_CC_ClearImageBuffer() 。

￿ 新增设置 U3V 的传输包大小据函数接口： MV_USB_SetTransferSize() 。

￿ 新增获取 U3V 的传输包大小据函数接口： MV_USB_GetTransferSize() 。

￿ 新增设置 U3V 的传输通道个数据函数接口： MV_USB_SetTransferWays() 

￿ 新增获取 U3V 的传输通道个数据函数接口： MV_USB_GetTransferWays() 

# V3.0.0 

【功能新增】 

￿ 新增发出 PTP 时钟拍照动作命令函数接口： MV_GIGE_IssueActionCommand() 

￿ 新增判断相机是否处于连接状态函数接口： MV_CC_IsDeviceConnected() 

￿ 新增设置设备波特率函数接口： MV_CAML_SetDeviceBaudrate() （此接口为 

CameraLink 设备接口）。 

￿ 新增获取设备波特率函数接口： MV_CAML_GetDeviceBaudrate() （此接口为 

CameraLink 设备接口）。 

￿ 新增获取设备与主机间连接支持的波特率函数接口： 

MV_CAML_GetSupportBaudrates() （此接口为 CameraLink 设备接口）。 

￿ 新增开始录像函数接口： MV_CC_StartRecord() 。

￿ 新增停止录像函数接口： MV_CC_StopRecord() 。

￿ 新增输入录像数据函数接口： MV_CC_InputOneFrame() 。V2.4.1 

【功能新增】 

￿ 新增显示一帧图像接口： MV_CC_DisplayOneFrame() 。

￿ 新增高性能取流接口： MV_CC_GetImageBuffer() 。

￿ 新增释放图像缓存接口： MV_CC_FreeImageBuffer() 。

￿ 新增获取相机 64 位int 型节点值接口： MV_CC_GetIntValueEx() 。

￿ 新增设置相机 64 位int 型节点值接口： MV_CC_SetIntValueEx() 。

￿ 新增清除 GenICam 节点缓存接口： MV_CC_InvalidateNodes() 。

# V2.4.0 

【功能新增】 

￿ 新增 140 个DotNet 接口。 

￿ 新增注册设备 Event 事件回调函数接口： MV_CC_RegisterAllEventCallBack() 和

MV_CC_RegisterEventCallBackEx() 。

￿ 新增 GigE 相机传输模式设置接口： MV_GIGE_SetTransmissionType() 。

￿ 新增相机文件读写接口： MV_CC_FileAccessRead() 和 MV_CC_FileAccessWrite() 。

￿ 新增图片保存接口： MV_CC_SaveImageEx2() 。

￿ 新增 SDK 日志路径设置接口： MV_CC_SetSDKLogPath() 。

￿ 新增相机 Enum 型节点设置接口： MV_CC_SetEnumValueByString() 。

# V2.2.0.3 

【功能新增】 

￿ 在Win10 系统对接 Gige 相机，新增驱动支持。 

￿ MV_CC_GetOneFrameTimeout() 新增支持 U3V 相机。 

￿ 新增枚举子网内指定的传输协议和指定厂商的所有设备的接口： 

MV_CC_EnumDevicesEx() 。

￿ 新增强制设置相机网络参数扩展接口： MV_GIGE_ForceIpEx() 。V2.1.2.2 

【功能新增】 

￿ 新增 Win64 版本 SDK 。

￿ 新增转换像素格式的接口： MV_CC_ConvertPixelType() 。

￿ 新增获取 RGB 数据的接口： MV_CC_GetImageForRGB() 、

MV_CC_RegisterImageCallBackForRGB() 。

￿ 新增获取 BGR 数据的接口： MV_CC_GetImageForBGR() 、

MV_CC_RegisterImageCallBackForBGR() 。

# V2.1.1.4 

【功能新增】 

￿ 新增采用超时机制获取一帧图片的接口： MV_CC_GetOneFrameTimeout() ，仅 GIGE 相机支持。 

￿ SDK 中GenICam 库版本从 V2.4 更新到 V3.0 。

￿ 在win10 系统对接 Gige 相机，不支持安装驱动，走套接字模式通过网络协议对接。 

# V2.1.0.1 

【功能新增】 

￿ 新增无日志句柄创建接口： MV_CC_CreateHandleWithoutLog() 

￿ 新增相机心跳超时时间配置接口： MV_CC_GetHeartBeatTimeout() 、

MV_CC_SetHeartBeatTimeout() 。

￿ 新增设置 GVCP 命令超时时间接口： MV_GIGE_SetGvcpTimeout() 。

￿ 新增图片数据格式转换接口： MV_CC_SaveImage() 、 MV_CC_SaveImageEx() （支持 设置 JPEG 编码质量）。 

￿ 新增相机行频配置接口： MV_CC_GetAcquisitionLineRate() 、

MV_CC_SetAcquisitionLineRate() 。

￿ 新增相机一次触发帧数配置接口： MV_CC_GetBurstFrameCount() 、

MV_CC_SetBurstFrameCount() 。￿ 新增获取图像数据的扩展接口（支持获取 chunk 信息）： MV_CC_GetOneFrameEx() 、

MV_CC_RegisterImageCallBackEx() 。

￿ 新增设置重发包属性接口： MV_GIGE_SetResend() 。

￿ 新增注册 Event 事件回调接口： MV_CC_RegisterEventCallBack() 。

￿ 新增通用配置接口： 

o int 类型： MV_CC_GetIntValue() 、 MV_CC_SetIntValue() 。

o string 类型： MV_CC_GetStringValue() 、 MV_CC_SetStringValue() 

o bool 类型： MV_CC_GetBoolValue() 、 MV_CC_SetBoolValue() 。

o float 类型： MV_CC_GetFloatValue() 、 MV_CC_SetFloatValue() 。

o Enum 类型： MV_CC_GetEnumValue() 、 MV_CC_GetEnumValue() 。

o Command 类型： MV_CC_SetCommandValue() 。

￿ MV_CC_DEVICE_INFO （设备信息）中联合体 SpecialInfo 里面新增结构体参数 

stUsb3VInfo （USB 设备信息）。 

# V2.0.0.3 

【功能新增】 

￿ 新增注册图像数据回调函数接口： MV_CC_RegisterImageCallBack() 。

￿ 新增设备用户 ID 配置接口： MV_CC_GetDeviceUserID() 、 MV_CC_SetDeviceUserID() 

。

￿ 新增 SDK 内部图像缓存节点个数设置接口： MV_CC_SetImageNodeNum() 。

￿ 新增白平衡参数配置接口： MV_CC_GetBalanceWhiteAuto() 、

MV_CC_SetBalanceWhiteAuto() 、 MV_CC_GetBalanceRatioRed() 、

MV_CC_SetBalanceRatioRed() 、 MV_CC_GetBalanceRatioGreen() 、

MV_CC_SetBalanceRatioGreen() 、 MV_CC_GetBalanceRatioBlue() 、

MV_CC_SetBalanceRatioBlue() 。

￿ 新增 Gamma 参数配置接口： MV_CC_GetGammaSelector() 、

MV_CC_SetGammaSelector() 、 MV_CC_GetGamma() 、 MV_CC_SetGamma() 。

￿ 新增色彩参数配置接口： MV_CC_GetSharpness() 、 MV_CC_SetSharpness() 、

MV_CC_GetHue() 、 MV_CC_SetHue() 、 MV_CC_GetSaturation() 、

MV_CC_SetSaturation() 。￿ 新增触发参数配置接口： MV_CC_GetTriggerSource() 、 MV_CC_SetTriggerSource() 

、 MV_CC_GetTriggerDelay() 、 MV_CC_SetTriggerDelay() 。

￿ 新增软件触发控制接口： MV_CC_TriggerSoftwareExecute() 。

【文档调整】 

￿ 修改接口返回值说明，包括宏定义、宏定义值和描述。 

# V2.0.0.1 

【功能新增】 

￿ 新增 C接口的实现，包括 SDK 版本信息获取、设备连接、图像采集和显示、参数配置、升 级、寄存器读写、 XML 解析等相关接口。 

￿ 新增支持 U3V 设备。 

￿ 新增错误码： 0x800000A1~0x800000A5 、0x800000ff 、0x80000210~0x80000213 、

0x80000301~0x80000304 。

【功能调整】 

￿ 获取 SDK 版本接口 MV_CC_GetSDKVision() 名称修改为 MV_CC_GetSDKVersion() 。

# V1.0.0.1 

【功能新增】 

￿ 实现 C++ 接口，包括传输层工厂类、设备控制类、 GenApi 基本接口。 

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 编程引导 

￿ 配置开发环境 

￿ 开发前必读 

o 相机调用流程 

o 采集卡调用流程 

o 错误处理和错误码 

￿ 初始化 SDK 

￿ 初始化相机 

o 枚举相机 

o 创建相机实例 

o 打开相机 

o 参数设置（可选） 

o 关闭相机 

o 销毁相机实例 

￿ 初始化采集卡 

o 枚举采集卡 

o 创建采集卡实例 

o 打开采集卡 

o 设置参数（可选） 

o 关闭采集卡 

o 销毁采集卡实例 

￿ 设置参数 

o 查询节点名称和类型 

o 获取和设置节点 

o GigE 相机专有配置 

o U3V 相机专有配置 

o 串口设备专有配置 

￿ 事件及异常 

￿ 采集图像 o 回调取图 

o 轮询取图 

￿ 处理图像 

o 图像渲染 

o 保存图像 

o 像素格式转换 

o 解码图像 

o 录像 

o 分时曝光拆图 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 配置开发环境 

在您开始二次开发前，请参照本文配置开发环境，将 SDK 引入至您的项目。 

# 开发环境要求 

请确保开发环境符合如下要求： 

￿ 已安装 Visual Studio 2008 或更高版本。 

￿ 已安装客户端。 操作步骤 

1. 在Visual Studio 中，右键单击程序，在弹出菜单中选择 属性 ，进入 属性页 。

2. 在C/C++ -> 常规 -> 附加包含目录 中，将 SDK 的头文件引入至您的项目。 

您可在此处输入头文件（ Includes ）文件夹的绝对路径 C:\Program Files(x86)\ （软件名 称） \Development\Includes ，或通过环境变量 $(MVCAM_COMMON_RUNENV) ，引入 头文件。 

SDK 提供的头文件位于客户端安装路径下的 Development\Includes 文件夹中，具体描述如 下。 

头文件文件名 描述 

CameraParams.h 结构体定义 

MvCameraControl.h 接口文件 

MvErrorDefine.h 错误码定义 

PixelType.h 像素格式定义 

3. 在链接器 -> 常规 -> 附加库目录 中，将 SDK 的库文件路径引入至您的项目。 SDK 提供了适配不同程序的库文件。您可以在客户端安装路径下的 Libraries 文件夹中获取 ，具体描述如下。 

适用程序 库文件相对路径 

32 位 Libraries\win32 

64 位 Libraries\win64 

您可以在 附加库目录 中输入库文件文件夹的绝对路径： 

o 32 位：C:\Program Files(x86)\ （软件名称） \Development\Libraries\win32 。

o 64 位：C:\Program Files(x86)\ （软件名称） \Development\Libraries\win64 。

或通过环境变量 $(MVCAM_COMMON_RUNENV) ：

o 32 位：$(MVCAM_COMMON_RUNENV)\Libraries\win32 。

o 64 位：$(MVCAM_COMMON_RUNENV)\Libraries\win64 。

4. 在链接器 -> 输入 -> 附加依赖项 中，添加 MvCameraControl.lib 。上一篇： 无 下一篇： 开发前必读 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 开发前必读 在开发您的程序前，建议您先了解 SDK 在相机与采集卡的调用流程、调用方式及错误处理，以更好 的实现您的应用程序。 

￿ 相机调用流程 

￿ 采集卡调用流程 

￿ 错误处理和错误码 

# 相机调用流程 

您可通过 SDK ，初始化相机、设置参数并最终实现采集图像。 

在实例生命周期内，相机的基础调用流程如下图所示。 采集卡调用流程 

您可通过 SDK ，初始化采集卡和设置参数等。 

在实例生命周期内，采集卡的基础调用流程如下图所示。 错误处理和错误码 

在您在程序中调用 SDK 接口后，接口会返回一个代表 int 型的状态码。状态码以 16 进制的形式呈现 ，其格式为 “0x%x” 。

如果接口调用正常，且未检测到任何错误，则会返回 “0x00000000” ，代表 “成功，无错误 ”；否则 ，接口将返回错误码。 

注解 

您可在 “MvErrorDefine.h” 文件或 状态码 中，查找错误码及其对应定义和解释。 

您可以参照如下示例，在您的程序中检查接口异常并返回错误信息。 

int nRet = MV_OK ;

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

return nRet; 

}

该例演示了打开相机时，获取 MV_CC_OpenDevice() 的调用情况。 

￿ 若能够正常打开相机，则该例不会返回报错信息。 

￿ 若调用接口时，相机设备已连接至第三方软件，则 MV_CC_OpenDevice() 无法正常打开 相机。此时，该接口会返回如下信息。 

Open Device fail! nRet [0x80000203] 

在获得错误信息和对应状态码后，您可在 状态码 中，查找对应内容。该例中， 

“0x80000203” 代表 “设备无访问权限 ”。

上一篇： 配置开发环境 下一篇： 初始化 SDK 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 初始化 SDK 

在进程中调用 SDK 时，您需要首先初始化 SDK 的运行环境，以提升后续接口调用的流畅性。 

您可参照如下示例代码，在您的进程中初始化 SDK 的运行环境，并在进程退出时反初始化 SDK 。

int main () 

{

int nRet = MV_OK ;

MV_CC_Initialize (); // 1. 程序启动后，初始化 SDK 

// 2. 进行设备发现，控制，图像采集等操作 

MV_CC_Finalize (); // 3. 程序退出时，反初始化 SDK 

return nRet; 

}

1. 调用 MV_CC_Initialize() ，初始化 SDK 的运行环境。该操作可提前申请和分配所必需的 系统资源，确保 SDK 能够可靠地运行。 

2. 在初始化 SDK 后，在此处调用其他接口，以实现初始化相机或采集卡、设置参数、采集和 处理图像等操作。 

3. 在完成所需操作后，调用 MV_CC_Finalize() 进行反初始化，释放 SDK 占用的系统资源。 

注意 

在单个进程中，您仅可执行 MV_CC_Initialize() 和 MV_CC_Finalize() 各一次。 上一篇： 开发前必读 下一篇： 初始化相机 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 初始化相机 

本节介绍如何通过调用相应的 SDK 接口完成相机初始化，实现枚举相机、打开或关闭相机等基础相 机控制功能。在此基础上，您还可以继续配置相机参数，实现图像采集、图像处理等核心功能。 

基本的相机控制流程包含： 

1. 枚举相机 

2. 创建相机实例 

3. 打开相机 

4. 参数设置（可选） 

5. 关闭相机 

6. 销毁相机实例 

# 步骤一：枚举相机 

在控制相机时，您需首先通过 SDK 枚举相机。 枚举相机 

按需调用如下枚举接口（三选一）。不同相机类型的枚举方法相同。 

￿ 选项 1：调用 MV_CC_EnumDevices() 获取设备列表时，需传入对应的设备接口类型 

nTLayerType 。调用成功后，该接口返回对应接口类型的设备列表 pstDevList 。

可选的设备接口类型及对应的枚举设备如下： 

设备接口类型 枚举到的设备 

MV_GIGE_DEVICE 所有 GigE 相机，包含虚拟 GigE 相机和采集卡上 的GigE 相机 

MV_USB_DEVICE 所有 USB 相机，包含虚拟 USB 相机 

MV_CAMERALINK_DEVICE 所有串口设备，包含 Camera Link 相机和串口光 源控制器。 

MV_GENTL_CAMERALINK_DEVICE 所有 Camera Link 采集卡下的 Camera Link 相机 

MV_GENTL_CXP_DEVICE 所有 CoaXPress 采集卡下的 CoaXPress 相机 

MV_GENTL_XOF_DEVICE 所有 XoFLink 采集卡下的 XoFLink 相机 

MV_GENTL_VIR_DEVICE 所有虚拟采集卡下的虚拟相机 

注意 

设备列表的内存直接从 SDK 内部分配。当您调用该接口时， SDK 会进行设备列表内 存申请和释放，因此请避免多线程枚举操作。 

示例代码如下：     

> // 枚举 GigE 和USB 相机
> MV_CC_DEVICE_INFO_LIST stDeviceList;
> memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST ));
> nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE |MV_USB_DEVICE ,&stDeviceList);
> Check(nRet);

￿ 选项 2：调用 MV_CC_EnumDevicesEx() 获取设备列表。相比于普通枚举接口 

MV_CC_EnumDevices() ，调用该接口时可传入厂商名称 strManufacturerName 用来过 滤枚举结果。调用成功后，该接口返回与指定厂商名称匹配的设备列表 pstDevList 。

示例代码如下 :  

> // 枚举指定厂商的 GigE 和USB 相机
> MV_CC_DEVICE_INFO_LIST stDeviceList;

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevicesEx (MV_GIGE_DEVICE |MV_USB_DEVICE ,&stDeviceList, "XXX"); 

Check(nRet); 

￿ 选项 3：调用 MV_CC_EnumDevicesEx2() 获取设备列表。相比于普通枚举接口 

MV_CC_EnumDevices() ，调用该接口时您可以： 

o 传入 strManufacturerName 过滤枚举结果，并获取与指定厂商名称匹配的设备列表 

devInfoList 。若 strManufacturerName 设置为 NULL ，则返回所有厂商的设备列表 。

o 对返回的设备列表进行排序。支持多种排序方式，如根据序列号排序、根据相机 

IP 地址排序等。 

o 严格按照枚举类型 nTLayerType 枚举设备。例如，当设备接口类型设置为 

MV_GIGE_DEVICE 时，仅枚举同网段内的 GigE 相机，不包含虚拟 GigE 相机和 

GigE 采集卡所连接的相机。 

示例代码如下 :

// 枚举 GigE 和USB 相机，并按照设备序列号排序。 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevicesEx2 (MV_GIGE_DEVICE |MV_USB_DEVICE ,&stDeviceList,NULL, SortMethod_SerialNumber ); 

Check(nRet); 

GigE 和串口设备枚举时间优化 

您可以参照如下内容，在程序中优化 GigE 和串口设备的枚举时间。 

￿ GigE 相机枚举时间设置 

当枚举 GigE 相机时， SDK 会遍历网卡，并且在向每个网卡发送枚举命令的同时接收响应 结果。若等待超时，则 SDK 会对下一个网卡进行枚举。当前超时时间是 100ms ，如果环境 中存在较多网卡，则枚举时间会相对较长。该情况下，您可以根据实际情况减少每个网卡 的枚举超时时间，从而减少枚举 GigE 设备的整体耗时。 

如下示例代码演示了如何配置 GigE 相机的枚举超时时间并按照设备序列号给枚举出的 

GigE 相机排序： 

// 配置 GigE 相机的枚举超时时间（单位 ms ）

Unsigned int nMilTimeout = 50; nRet = MV_CC_SetEnumDevTimeout(nMilTimeout); 

Check(nRet); 

// 枚举 GigE 相机，并按照设备序列号排序。 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevicesEx2 (MV_GIGE_DEVICE , &stDeviceList,NULL, 

SortMethod_SerialNumber ); 

Check(nRet); 

￿ 串口设备枚举时间优化 

串口设备通过串口进行通信。若工控机上提供多个串口，在枚举时， SDK 会遍历所有串口 以查找所需设备。又因串口通信速度较慢，遍历串口可能导致枚举操作的整体耗时较长。 

此时，您可以通过以下方法进行优化。 

1. 调用 MV_CAML_GetSerialPortList() 获取当前 PC 的所有串口列表。 

2. 调用 MV_CAML_SetEnumSerialPorts() 设置枚举部分指定串口。 

3. 调用 MV_CC_EnumDevices() 枚举接口，枚举串口设备。 

示例代码如下： 

// 获取当前 PC 的所有串口 

MV_CAML_SERIAL_PORT_LIST stCurrentSerialPortList; 

nRet = MV_CAML_GetSerialPortList (&stCurrentSerialPortList); 

Check(nRet); 

MV_CAML_SERIAL_PORT_LIST stEnumSerialPortList; 

// 设置只枚举指定的一个（或者多个）串口 

stEnumSerialPortList. nSerialPortNum = 1; 

memcpy(stEnumSerialPortList. stSerialPort [0]. chSerialPort ,stCurren tSerialPortList. stSerialPort [0]. chSerialPort ,strlen((const char *)stCurrentSerialPortList. stSerialPort [0]. chSerialPort )); 

nRet = MV_CAML_SetEnumSerialPorts (&stEnumSerialPortList); 

Check(nRet); 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

// 枚举串口设备 

nRet = MV_CC_EnumDevices ( MV_CAMERALINK_DEVICE , &stDeviceList); 

Check(nRet); 

# 步骤二：创建相机实例 可根据如下方式创建相机实例。 

调用 MV_CC_CreateHandle() 创建相机实例。调用该接口时需传入设备信息 pstDevInfo 。该接口 可根据传入的设备信息创建不同的相机实例。 

示例代码如下： 

void* handle = NULL; 

// 选择设备并创建句柄 

nRet = MV_CC_CreateHandle (& handle , stDeviceList. pDeviceInfo [nIndex]); 

Check(nRet); 

# 步骤三：打开相机 

“打开相机 ”指建立相机实例与物理相机的连接，使相机实例获得物理相机的访问权限，实现相机 实例与物理相机的通信。 

￿ 选项 1：调用 MV_CC_OpenDevice() 打开相机。该方式默认相机实例独占物理相机的访 问权限。 

示例代码如下： 

// 打开相机 

nRet = MV_CC_OpenDevice (handle ); 

Check(nRet); 

￿ 选项 2：调用 MV_CC_OpenDevice() 打开 GigE 相机。调用时需传入访问权限 

nAccessMode 和切换访问权限时的密钥 nSwitchoverKey ，使用指定访问权限打开设备。 

注意 

该方式仅适用于打开 GigE 相机或通过 GEV 采集卡连接的各相机，不支持打开其他设 备。 

示例代码如下： 

unsigned int nAccessMode = MV_ACCESS_Control ;

unsigned short nSwitchoverKey = 0; 

// 打开相机 

nRet = MV_CC_OpenDevice (handle , nAccessMode, nSwitchoverKey); 

Check(nRet); 步骤四：设置参数（可选） 

打开相机后，您可以： 

￿ 配置设备参数。详情参见 设置参数 章节。 

￿ 获取设备通知事件或者异常告警事件。详情参见 事件及异常 章节。 

￿ 实现图像采集相关功能。详情参见 采集图像 章节。 

￿ 实现图像采集之后，还可进一步实现各种图像处理操作。详情参见 处理图像 章节。 

# 步骤五：关闭相机 

若相机实例不再需要与物理相机通信，您可以调用 MV_CC_CloseDevice() 关闭相机。 

示例代码如下： 

// 关闭相机 

nRet = MV_CC_CloseDevice (handle ); 

Check(nRet); 

# 步骤六：销毁相机实例 

调用 MV_CC_DestroyHandle() 销毁相机实例，并释放相机实例所占用的资源。 

注意 

调用该接口后，原先的相机实例将失效，不能再用于其他接口的调用。 

示例代码如下： 

// 销毁句柄 

nRet = MV_CC_DestroyHandle (handle ); 

Check(nRet); 

上一篇： 初始化 SDK 下一篇： 初始化采集卡 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 初始化采集卡 

本节介绍如何调用 SDK 接口，在您的程序上实现采集卡控制功能，例如枚举、打开、配置和关闭采 集卡。 

基本的采集卡控制流程包含： 

1. 枚举采集卡 

2. 创建采集卡实例 

3. 打开采集卡 

4. 设置参数（可选） 

5. 关闭采集卡 

6. 销毁采集卡实例 

# 前提条件 

在继续前，确保您已初始化 SDK 。详情请参见 初始化 SDK 。

# 步骤一：枚举采集卡 您可以调用 MV_CC_EnumInterfaces() 并传入采集卡接口类型 nTLayerType ，以获取对应类型 采集卡列表（ pInterfaceInfoList ）。 

该例演示了枚举 CoaXPress 和XoFLink 类型的采集卡。 

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumInterfaces (MV_CXP_INTERFACE |MV_XOF_INTERFACE ,&stInterfaceInfoList); // 在nTLayerType 处传入 “MV_CXP_INTERFACE” 和

“MV_XOF_INTERFACE” 

Check(nRet); 

注解 

采集卡接口类型详情如下： 

采集卡接口类型定义 值 说明 

MV_GIGE_INTERFACE 0x00000001 GigE Vision 采集卡 

MV_CAMERALINK_INTERFACE 0x00000004 Camera Link 采集卡 

MV_CXP_INTERFACE 0x00000008 CoaXPress 采集卡 

MV_XOF_INTERFACE 0x00000010 XoFLink 采集卡 

MV_VIR_INTERFACE 0x00000020 虚拟采集卡 

MV_LC_INTERFACE 0x00000040 光源控制卡 

# 步骤二：创建采集卡实例 

您可通过采集卡设备信息或采集卡设备 ID ，创建采集卡实例。 

￿ 选项 1：调用 MV_CC_CreateInterface() ，输入采集卡设备信息 pInterfaceInfo 。接口 根据传入的设备信息，创建对应的采集卡实例。 

void* hInterface = NULL; 

// 创建采集卡句柄 

nRet = MV_CC_CreateInterface (& hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

Check(nRet); 

￿ 选项 2：调用 MV_CC_CreateInterfaceByID() ，输入采集卡 ID pInterfaceID ，获取采集 卡实例。其中， ID 可以是设备序列号。 

注解 通过此方式创建采集卡实例时，您不需要预先 枚举采集卡 ，直接传入采集卡序列 号即可。 

如下示例代码演示了通过 MV_CC_CreateInterfaceByID() 枚举设备序列号为 

“DA1433238” 的采集卡。 

void* hInterface = NULL; 

const char *pInterfaceID = "DA1433238"; 

// 创建采集卡句柄 

nRet = MV_CC_CreateInterfaceByID (& hInterface , pInterfaceID); 

Check(nRet); 

# 步骤三：打开采集卡 

“打开采集卡 ”指建立采集卡实例与物理采集卡的连接，使采集卡实例获得物理采集卡的访问权限 ，实现与物理采集卡通信。 

您可调用 MV_CC_OpenInterface() 打开采集卡。若返回值为 MV_OK ，则表示打开成功，否则 打开失败。 

// 打开采集卡 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

Check(nRet); 

# （可选）步骤四：配置参数 

打开采集卡后，您可调用对应的 SDK 接口： 

￿ 实现采集卡参数配置功能。详情请参见 参数设置 。

￿ 获取采集卡事件。详情请参见 事件及异常 。

# 步骤五：关闭采集卡 

若采集卡实例不再需要与物理采集卡通信，可调用 MV_CC_CloseInterface() 关闭采集卡。 

示例代码如下： // 关闭设备 

nRet = MV_CC_CloseInterface (hInterface ); 

Check(nRet); 

# 步骤六：销毁采集卡实例 

调用 MV_CC_DestroyInterface() 销毁采集卡实例，释放实例占用的资源。 

注意 

在您销毁采集卡实例后，先前的实例失效，不可用于其他接口的调用。 

示例代码如下： 

// 销毁句柄 

nRet = MV_CC_DestroyInterface (hInterface ); 

Check(nRet); 

注解 

在使用 SDK 实现功能后，您需及时反初始化 SDK ，以释放 SDK 占用的系统资源。详情请 参见 初始化 SDK 。

上一篇： 初始化相机 下一篇： 设置参数 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

# 设置参数 

SDK 通过 GenICam 标准协议实现读取和设置设备参数，并提供了一套相机和采集卡均通用的参数配 置接口。通过接口，您可获取和配置包括整型、枚举型、浮点型、布尔型、字符串型和命令型总共 

6种类型的参数节点。 

本节内容包含： 

￿ 查询节点名称和类型 

￿ 获取和设置节点 

￿ GigE 相机专有配置 

￿ U3V 相机专有配置 

￿ 串口设备专有配置 

# 查询节点名称和类型 

调用用于 获取和设置节点 的接口时，您需传入节点名称和节点类型。 

您可通过客户端查询节点的名称和类型。 

1. 通过客户端连接设备。 

2. 在客户端属性树上选中某个属性的参数，即可在属性下方查看该参数的节点信息。 

注解 

若您使用的客户端版本高于等于 4.4.0 ，您还可以查看节点的调用示例。 

下图以 Width 参数为例。 注解 

更多操作详情，请参见客户端用户手册。 

# 获取和配置节点 

您可参照本节的示例代码，在您的程序中获取和配置节点值。 

您可配置总共 6种类型的参数节点，包括： 整型 、枚举型 、浮点型 、布尔型 、字符串型 和命令型 。

￿ 整型节点 ：o 调用 MV_CC_GetIntValueEx() 获取整型节点。 

o 调用 MV_CC_SetIntValueEx() 配置整型节点。 

const char* strNodeName = "Width"; 

// 获取整型节点 

MVCC_INTVALUE_EX stIntValue; 

int nRet = MV_CC_GetIntValueEx (handle , strNodeName ,&stIntValue); 

Check(nRet); 

// 设置整型节点 

nRet = MV_CC_SetIntValueEx (handle , strNodeName ,stIntValue. nCurValue ); 

Check(nRet); 

￿ 枚举型节点 ：

o 调用 MV_CC_GetEnumValue() 获取枚举型节点。 

o 调用 MV_CC_SetEnumValue() 设置枚举型节点。 

o 调用 MV_CC_GetEnumEntrySymbolic() 获取枚举型节点指定的符号。 

o 调用 MV_CC_SetEnumValueByString() 设置枚举型属性值。 

const char* strNodeName = "PixelFormat"; 

MVCC_ENUMENTRY stEnumEntry; 

MVCC_ENUMVALUE stEnumValue; 

// 获取枚举型节点 

nRet = MV_CC_GetEnumValue (handle , strNodeName, &stEnumValue); 

Check(nRet); 

// 获取枚举型节点的符号 

stEnumEntry. nValue = stEnumValue. nCurValue ;

nRet = MV_CC_GetEnumEntrySymbolic (handle , strNodeName, &stEnumEntry); 

Check(nRet); 

// 设置枚举型节点 

nRet = MV_CC_SetEnumValue (handle , strNodeName ,stEnumValue. nCurValue ); 

Check(nRet); 

// 设置枚举型属性值 

const char* strValue = "Mono8" 

nRet = MV_CC_SetEnumValueByString (handle , strNodeName, strValue); 

Check(nRet); ￿ 浮点型节点 ：

o 调用 MV_CC_GetFloatValue() 获取浮点型节点。 

o 调用 MV_CC_SetFloatValue() 设置浮点型节点。 

const char* strNodeName = "ExposureTime"; 

// 获取浮点型节点 

MVCC_FLOATVALUE FloatValue; 

int nRet = MV_CC_GetFloatValue (handle , strNodeName , &FloatValue); 

Check(nRet); 

// 设置浮点型节点 

nRet = MV_CC_SetFloatValue (handle , strNodeName , FloatValue. fCurValue ); 

Check(nRet); 

￿ 布尔型节点 ：

o 调用 MV_CC_GetBoolValue() 获取布尔型节点。 

o 调用 MV_CC_SetBoolValue() 设置布尔型节点。 

const char* strNodeName = "GammaEnable"; 

// 获取布尔型节点 

bool bValue = false; 

int nRet = MV_CC_GetBoolValue (handle , strNodeName , &bValue); 

Check(nRet); 

// 设置布尔型节点 

nRet = MV_CC_SetBoolValue (handle , strNodeName , bValue); 

Check(nRet); 

￿ 字符串型节点 ：

o 调用 MV_CC_GetStringValue() 获取字符串型节点。 

o 调用 MV_CC_SetStringValue() 设置字符串型节点。 const char* strNodeName = "DeviceUserID"; 

// 获取字符串型节点 

MVCC_STRINGVALUE StringValue; 

int nRet = MV_CC_GetStringValue (handle , strNodeName , &StringValue); 

Check(nRet); 

// 设置字符串型节点 

nRet = MV_CC_SetStringValue (handle , strNodeName , StringValue. chCurValue ); 

Check(nRet); 

￿ 命令型节点 ：调用 MV_CC_SetCommandValue() 设置命令型节点。 

const char* strNodeName ="UserSetLoad"; 

// 设置命令型节点 

nRet = MV_CC_SetCommandValue (handle , strNodeName ); 

Check(nRet); 

# GigE 相机专有配置 

若您使用的相机为 GigE 相机，您可 设置最佳包大小 和设置重发包 。

￿ 设置最佳包大小 

在打开 GigE 相机并开始取流前，您可通过 MV_CC_GetOptimalPacketSize() 探测当前网 络，获取当前网络最佳通信的数据包大小。 

您可以使用该数据包大小配置相机发送流数据时的数据包大小，从而充分利用带宽并提高 流数据的传输速度。 

// 探测网络最佳包大小（仅支持 GigE 相机） 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{// 配置相机的包大小 

> nRet =
> MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize );
> Check(nRet);
> }
> }

￿ 设置重发包 

GigE 设备通过网络进行数据通信，在网络拥塞等异常情况下，可能造成 SDK 侧收到的数 据包不完整。可以通过重发命令控制设备对不完整部分进行重传。 

注意 

o 重发包需要相机支持，才可以使用。 

o 网络偶尔拥塞时，您可通过重发解决偶尔丢包问题。 

o 网络持续拥塞时，建议您首先排查并优化网络。若直接开启重发包，可能 会造成网络拥塞加剧，请谨慎使用。 

o 您可参考如下示例，在应用程序中调用 MV_GIGE_SetResend() 开启重发包功能 。       

> unsigned int bEnable = true; // 1. 是否开启重发包
> unsigned int nMaxResendPercent = 10; // 2. 最大重发比
> unsigned int nResendTimeout = 50; // 3. 重发超时时间，单 位ms
> nRet = MV_GIGE_SetResend (handle , bEnable, nMaxResendPercent, nResendTimeout);
> Check(nRet);

1. bEnable ，代表是否开启重发包功能。 

2. nMaxResendPercent ，设置重发当前帧丢包数据的比例，超过部分不重 发，以避免加剧网络拥塞。当该值设置为 100 时， SDK 重发当前帧的所有 丢包。 

3. nResendTimeout ，设置重发包超时时间。在当前帧结束后开始计时，若 计时时间超出该值，则 SDK 不再请求重发该丢包数据。 

o 在发送重发命令后，若 SDK 未收到设备响应和重发的数据，您需要控制 SDK 继续 发送重发请求。 

您可参考如下示例，调用 MV_GIGE_SetResendTimeInterval() 控制单个重发包 的间隔和 MV_GIGE_SetResendMaxRetryTimes() 设置最大重发次数。 // 配置重发包间隔 

unsigned int nMillisec = 10; 

nRet = MV_GIGE_SetResendTimeInterval (handle , nMillisec); 

Check(nRet); 

// 配置重发包最大重发的次数 

unsigned int nRetryTimes = 20; 

nRet = MV_GIGE_SetResendMaxRetryTimes (handle ,nRetryTimes); 

Check(nRet); 

￿ nMillisec ，重发包间隔默认 10ms ，代表两次重传命令请求的时间间隔。 时间间隔越小，占用的网络资源越多，网络和设备压力越大。 

￿ nRetryTimes ，默认值 20 ，表示对于单个丢包数据， SDK 最多请求 20 次重 传命令。 

# U3V 相机专有配置 

若您使用的相机为 U3V 相机，您可调节其 控制链路 和流链路 ，以兼容和解决对应的异常。 

￿ 控制链路用于传入控制命令。若控制链路异常，可能导致传输控制命令慢，导致接口超时 返回异常。 

此时，您可参照如下代码示例，在您的程序中调用 MV_USB_SetSyncTimeOut() 调节控 制链路的超时时间，从而兼容对此类异常进行兼容。 

// 默认超时时间 1000ms 

unsigned int nMills = 1000; 

// 设置 U3V 相机同步读写超时时间 

nRet = MV_USB_SetSyncTimeOut (handle ,nMils); 

Check(nRet); 

￿ 流链路用于传入流数据。若流链路带宽不足或系统资源不足，可能导致传输失败、资源创 建失败。 

您可参照如下代码示例，在您的程序中调用 MV_USB_SetTransferSize() 调节流数据包 的大小，或调用 MV_USB_SetTransferWays() 调节 U3V 流通道个数，减少资源占用。 

// 配置 U3V 相机流数据的最大数据包大小 

unsigned int nTransferSize = 1*1024*1024; // 默认 1MB nRet = MV_USB_SetTransferSize (handle ,nTransferSize); 

Check(nRet); 

// 配置 SDK 内部 U3V 的流通道缓存个数 

Unsigned int nTransferWay = 2; 

nRet = MV_USB_SetTransferWays (handle ,nTransferWay); 

Check(nRet); 

# 串口设备专有配置 

串口设备通过串口连接，并且通信协议符合 GenCP 协议。对于此类设备，您可通过 

MV_CAMERALINK_DEVICE() 类型枚举。 

注解 

当前，串口设备包括：光源控制器和 Camera Link 相机。 

当设备通过串口通信时，您可以改变波特率，从而优化传输速度。具体步骤如下： 

1. 调用 MV_CAML_GetSupportBaudrates() 获取当前设备和主机之间支持的波特率。 

2. 调用 MV_CAML_SetDeviceBaudrate() 设置设备的波特率。 

// 获取主机和当前设备支持的波特率 

unsigned int nBaudrateAblity = 0; 

nRet = MV_CAML_GetSupportBaudrates (handle ,&nBaudrateAblity); 

Check(nRet); 

// 检测是否支持，并配置 115200 波特率 

if (nBaudrateAblity & MV_CAML_BAUDRATE_115200 )

{

nRet = MV_CAML_SetDeviceBaudrate (handle ,MV_CAML_BAUDRATE_115200 ); 

Check(nRet); 

}

上一篇： 初始化采集卡 下一篇： 事件及异常 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 事件及异常 

事件可分为正常通知事件和异常告警事件。 

￿ 正常通知事件指相机或采集卡处于正常状态下出现的事件。根据事件生成条件的差异，让 设备上报事件至您的程序的操作有所差异。 

o 部分事件需在相机或连接至采集卡的相机开始取流后才可触发。对于此类事件，您 在程序中调用事件相关接口订阅并启用指定事件后，需调用 

MV_CC_StartGrabbing() 让相机开始取流，从而让设备上报取流相关的事件至您 的程序。 

o 部分事件无需取流即可上报。您可调用事件相关接口订阅并启用指定事件，让设备 上报事件至您的程序。 

￿ 异常告警事件是在相机、采集卡或者 SDK 运行时产生的异常事件（例如相机掉线等），此 类事件可直接从 SDK 中获取，可用于及时预警，排除异常情况。 

当相机或者采集卡打开成功后，即可注册自定义的异常告警事件处理函数。注册成功后， 当设备产生异常告警时，将自动执行自定义的异常告警处理函数。 

# 事件采集 

您可以依次通过订阅、启用、获取、关闭和取消订阅正常通知事件，完成事件的处理流程。 注解 

若要获取正常通知事件，需先通过客户端配置相机或采集卡。 

￿ 相机配置操作详情参见客户端用户手册。 

￿ 采集卡事件可以通过采集卡事件配置工具进行配置。 

1. 订阅 ：可通过调用 MV_CC_RegisterEventCallBackEx() 订阅指定事件。调用该接口时 需传入事件名称 StrEventName 。

2. 启用 ：可通过调用 MV_CC_EventNotificationOn() 启用指定事件。 

3. 获取 ：当相机或采集卡生成一个事件时， SDK 会触发对应的事件回调函数并将该事件信息 推送给用户。一般情况下，推送给用户的事件信息中包含事件名称、事件 ID 和时间戳等关 键信息，其他信息如帧号和事件数据等则不一定包含。不同事件所包含的信息会存在差异 ，请以实际情况为准。 

注意 

请勿通过事件回调函数执行耗时较长的操作，否则将导致后续事件信息的推送被阻 塞。 

4. 关闭 ：可通过调用 MV_CC_EventNotificationOff() 关闭指定事件。 

5. 取消订阅 ：可通过调用 MV_CC_RegisterEventCallBackEx() 取消订阅指定事件。调用 该接口时需传入事件名称 strEventName ，并将事件回调指针 cbEvent 设置为 NULL 。调用 成功后，则取消订阅指定事件。 

如下示例代码演示了相机 "曝光结束 "事件的处理全过程。            

> // 事件回调函数
> void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser)
> {
> if (pEventInfo)
> {
> __int64 nBlockId = pEventInfo-> nBlockIdHigh ;
> nBlockId = (nBlockId << 32) + pEventInfo-> nBlockIdLow ;
> __int64 nTimestamp = pEventInfo-> nTimestampHigh ;
> nTimestamp = (nTimestamp << 32) + pEventInfo-> nTimestampLow ;
> printf("EventName[%s], EventID[%u], BlockId[%I64d], Timestamp[%I64d]\n",
> pEventInfo-> EventName , pEventInfo->nEventID ,nBlockId,nTimestamp);
> }
> }
> int main ()
> {

int nRet = MV_OK ;

// 程序启动后初始化 SDK 

MV_CC_Initialize () ; 

// 枚举设备，创建相机实例 

// 打开相机 

nRet = MV_CC_OpenDevice (handle ); 

Check(nRet); 

// 订阅相机曝光结束事件 

nRet = MV_CC_RegisterEventCallBackEx (handle , "ExposureEnd", 

EventCallBack , handle ); 

Check(nRet); 

// 启用相机曝光结束事件 

nRet = MV_CC_EventNotificationOn (handle ,"ExposureEnd"); 

Check(nRet); 

// 开始取流 

nRet = MV_CC_StartGrabbing (handle ); 

Check(nRet); 

// 停止取流 

nRet = MV_CC_StopGrabbing (handle ); 

Check(nRet); 

// 关闭相机曝光结束事件 

nRet = MV_CC_EventNotificationOff (handle ,"ExposureEnd"); 

Check(nRet); 

// 订阅相机曝光结束事件 

nRet = MV_CC_RegisterEventCallBackEx (handle , "ExposureEnd", NULL, 

handle ); 

Check(nRet); 

// 关闭设备 

nRet = MV_CC_CloseDevice (handle ); 

Check(nRet); 

// 销毁句柄 nRet = MV_CC_DestroyHandle (handle ); 

Check(nRet); 

// 反初始化 SDK 

MV_CC_Finalize (); 

return nRet; 

}

注解 

枚举设备和创建相机实例步骤的示例代码可参考 初始化相机 章节。 

如下示例代码演示了采集卡 "帧开始 "事件的处理全过程。 

// 事件回调函数 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser) 

{

if (pEventInfo) 

{

__int64 nBlockId = pEventInfo-> nBlockIdHigh ;

nBlockId = (nBlockId << 32) + pEventInfo-> nBlockIdLow ;

__int64 nTimestamp = pEventInfo-> nTimestampHigh ;

nTimestamp = (nTimestamp << 32) + pEventInfo-> nTimestampLow ;

printf("EventName[%s], EventID[%u], BlockId[%I64d], Timestamp[%I64d]\n", 

pEventInfo-> EventName , pEventInfo->nEventID ,nBlockId,nTimestamp); 

}

}

int main () 

{

int nRet = MV_OK ;

// 程序启动后初始化 SDK 

MV_CC_Initialize () ; 

// 枚举设备，创建采集卡实例 

// 打开采集卡 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

Check(nRet); 

// 订阅采集卡 ”帧开始 ”事件 

nRet = MV_CC_RegisterEventCallBackEx (hInterface , "FrameStart", 

EventCallBack , hInterface ); 

Check(nRet); // 启用采集卡 ”帧开始 ”事件 

nRet = 

MV_CC_EventNotificationOn (hInterface ,"ReceiveImageFrameStart0"); 

Check(nRet); 

// 进行其他处理 

// 关闭采集卡 ”帧开始 ”事件 

nRet = 

MV_CC_EventNotificationOff (hInterface ,"ReceiveImageFrameStart0") ;

Check(nRet); 

// 取消订阅 采集卡 ”帧开始 ”事件 

nRet = MV_CC_RegisterEventCallBackEx (hInterface , "FrameStart", NULL, hInterface ); 

Check(nRet); 

// 关闭设备 

nRet = MV_CC_CloseInterface (hInterface ); 

Check(nRet); 

// 销毁句柄 

nRet = MV_CC_DestroyInterface (hInterface ); 

Check(nRet); 

// 反初始化 SDK 

MV_CC_Finalize (); 

return nRet; 

}

注解 

枚举设备和创建采集卡实例步骤的示例代码可参考 初始化采集卡 章节。 

# 异常事件 

异常告警事件可直接从 SDK 中获取。该类型事件的处理流程包括注册、获取和注销。 

1. 注册 ：通过函数 MV_CC_RegisterExceptionCallBack() 注册异常事件，若出现异常情 况时，则异常会及时上报给 SDK 。

2. 获取 ：当 SDK 出现异常时，会触发异常事件回调函数。该函数可将异常告警事件推送给 用户。 注意 

请勿通过异常事件回调函数执行耗时较长的操作，否则将导致后续事件信息的推 送被阻塞。 

3. 注销 ：调用 MV_CC_RegisterExceptionCallBack() 注销异常告警事件。当异常回调函 数为 NULL 时，可取消采集卡或相机实例的设备异常事件。 

如下示例代码演示了如何订阅、处理和取消订阅异常事件。 

// 异常事件回调函数 

void __stdcall ExceptionCallBack(unsigned int nMsgType, void* pUser) 

{

if(nMsgType == MV_EXCEPTION_DEV_DISCONNECT )

{

printf("ExceptionCallBack Recv Type[%d]\n", nMsgType); 

// 可以进行异常处理，比如关闭相机，销毁句柄，重新枚举相机，打开相机 等;

}

}

int main () 

{

int nRet = MV_OK ;

// 程序启动后调用 "初始化 SDK" 

MV_CC_Initialize () ; 

// 枚举设备，创建实例 

// 打开相机 

nRet = MV_CC_OpenDevice (handle ); 

Check(nRet); 

// 注册异常消息回调 

nRet = MV_CC_RegisterExceptionCallBack (handle ,ExceptionCallBack, handle ); 

Check(nRet); 

// 开始取流 

nRet = MV_CC_StartGrabbing (handle ); 

Check(nRet); 

// 停止取流 

nRet = MV_CC_StopGrabbing (handle ); Check(nRet); 

// 注销异常消息回调 

nRet = MV_CC_RegisterExceptionCallBack (handle , NULL, 

handle ); 

Check(nRet); 

// 关闭设备 

nRet = MV_CC_CloseDevice (handle ); 

Check(nRet); 

// 销毁句柄 

nRet = MV_CC_DestroyHandle (handle ); 

Check(nRet); 

// 反初始化 SDK 

MV_CC_Finalize (); 

return 0; 

}

注解 

枚举设备和创建实例步骤的示例代码参见 初始化采集卡 章节或 初始化相机 章节。 

# 事件缓存调节 

GigE 相机产生的事件使用 socket 缓冲区，不需要额外配置缓存区，而 U3V 设备产生的事件通过 事件端点或链路上报。在 SDK 内部，默认有 5个缓存节点可以接收事件。若上层软件处理速度较 慢或者设备上报事件的频率较高，则可能导致 SDK 内部缓存不足，导致丢事件的情况发生。此 时，您可以通过 MV_USB_SetEventNodeNum() 修改 U3V 相机 SDK 内部的事件缓存节点数量 。

// 调节 SDK 内部 U3V 设备的 Event 事件缓存节点数量 

unsigned int nEventNodeNum = 5; 

nRet = MV_USB_SetEventNodeNum (handle , nEventNodeNum); 

Check(nRet); 

上一篇： 设置参数 下一篇： 采集图像 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 采集图像 

SDK 支持回调取图或轮询取图方式采集图像。您可根据实际使用情况，选择所需的采集方式。 

￿ 回调取图 ：通过回调函数采集图像。 

￿ 轮询取图 ：通过轮询调用取图接口采集图像。 

注意 

您仅可使用其中一种采集方式，不支持同时使用以上方式。 

# 回调取图 

SDK 提供注册回调取图接口，您可在 SDK 内部注册自定义的回调函数。在 SDK 获取到相机图像后 ，SDK 会主动调用您自定义的回调函数。 

使用场景 ：您可以调用 MV_CC_RegisterImageCallBackEx() 注册回调函数。 

注意 

￿ 不建议您在回调函数中添加耗时操作、线程锁等。若添加，易造成回调阻塞。 

￿ 回调的 pData 在回调结束后无效。在回调结束后，您不能再次使用 pData 。该方式的基本步骤如下： 

1. 调用 MV_CC_SetImageNodeNum() ，设置合适的缓存节点个数。 

注解 

您可根据实际情况，设置所需的缓存节点个数。主要影响因素有：相机帧率、图像 分辨率和电脑配置（主板性能、内存大小）等。 

2. 调用 MV_CC_RegisterImageCallBackEx() ，注册图像处理函数。 

3. 调用 MV_CC_StartGrabbing() ，开始采集图像。 

4. 等待 SDK 收到图像，并执行，在自定义的图像处理函数中处理图像。 

如下示例代码演示了通过回调函数采集图像的过程： 

￿ 自定义图像回调处理方法： 

void __stdcall ImageCallBackEx(unsigned char * pData, 

MV_FRAME_OUT_INFO_EX * pFrameInfo, void* pUser) 

{

if (pFrameInfo) 

{

printf("Get One Frame: Width[%d], Height[%d], FrameLen[%I64d] nFrameNum[%d]\n", 

pFrameInfo-> nExtendWidth , pFrameInfo-> nExtendHeight ,pFrameInfo-> nFrameLenEx ,pFrameInfo-> nFrameNum ); 

// pData 是图像指针， pFrameInfo->nFrameLenEx 是图像长度 , 可以 进行图像处理 

}

}

￿ 注册图像取流回调，并开始采集。 

// 注册抓图回调 

nRet = MV_CC_RegisterImageCallBackEx (handle , ImageCallBackEx, 

handle ); 

Check(nRet); 

// 设置缓存节点个数 

nRet = MV_CC_SetImageNodeNum (handle , 5); 

Check(nRet); 

// 开始取流 

nRet = MV_CC_StartGrabbing (handle ); 

Check(nRet); 轮询取图 

SDK 提供主动获取图像的接口，您可以创建线程，并在线程内部循环调用取图接口，获取图像。 

轮询取图的基本步骤如下： 

1. 调用 MV_CC_SetImageNodeNum() ，设置 SDK 内部缓存节点个数。 

注解 

o SDK 接收相机的图片数据并缓存在 SDK 内部，供外部调用。其中通过 

MV_CC_SetImageNodeNum() 配置 SDK 内部缓存节点个数。若上层调用 偏慢，且缓存节点有限，会导致 SDK 没有空间接收相机新发送的图像数据 ，导致丢帧。 

o 具体申请多少块图像缓存需要根据实际情况决定，主要影响因素有：相机 帧率、图像分辨率和电脑配置（主板性能、内存大小）等。 

2. 调用 MV_CC_StartGrabbing() 开始采集。 

3. 在应用层，调用 MV_CC_GetImageBuffer() 获取指定像素格式的帧数据。 

注解 

o 您可以设置该接口的超时时间。未超时前， SDK 内部等待直到有数据返回 。

o 获取图像数据时，您需要根据相机帧率，合理配置上层应用程序的接口调 用频率。 

4. 操作 buffer 进行图像处理等。 

5. 调用 MV_CC_FreeImageBuffer() 释放 buffer 。

注解 

调用 MV_CC_FreeImageBuffer() 将会把 buffer 归还 SDK 。归还后， buffer 失效。 

如下示例代码演示了轮询取图的过程： 

1. 自定义线程函数，接收并处理图像。 

static unsigned int __stdcall WorkThread (void* handle )

{

int nRet = MV_OK ;

MV_FRAME_OUT stOutFrame = {0}; 

while(true) 

{

nRet = MV_CC_GetImageBuffer (handle , &stOutFrame, 1000); if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stOutFrame. stFrameInfo .nWidth ,stOutFrame. stFrameInfo .nHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (handle , &stOutFrame); 

Check(nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

2. 开始采集。 

// 设置缓存节点个数 

nRet = MV_CC_SetImageNodeNum (handle , 5); 

Check(nRet); 

// 开始取流 

nRet = MV_CC_StartGrabbing (handle ); 

Check(nRet); 

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex(NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

上一篇： 事件及异常 下一篇： 处理图像 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 处理图像 

SDK 提供了丰富的图像处理接口，可用于实现图像显示、图像保存、像素格式转换、图像重组和录 像等功能。采集到图像后，您可以直接其传入到这些接口中进行图像处理。 

本节内容包含： 

￿ 图像渲染 

￿ 保存图像 

￿ 像素格式转换 

￿ 解码图像 

￿ 录像 

￿ 分时曝光拆图 

# 图像渲染 

采集到图像后，您可参照如下示例，调用 MV_CC_DisplayOneFrameEx2() 将图像显示在指定窗 口。 

// 1. 获取图像相关数据 

MV_CC_IMAGE stImage = {0}; 

stImage. nWidth = stImageInfo. stFrameInfo .nExtendWidth ;

stImage. nHeight = stImageInfo. stFrameInfo .nExtendHeight ;

stImage. enPixelType = stImageInfo. stFrameInfo .enPixelType ;

stImage. pImageBuf = stImageInfo. pBufAddr ;

stImage.nImageBufLen = stImageInfo. stFrameInfo .nFrameLenEx ;

// 2. 设置渲染模式 

unsigned int enRenderMode = 0; // 3. 显示图像 

nRet = MV_CC_DisplayOneFrameEx2 (handle ,(void*) g_hwnd , &stImage ,enRenderMode); 

Check(nRet); 

1. 获取图像宽、高、像素格式、图像缓存及图像长度。 

2. 设置图像渲染模式。此处设置为 0，表示默认模式，即通过 GDI 模式渲染。 

3. 通过 MV_CC_DisplayOneFrameEx2() 将获取的图像通过指定模式渲染。 

# 保存图像 

在采集到图像后，您可将图像保存至本地或内存中： 

￿ 保存至本地：调用 MV_CC_SaveImageToFileEx2() 。

￿ 保存至内存：调用 MV_CC_SaveImageEx3() 。

如下示例代码演示了如何将图像保存成本地 BMP 文件。 

// 存原始数据 bmp 图片 

char chImageName[ IMAGE_NAME_LEN ] = { 0 }; 

MV_CC_IMAGE stImage; 

memset(&stImage, 0, sizeof( MV_CC_IMAGE )); 

MV_CC_SAVE_IMAGE_PARAM stSaveImageParam; 

memset(&stSaveImageParam, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

stImage. enPixelType = stImageInfo. stFrameInfo .enPixelType ;

stImage. nHeight = stImageInfo. stFrameInfo .nExtendWidth ;

stImage. nWidth = stImageInfo. stFrameInfo .nExtendHeight ;

stImage.nImageBufLen = stImageInfo. stFrameInfo .nFrameLenEx ;

stImage. pImageBuf = stImageInfo. pBufAddr ;

stSaveImageParam. enImageType = MV_Image_Bmp ;

stSaveImageParam. iMethodValue = 1; 

stSaveImageParam. nQuality = 99; 

sprintf_s(chImageName, IMAGE_NAME_LEN , "InPut_w%d_h%d_fn%03d.bmp", stImage. nWidth , stImage. nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_SaveImageToFileEx2 (handle , &stImage, &stSaveImageParam, chImageName); 

Check(nRet); 

# 像素格式转换 采集到图像后，您可调用 MV_CC_ConvertPixelTypeEx() ，将图像转换成其他像素格式。 

例如，您可将 Bayer 格式转换成 RGB/BGR 格式。在对 Bayer 格式图像进行插值时，还支持一些算 法功能，如平滑滤波、 Gamma 矫正和 CCM 矫正等，具体支持的功能，可参考 图像处理 相关内容 。

如下示例代码演示了如何将图像转换成 RGB 格式。 

// 设置插值方法为均衡 

nRet = MV_CC_SetBayerCvtQuality (handle , 1); 

Check(nRet); 

unsigned char *pConvertData = NULL; 

unsigned int nConvertDataSize = 0; 

nConvertDataSize = stOutFrame. stFrameInfo .nExtendWidth *stOutFrame. stFrameInfo .nExtendHeight * 3; 

pConvertData = (unsigned char*)malloc(nConvertDataSize); 

if (NULL == pDataForRGB) 

{

printf("pConvertData is null\n"); 

break; 

}

// 像素格式转换 

MV_CC_PIXEL_CONVERT_PARAM_EX stConvertParam = {0}; 

stConvertParam. nWidth = stOutFrame. stFrameInfo .nExtendWidth ;

stConvertParam. nHeight = stOutFrame. stFrameInfo .nExtendHeight ;

stConvertParam. pSrcData = stOutFrame. pBufAddr ;

stConvertParam. nSrcDataLen = stOutFrame. stFrameInfo .nFrameLenEx ;

stConvertParam. enSrcPixelType = stOutFrame. stFrameInfo .enPixelType ;

stConvertParam. enDstPixelType = PixelType_Gvsp_RGB8_Packed ;

stConvertParam. pDstBuffer = pConvertData ;

stConvertParam. nDstBufferSize = nConvertDataSize ; 

nRet = MV_CC_ConvertPixelTypeEx (handle , &stConvertParam); 

Check(nRet); 

# 解码图像 

部分相机支持对图像进行编码压缩，发送压缩的图像，用户可以调用 MV_CC_HB_Decode() 对图像进行解码。 

注意 

解码前需要判断输入图像是否完整，如果因为网络等因素导致图像丢失了部分数据包，该 接口可能会解码失败。 您可以通过 MV_FRAME_OUT_INFO_EX 结构体中的 nLostPacket 

（本帧丢包数）字段，进行检测，如果 nLostPacket 大于 0，则当前帧有丢包。 

如下示例代码演示了如何解码压缩图像。 unsigned char* pDstBuf = NULL; 

MV_FRAME_OUT stImageInfo = {0}; 

MV_CC_HB_DECODE_PARAM stDecodeParam = {0}; 

// 检测丢包情况 

if (0 == stImageInfo. stFrameInfo .nLostPacket )

{

// 无损压缩解码 

stDecodeParam. pSrcBuf = stImageInfo. pBufAddr ;

stDecodeParam. nSrcLen = stImageInfo. stFrameInfo .nFrameLen ;

if (NULL == pDstBuf) 

{

pDstBuf = (unsigned char *)malloc(sizeof(unsigned char) * (nPayloadSize)); 

if (NULL == pDstBuf) 

{

printf("malloc pDsrData fail!\n"); 

break; 

}

}

stDecodeParam. pDstBuf = pDstBuf; 

stDecodeParam. nDstBufSize = nPayloadSize; 

nRet = MV_CC_HB_Decode (handle , &stDecodeParam); 

Check(nRet); 

}

else 

{

printf("Frame [%d] lost packet [%d] \n",stImageInfo. stFrameInfo .nFrameNum ,stImageInfo. stFrameInfo .nL ostPacket )

}

# 录像 

您可通过 SDK 将从相机接收到的图像保存成录像文件，其方法如下： 

1. 调用 MV_CC_StartRecord() ，开始录像，您需要配置录像的各种参数。 

2. 调用 MV_CC_InputOneFrame() ，循环放入图像数据。 

3. 在完成录像时，调用 MV_CC_StopRecord() ，停止录像。 

如下示例代码演示了如何将图像保存成录像文件。 

1. 开始录像：调用 MV_CC_StartRecord() 配置录像的参数，需要的参数可以从相机中获取 ，也可以从图像中获取。以下代码演示了从相机中获取宽、高、像素格式等参数。 MV_CC_RECORD_PARAM stRecordPar; 

MVCC_INTVALUE stParam = {0}; 

nRet = MV_CC_GetIntValue (handle , "Width", &stParam); 

Check(nRet); 

stRecordPar. nWidth = stParam. nCurValue ;

nRet = MV_CC_GetIntValue (handle , "Height", &stParam); 

Check(nRet); 

stRecordPar. nHeight = stParam. nCurValue ;

MVCC_ENUMVALUE stEnumValue = {0}; 

nRet = MV_CC_GetEnumValue (handle , "PixelFormat", &stEnumValue); 

Check(nRet); 

stRecordPar. enPixelType = MvGvspPixelType (stEnumValue. nCurValue ); 

MVCC_FLOATVALUE stFloatValue; 

nRet = MV_CC_GetFloatValue (handle , "ResultingFrameRate", &stFloatValue); 

Check(nRet); 

stRecordPar. fFrameRate = stFloatValue. fCurValue ;

stRecordPar. nBitRate = 1000; 

stRecordPar. enRecordFmtType = MV_FormatType_AVI ;

stRecordPar. strFilePath = "./Recording.avi"; 

nRet = MV_CC_StartRecord (handle , &stRecordPar); 

Check(nRet); 

2. 放入图像到录像中：循环调用 MV_CC_InputOneFrame() ，将从相机获取的图像数据放 入录像中。 

static unsigned int __stdcall WorkThread (void* handle )

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

MV_CC_INPUT_FRAME_INFO stInputFrameInfo = {0}; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

stInputFrameInfo. pData = stImageInfo. pBufAddr ;

stInputFrameInfo. nDataLen =stImageInfo. stFrameInfo .nFrameLen ;

nRet = MV_CC_InputOneFrame (handle ,&stInputFrameInfo); Check(nRet); 

nRet = MV_CC_FreeImageBuffer (handle , &stImageInfo); 

Check(nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

3. 停止录像：调用 MV_CC_StopRecord() ，停止录像。 

nRet = MV_CC_StopRecord (handle ); 

Check(nRet); 

# 分时曝光拆图 

￿ SDK 拆图 

部分相机支持分时曝光功能，并将分时曝光的整图发送给 SDK ，应用程序可以调用 

MV_CC_ReconstructImage() ，拆分分时曝光的整图，输出每个曝光的图像。 

通过 SDK 端进行分时曝光拆图和图像重构的基本步骤如下： 

1. 调用 MV_CC_GetEnumValue() 获取 “MultiLightControl” 节点的值，即当前相机的 多重曝光数量。 

注意 

￿ 部分相机可能没有 “MultiLightControl” 节点，此时，您需根据实际曝 光数量进行设置。 

￿ 相机配置 HB （High Bandwidth ）模式下 “MultiLightControl” 节点的 值，需要进行转换才能得到有效的曝光数量。 

2. 若获取的图像为 HB 图像，调用 MV_CC_HB_Decode() ，进行 HB 解码。 

3. 调用 MV_CC_ReconstructImage() ，重构图像。 

示例代码如下： 

unsigned int m_nMultiLightNum = 0; // 获取多组曝光数量 

MVCC_ENUMVALUE stEnumValue = {0}; 

int nRet = MV_CC_GetEnumValue (handle , "MultiLightControl", &stEnumValue); 

Check(nRet); 

m_nMultiLightNum=stEnumValue. nCurValue ;nRet = MV_CC_GetEnumValue (handle , "ImageCompressionMode", &stEnumValue); 

Check(nRet); 

if(2 == stEnumValue. nCurValue ) //HB 开启 

{

//HB 模式下，曝光数转换逻辑： 

// 目前固件端 HB 定义的灯数是从 0x10 起始的，实际灯数从字节低四位获取 

m_nMultiLightNum = m_nMultiLightNum & 0xF; 

//HB 模式下，需要对 HB 图像进行解码后，参考 "解码图像 "章节， 

// 之后再进行重构 

}

MV_RECONSTRUCT_IMAGE_PARAM stImgReconstructionParam ; 

unsigned char* pImageBufferList[8] = {0}; 

for (int k = 0; k < 8; k++) 

{

pImageBufferList[k] = NULL; 

}

stImgReconstructionParam. nWidth = stOutFrame. stFrameInfo .nWidth ;

stImgReconstructionParam. nHeight =stOutFrame. stFrameInfo .nHeight ;

stImgReconstructionParam. enPixelType =stOutFrame. stFrameInfo .enPixelType ;

stImgReconstructionParam. pSrcData = stOutFrame. pBufAddr ;

stImgReconstructionParam. nSrcDataLen =stOutFrame. stFrameInfo .nFrameLen ;

// 曝光数量 

stImgReconstructionParam. nExposureNum = m_nMultiLightNum; 

stImgReconstructionParam. enReconstructMethod = MV_SPLIT_BY_LINE ;

// 重组后的长度 

unsigned int nImageBufferSize = stImgReconstructionParam. nSrcDataLen / m_nMultiLightNum;; 

for (unsigned int i = 0; i < m_nMultiLightNum; i++) 

{

if (pImageBufferList[i]) 

{

free(pImageBufferList[i]); 

pImageBufferList[i] = NULL; 

}

pImageBufferList[i] = (unsigned char*)malloc(nImageBufferSize); 

if (NULL != pImageBufferList[i]) 

{

stImgReconstructionParam. stDstBufList [i]. pBuf =pImageBufferList[i]; 

stImgReconstructionParam. stDstBufList [i]. nBufSize =nImageBufferSize; 

}

else 

{

return MV_E_RESOURCE ;

}}

nRet = MV_CC_ReconstructImage (handle , &stImgReconstructionParam); 

Check(nRet); 

￿ 采集卡端拆图 

在通过采集卡端拆图时，您可通过 MV_FRAME_OUT_INFO_EX 结构体中的 

SubImageList 获取拆图后的子图。示例代码如下。 

注解 

只有部分型号采集卡支持拆图功能。 

MV_FRAME_OUT stFrameOut = {0}; 

int nRet = MV_CC_GetImageBuffer (pUser, &stFrameOut, 1000); 

if (nRet == MV_OK )

{

if (stFrameOut. stFrameInfo .nSubImageNum > 0) 

{

for (unsigned int i = 0; i < stFrameOut. stFrameInfo .nSubImageNum ; ++i) 

{

MV_CC_IMAGE * pSubImage = &stFrameOut. stFrameInfo .SubImageList .pstSubImage [i]; 

printf("SubImage buffer[%p], size[%d]\n", pSubImage-> pImageBuf , pSubImage-> nImageLen ); 

}

}

MV_CC_FreeImageBuffer (pUser, &stFrameOut); 

}

上一篇： 采集图像 下一篇：无 

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# API 参考 

这里列出了所有模块 : 

> [详情级别 12]

SDK 版本信息 获取 SDK 版本信息接口 

SDK 初始化 包括初始化 SDK 和反初始化 SDK 接口 

相机初始化 包含枚举相机、创建句柄、打开相机等接口 

采集卡初始化 包含枚举采集卡、创建句柄、打开采集卡等接口 

> ▼

参数设置 

属性配置 获取和设置设备参数的万能接口 

读写寄存器 通过寄存器地址获取和设置相机寄存器数据 

设备 XML 文件 包含获取设备 XML 文件接口 

读写相机文件 包含从设备读取文件、将文件写入设备等接口 

图像采集 包含图像获取（回调取图、主动取图）、开始 /结束取流接口等。 

图像渲染 包含图像渲染相关接口 

图像处理 包括图像显示、图像保存和图像格式转换接口等 

事件及异常 包括事件及异常接口 

串口控制相关 用于在工业相机外接串口设备时（如液态镜头），通过 SDK 串口 控制相关接口，实现与相机外接的串口设备进行通信。 

GigE 相机 仅GigE 相机支持的接口 

U3V 相机 仅U3V 相机支持的接口 

串口设备 仅串口设备（ Camera Link 相机、串口光源控制器支持的接口 

GenTL GenTL 相关接口 

回调函数定义 注册图像数据、异常消息的回调函数 

设备升级 包含设备升级和获取升级进度接口 

结构体定义 包含相关结构体定义 

枚举类型定义 包含不同类型的枚举信息 

宏定义 包含一些常量定义 

废弃接口 废弃原因：新开发的万能接口代替了具体节点的设置、获取参数 功能；效率低的接口由新的接口替代；实际开发中部分接口使用 频率较低。 ▼状态码 介绍 SDK 使用过程中不同状态码对应的值和说明 

SDK 内部自定义状态码 

算法库透传状态码 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# SDK 版本信息 

获取 SDK 版本信息接口 更多 ... 

# 函数 

MV_CAMCTRL_API unsigned int __stdcall MV_CC_GetSDKVersion () 

获取 SDK 版本号 更多 ... 

# 详细描述 

获取 SDK 版本信息接口 函数说明 

◆ MV_CC_GetSDKVersion() 

MV_CAMCTRL_API unsigned int __stdcall MV_CC_GetSDKVersion ( )

获取 SDK 版本号 

返回 

始终返回 4字节版本号 

主 次 修正 测试 

8bits 8bits 8bits 8bits 

注解 

• 比如返回值为 0x01000001 ，即 SDK 版本号为 V1.0.0.1 。

• MV_CC_GetSDKVersion() 引入头文件、 Lib 文件后， SDK 环境搭建完毕，可直接调 用。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# SDK 初始化 包括初始化 SDK 和反初始化 SDK 接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_Initialize () 

初始化 SDK 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_Finalize () 

反初始化 SDK ，释放资源 更多 ... 

# 详细描述 

包括初始化 SDK 和反初始化 SDK 接口 

# 函数说明 

◆ MV_CC_Initialize() 

MV_CAMCTRL_API int __stdcall MV_CC_Initialize ( )

初始化 SDK 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ChunkData.cpp , ConfigLightController.cpp , ConnectSpecCamera.cpp ,

ConvertPixelType.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_Finalize() 

MV_CAMCTRL_API int __stdcall MV_CC_Finalize ( )

反初始化 SDK ，释放资源 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

需在 main 函数退出前调用。 

示例 

ChunkData.cpp , ConfigLightController.cpp , ConnectSpecCamera.cpp ,

ConvertPixelType.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 相机初始化 

包含枚举相机、创建句柄、打开相机等接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevices (IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST *pstDevList) 

枚举设备，支持枚举对应采集卡上的相机 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesEx (IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST *pstDevList, IN const char *strManufacturerName) 

根据厂商名字枚举设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesEx2 (IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST *pstDevList, IN const char *strManufacturerName, IN MV_SORT_METHOD 

enSortMethod) 

枚举设备扩展（可指定排序方式枚举、根据厂商名字过滤） ，支持枚举对应采集卡上的相机 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesByInterface (IN void * handle , OUT 

MV_CC_DEVICE_INFO_LIST *pstDevList) 

通过采集卡句柄枚举设备 更多 ... 

MV_CAMCTRL_API bool __stdcall MV_CC_IsDeviceAccessible (IN MV_CC_DEVICE_INFO 

*pstDevInfo, IN unsigned int nAccessMode) 设备是否可连接 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CreateHandle (IN OUT void ** handle , IN const 

MV_CC_DEVICE_INFO *pstDevInfo) 

创建设备句柄 更多 ... 

MV_CAMCTRL_API bool __stdcall MV_CC_IsDeviceConnected (IN void * handle )

判断设备是否处于连接状态 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_OpenDevice (IN void * handle , IN unsigned int nAccessMode, IN unsigned short nSwitchoverKey) 

打开设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAllMatchInfo (IN void * handle , IN OUT 

MV_ALL_MATCH_INFO *pstInfo) 

获取各种类型的信息 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceInfo (IN void * handle , IN OUT 

MV_CC_DEVICE_INFO *pstDevInfo) 

获取设备信息，取流之前调用 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CloseDevice (IN void * handle )

关闭设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DestroyHandle (IN void * handle )

销毁设备句柄 更多 ... 

# 详细描述 

包含枚举相机、创建句柄、打开相机等接口 

# 函数说明 

◆ MV_CC_EnumDevices() MV_CAMCTRL_API int __stdcall MV_CC_EnumDevices ( IN unsigned int nTLayerType, 

IN OUT MV_CC_DEVICE_INFO_LIST * pstDevList 

)

枚举设备，支持枚举对应采集卡上的相机 

参数 

nTLayerType [IN] 枚举传输层，参数定义参见 CameraParams.h 

传输层协议类型定义 值 说明 

MV_UNKNOW_DEVICE 0x00000000 未知设备类型 

MV_GIGE_DEVICE 0x00000001 GigE 设备 

MV_1394_DEVICE 0x00000002 1394-a/b 设备 

MV_USB_DEVICE 0x00000004 USB 设备 

MV_CAMERALINK_DEVICE 0x00000008 

串口设备，包含 

Camera Link 设备和串口视觉控 制器 

MV_VIR_GIGE_DEVICE 0x00000010 虚拟 GigE 设备 

MV_VIR_USB_DEVICE 0x00000020 虚拟 USB 设备 

MV_GENTL_GIGE_DEVICE 0x00000040 自研网卡下 GigE 

设备 

MV_GENTL_CAMERALINK_DEVICE 0x00000080 CameraLink 设备 

MV_GENTL_CXP_DEVICE 0x00000100 CoaXPress 设备 

MV_GENTL_XOF_DEVICE 0x00000200 XoF 设备 

MV_GENTL_VIR_DEVICE 0x00000800 虚拟设备 

pstDevList [IN][OUT] 设备列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 设备列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存的释 放和申请，建议尽量避免多线程枚举操作。 

• 参数枚举传输层，适配传入 MV_GIGE_DEVICE 、MV_1394_DEVICE 、

MV_USB_DEVICE 、MV_CAMERALINK_DEVICE ；MV_GIGE_DEVICE 该参数传出所 有GiGE 相关的设备信息（包含虚拟 GiGE 和GenTL 下的 GiGE 设备）， 

MV_USB_DEVICE 该参数传出所有 USB 设备，包含虚拟 USB 设备。 

示例 

ChunkData.cpp , ConvertPixelType.cpp , Events.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ MV_CC_EnumDevicesEx() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesEx ( IN unsigned int nTLayerType, 

IN OUT MV_CC_DEVICE_INFO_LIST * pstDevList, 

IN const char * strManufacturerName 

)

根据厂商名字枚举设备 

参数 

nTLayerType [IN] 枚举传输层，参数定义参见 CameraParams.h 

传输层协议类型定义 值 说明 

MV_UNKNOW_DEVICE 0x0000000 0

未知设备类 型

MV_GIGE_DEVICE 0x0000000 1 GigE 设备 

MV_1394_DEVICE 0x0000000 2

1394-a/b 设备

MV_USB_DEVICE 0x0000000 4 USB 设备 MV_CAMERALINK_DEVICE 0x0000000 8

串口设备， 包含 

Camera Link 设备和 串口视觉控 制器 

MV_VIR_GIGE_DEVICE 0x0000001 0

虚拟 GigE 

设备 

MV_VIR_USB_DEVICE 0x0000002 0

虚拟 USB 设备

MV_GENTL_GIGE_DEVICE 0x0000004 0

自研网卡下 

GigE 设备 

MV_GENTL_CAMERALINK_DEVI CE 

0x0000008 0

CameraLin k设备 

MV_GENTL_CXP_DEVICE 0x0000010 0

CoaXPress 

设备 

MV_GENTL_XOF_DEVICE 0x0000020 0 XoF 设备 

MV_GENTL_VIR_DEVICE 0x0000080 0 虚拟设备 

pstDevList [IN][OUT] 设备列表 

strManufacturerNam e [IN] 厂商名字 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 参数枚举传输层，适配传入 MV_GIGE_DEVICE 、MV_1394_DEVICE 、

MV_USB_DEVICE 、MV_CAMERALINK_DEVICE ；MV_GIGE_DEVICE 该参数传出所 有GiGE 相关的设备信息（包含虚拟 GiGE 和GenTL 下的 GiGE 设备）， 

MV_USB_DEVICE 该参数传出所有 USB 设备，包含虚拟 USB 设备。 

• 设备列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存的释 放和申请，建议尽量避免多线程枚举操作。 

• MV_GENTL_GIGE_DEVICE 、MV_GENTL_CAMERALINK_DEVICE 、

MV_GENTL_CXP_DEVICE 、MV_GENTL_XOF_DEVICE 传输层可以返回对采集卡下的 相机信息。 ◆ MV_CC_EnumDevicesEx2() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesEx2 ( IN unsigned int nTLayerType, 

IN OUT MV_CC_DEVICE_INFO_LIST * pstDevList, 

IN const char * strManufacturerName, 

IN MV_SORT_METHOD enSortMethod 

)

枚举设备扩展（可指定排序方式枚举、根据厂商名字过滤），支持枚举对应采集卡上的相机 

参数 

nTLayerType [IN] 枚举传输层（区分每一种传输层类型，不耦合），参数定义参 见CameraParams.h 

传输层协议类型定义 值 说明 

MV_UNKNOW_DEVICE 0x0000000 0

未知设备类 型

MV_GIGE_DEVICE 0x0000000 1 GigE 设备 

MV_1394_DEVICE 0x0000000 2

1394-a/b 设备

MV_USB_DEVICE 0x0000000 4 USB 设备 

MV_CAMERALINK_DEVICE 0x0000000 8

串口设备， 包含 

Camera Link 设备和 串口视觉控 制器 

MV_VIR_GIGE_DEVICE 0x0000001 0

虚拟 GigE 

设备 

MV_VIR_USB_DEVICE 0x0000002 0

虚拟 USB 设备

MV_GENTL_GIGE_DEVICE 0x0000004 0

自研网卡下 

GigE 设备 MV_GENTL_CAMERALINK_DEVI CE 

0x0000008 0

CameraLin k设备 

MV_GENTL_CXP_DEVICE 0x0000010 0

CoaXPress 

设备 

MV_GENTL_XOF_DEVICE 0x0000020 0 XoF 设备 

MV_GENTL_VIR_DEVICE 0x0000080 0 虚拟设备 

pstDevList [IN][OUT] 设备列表 

strManufacturerNam e [IN] 厂商名字（可传 NULL ，即不过滤） 

enSortMethod [IN] 排序方式 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 设备列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存的释 放和申请，建议尽量避免多线程枚举操作。 

• strManufacturerName 可传入 NULL ，若传入 NULL 则返回排好序的所有设备列表，若 不为 NULL 则只返回排好序的指定厂商设备列表。 

• MV_GENTL_GIGE_DEVICE 、MV_GENTL_CAMERALINK_DEVICE 、

MV_GENTL_CXP_DEVICE 、MV_GENTL_XOF_DEVICE 传输层可以返回对采集卡下的 相机信息。 

• MV_CC_EnumDevicesEx2() 与 MV_CC_EnumDevicesEx() 接口的差异如下： 

￿ MV_CC_EnumDevicesEx() 传入 MV_GIGE_DEVICE ，除了枚举网段内的网口 相机以外，还会枚举虚拟网口相机和自研采集卡下的网口相机；若传入 

MV_USB_DEVICE ，则会枚举 USB 口相机和虚拟 USB 口相机。 

￿ MV_CC_EnumDevicesEx2() 传入 MV_GIGE_DEVICE ，仅枚举网段内的网口 相机；若传入 MV_USB_DEVICE ，则仅枚举 USB 口相机。 

￿ MV_CC_EnumDevicesEx2() 多出排序的功能，由参数 MV_SORT_METHOD enSortMethod 决定排序方式。 

◆ MV_CC_EnumDevicesByInterface() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesByInterface ( IN void * handle, OUT MV_CC_DEVICE_INFO_LIST * pstDevList 

)

通过采集卡句柄枚举设备 

参数 

handle [IN] 采集卡句柄 

pstDevList [OUT] 设备列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 设备列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存的释 放和申请， 

• 建议尽量避免多线程枚举操作。 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , 以及 

QuickSoftwareTrigger.cpp .

◆ MV_CC_IsDeviceAccessible() 

MV_CAMCTRL_API bool __stdcall MV_CC_IsDeviceAccessible ( IN MV_CC_DEVICE_INFO * pstDevInfo, 

IN unsigned int nAccessMode 

)

设备是否可连接 

参数 

pstDevInfo [IN] 设备信息结构体 

nAccessMode [IN] 访问权限 

宏定义 

宏定义值

含义 MV_ACCESS_Exclusive 1

独占权限，其 他APP 只允许 读CCP 寄存器 

MV_ACCESS_ExclusiveWithSwitch 2

可以从 5模式下 抢占权限，然 后以独占权限 打开 

MV_ACCESS_Control 3

控制权限，其 他APP 允许读 所有寄存器 

MV_ACCESS_ControlWithSwitch 4

可以从 5模式下 抢占权限，然 后以控制权限 打开 

MV_ACCESS_ControlSwitchEnable 5 以可被抢占的 控制权限打开 

MV_ACCESS_ControlSwitchEnableWithKey 6

可以从 5模式下 抢占权限，然 后以可被抢占 的控制权限打 开

MV_ACCESS_Monitor 7

读模式打开设 备，适用于控 制权限下 

返回 

可达，返回 true ；不可达，返回 false 

注解 

• 读取设备 CCP 寄存器的值，判断当前状态是否具有某种访问权限。 

• 如果设备不支持 MV_ACCESS_ExclusiveWithSwitch 、

MV_ACCESS_ControlWithSwitch 、MV_ACCESS_ControlSwitchEnableWithKey 这三 种模式，接口返回 false 。目前设备不支持这 3种抢占模式，国际上主流的厂商的设备也 都暂不支持这 3种模式。 

示例 

ForceIPEx.cpp .◆ MV_CC_CreateHandle() 

MV_CAMCTRL_API int __stdcall MV_CC_CreateHandle ( IN OUT void ** handle, 

IN const MV_CC_DEVICE_INFO * pstDevInfo 

)

创建设备句柄 

参数 

handle [IN][OUT] 设备句柄 

pstDevInfo [IN] 设备信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 根据输入的设备信息，创建库内部必须的资源和初始化内部模块。 

• 通过该接口创建句柄，调用 SDK 接口，会默认生成 SDK 日志文件。 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_IsDeviceConnected() 

MV_CAMCTRL_API bool __stdcall MV_CC_IsDeviceConnected ( IN void * handle )

判断设备是否处于连接状态 参数 

handle [IN] 设备句柄 

返回 

设备处于连接状态，返回 true ；没连接或失去连接，返回 false 。

◆ MV_CC_OpenDevice() 

MV_CAMCTRL_API int __stdcall MV_CC_OpenDevice ( IN void * handle, 

IN unsigned int nAccessMode, 

IN unsigned short nSwitchoverKey 

)

打开设备 

参数 

handle [IN] 设备句柄 

nAccessMode [IN] 访问权限 

宏定义 

宏定义值

含义 

MV_ACCESS_Exclusive 1

独占权限，其 他APP 只允许 读CCP 寄存 器

MV_ACCESS_ExclusiveWithSwitch 2

可以从 5模式 下抢占权限， 然后以独占权 限打开 

MV_ACCESS_Control 3

控制权限，其 他APP 允许读 所有寄存器 

MV_ACCESS_ControlWithSwitch 4

可以从 5模式 下抢占权限， 然后以控制权 限打开 MV_ACCESS_ControlSwitchEnable 5 以可被抢占的 控制权限打开 

MV_ACCESS_ControlSwitchEnableWithKey 6

可以从 5模式 下抢占权限， 然后以可被抢 占的控制权限 打开 

MV_ACCESS_Monitor 7

读模式打开设 备，适用于控 制权限下 

nSwitchoverKey [IN] 切换访问权限时的密钥 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 根据设置的设备参数，找到对应的设备，连接设备。 

• 调用接口时可不传入 nAccessMode 和nSwitchoverKey ，此时默认设备访问模式为独占 权限 

• 目前 GigE 设备的相机固件暂不支持 MV_ACCESS_ExclusiveWithSwitch 、

MV_ACCESS_ControlWithSwitch 、MV_ACCESS_ControlSwitchEnable 、

MV_ACCESS_ControlSwitchEnableWithKey 这四种抢占模式 

• GenTL 设备只支持 nAccessMode 是 MV_ACCESS_Exclusive 、

MV_ACCESS_Control 、MV_ACCESS_Monitor 权限 

• 对于 U3V 设备， CXP ，CameraLink 设备， Xof 设备，虚拟 GEV ，虚拟 U3V 设备， 

nAccessMode 、nSwitchoverKey 这两个参数无效；默认以控制权限 

MV_ACCESS_Control 打开设备 

• 该接口支持网口设备不枚举直接打开，不支持 U口和 GenTL 设备不枚举打开设备 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_GetAllMatchInfo() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAllMatchInfo ( IN void * handle, 

IN OUT MV_ALL_MATCH_INFO * pstInfo 

)

获取各种类型的信息 

参数 

handle [IN] 设备句柄 

pstInfo [IN][OUT] 返回给调用者有关设备各种类型的信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 接口里面输入需要获取的信息类型（指定 MV_ALL_MATCH_INFO 结构体中的 nType 

类型），获取对应的信息（在 MV_ALL_MATCH_INFO 结构体中 pInfo 里返回）。 

• 该接口的调用前置条件取决于所获取的信息类型，获取 GigE 设备的 

MV_MATCH_TYPE_NET_DETECT 信息需在开启抓图之后调用，获取 U3V 设备的 

MV_MATCH_TYPE_USB_DETECT 信息需在打开设备之后调用。 

• 该接口不支持 Camera Link 设备。 

◆ MV_CC_GetDeviceInfo() 

MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceInfo ( IN void * handle, 

IN OUT MV_CC_DEVICE_INFO * pstDevInfo 

)

获取设备信息，取流之前调用 

参数 

handle [IN] 设备句柄 pstDevInfo [IN][OUT] 返回给调用者有关设备信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 支持用户在打开设备后获取设备信息，不支持 GenTL 设备。 

• 若该设备是 GigE 设备，则调用该接口存在阻塞风险，因此不建议在取流过程中调用该 接口。 

◆ MV_CC_CloseDevice() 

MV_CAMCTRL_API int __stdcall MV_CC_CloseDevice ( IN void * handle )

关闭设备 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过 MV_CC_OpenDevice() 连接设备后，可以通过该接口断开设备连接，释放资源。 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_DestroyHandle() MV_CAMCTRL_API int __stdcall MV_CC_DestroyHandle ( IN void * handle )

销毁设备句柄 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> 函数

# 采集卡初始化 

包含枚举采集卡、创建句柄、打开采集卡等接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_EnumInterfaces (IN unsigned int nTLayerType, IN OUT MV_INTERFACE_INFO_LIST *pInterfaceInfoList) 

枚举采集卡 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CreateInterface (IN OUT void ** handle , IN 

MV_INTERFACE_INFO *pInterfaceInfo) 

创建采集卡句柄 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CreateInterfaceByID (IN OUT void ** handle , IN char *pInterfaceID) 

通过采集卡 ID 创建采集卡句柄 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_OpenInterface (IN void * handle , IN char *pReserved) 

打开采集卡 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CloseInterface (IN void * handle )

关闭采集卡 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DestroyInterface (IN void * handle )

销毁采集卡句柄 更多 ... 

# 详细描述 

包含枚举采集卡、创建句柄、打开采集卡等接口 函数说明 

◆ MV_CC_EnumInterfaces() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumInterfaces ( IN unsigned int nTLayerType, 

IN OUT MV_INTERFACE_INFO_LIST * pInterfaceInfoList 

)

枚举采集卡 

参数 

nTLayerType [IN] 采集卡接口类型 

采集卡接口类型定义 值 说明 

MV_GIGE_INTERFACE 0x00000001 GigE Vision 采集 卡

MV_CAMERALINK_INTERFACE 0x00000004 Camera Link 采集卡 

MV_CXP_INTERFACE 0x00000008 CoaXPress 采集 卡

MV_XOF_INTERFACE 0x00000010 XoFLink 采集卡 

MV_VIR_INTERFACE 0x00000020 虚拟采集卡 

MV_LC_INTERFACE 0x00000040 光源控制卡 

pInterfaceInfoList [IN][OUT] 采集卡列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ MV_CC_CreateInterface() 

MV_CAMCTRL_API int __stdcall MV_CC_CreateInterface ( IN OUT void ** handle, 

IN MV_INTERFACE_INFO * pInterfaceInfo )

创建采集卡句柄 

参数 

handle [IN][OUT] 采集卡句柄 

pInterfaceInfo [IN] 采集卡信息 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ MV_CC_CreateInterfaceByID() 

MV_CAMCTRL_API int __stdcall MV_CC_CreateInterfaceByID ( IN OUT void ** handle, 

IN char * pInterfaceID 

)

通过采集卡 ID 创建采集卡句柄 

参数 

handle [IN][OUT] 采集卡句柄 

pInterfaceID [IN] 采集卡 ID ，比如采集卡序列号 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_OpenInterface() 

MV_CAMCTRL_API int __stdcall MV_CC_OpenInterface ( IN void * handle, 

IN char * pReserved 

)

打开采集卡 

参数 

handle [IN] 采集卡句柄 pReserved [IN] 预留，直接填 NULL 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ MV_CC_CloseInterface() 

MV_CAMCTRL_API int __stdcall MV_CC_CloseInterface ( IN void * handle )

关闭采集卡 

参数 

handle [IN] 采集卡句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ MV_CC_DestroyInterface() 

MV_CAMCTRL_API int __stdcall MV_CC_DestroyInterface ( IN void * handle )

销毁采集卡句柄 

参数 

handle [IN] 采集卡句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

如果传入相机句柄，其效果和 MV_CC_DestroyHandle 相同 ;

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 模块

# 参数设置 

# 模块 

属性配置 

获取和设置设备参数的万能接口 

读写寄存器 

通过寄存器地址获取和设置相机寄存器数据 

设备 XML 文件 

包含获取设备 XML 文件接口 

读写相机文件 

包含从设备读取文件、将文件写入设备等接口 

# 详细描述 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 属性配置 

> 参数设置

获取和设置设备参数的万能接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_GetIntValueEx (IN void * handle , IN const char *strKey, IN OUT MVCC_INTVALUE_EX *pstIntValue) 

获取 Integer 属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetIntValueEx (IN void * handle , IN const char *strKey, IN int64_t nValue) 

设置 Integer 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetEnumValue (IN void * handle , IN const char *strKey, IN OUT MVCC_ENUMVALUE *pstEnumValue) 

获取 Enum 属性值 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_GetEnumValueEx (IN void * handle , IN const char *strKey, IN OUT MVCC_ENUMVALUE_EX *pstEnumValue) 

获取 Enum 属性值 (扩展接口 ) 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetEnumValue (IN void * handle , IN const char *strKey, IN unsigned int nValue) 

设置 Enum 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetEnumEntrySymbolic (IN void * handle , IN const char *strKey, IN OUT MVCC_ENUMENTRY *pstEnumEntry) 

获取 Enum 型节点指定值的符号 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetEnumValueByString (IN void * handle , IN const char *strKey, IN const char *strValue) 

设置 Enum 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetFloatValue (IN void * handle , IN const char *strKey, IN OUT MVCC_FLOATVALUE *pstFloatValue) 

获取 Float 属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetFloatValue (IN void * handle , IN const char *strKey, IN float fValue) 

设置 Float 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBoolValue (IN void * handle , IN const char *strKey, IN OUT bool *pbValue) 

获取 Boolean 属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBoolValue (IN void * handle , IN const char *strKey, IN bool bValue) 

设置 Boolean 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetStringValue (IN void * handle , IN const char *strKey, IN OUT MVCC_STRINGVALUE *pstStringValue) 

获取 String 属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetStringValue (IN void * handle , IN const char *strKey, IN const char *strValue) 

设置 String 型属性值 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_SetCommandValue (IN void * handle , IN const char *strKey) 

设置 Command 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureLoad (IN void * handle , IN const char *strFileName) 

导入设备属性 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureLoadEx (IN void * handle , IN const char *strFileName, IN OUT MVCC_NODE_ERROR_LIST 

*pstNodeErrorList) 

导入设备属性并保存错误信息列表 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureSave (IN void * handle , IN const char *strFileName) 

保存设备属性 更多 ... 

# 详细描述 

获取和设置设备参数的万能接口 

# 函数说明 

◆ MV_CC_GetIntValueEx() 

MV_CAMCTRL_API int __stdcall MV_CC_GetIntValueEx ( IN void * handle, 

IN const char * strKey, 

IN OUT MVCC_INTVALUE_EX * pstIntValue 

)

获取 Integer 属性值 

参数 handle [IN] 设备句柄 

strKey [IN] 属性键值，如获取宽度信息则为 "Width" 

pstIntValue [IN][OUT] 返回给调用者有关设备属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 int 类型的指定节点的值，具体可以查看客户端属性描 述，如下图所示： 

示例 

ConfigLightController.cpp , Grab_Asynchronous.cpp , InterfaceDemo.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ MV_CC_SetIntValueEx() 

MV_CAMCTRL_API int __stdcall MV_CC_SetIntValueEx ( IN void * handle, 

IN const char * strKey, 

IN int64_t nValue 

)

设置 Integer 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如设置宽度信息则为 "Width" 

nValue [IN] 想要设置的设备的属性值 返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 int 类型的指定节点的值，具体可以查看客户端属性描 述，如下图所示： 

示例 

ConfigLightController.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

Events.cpp , Grab_ActionCommand.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ MV_CC_GetEnumValue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetEnumValue ( IN void * handle, 

IN const char * strKey, 

IN OUT MVCC_ENUMVALUE * pstEnumValue 

)

获取 Enum 属性值 

参数 handle [IN] 设备句柄 

strKey [IN] 属性键值，如获取像素格式信息则为 "PixelFormat" 

pstEnumValue [IN][OUT] 返回给调用者有关设备属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 Enum 类型的指定节点的值。 

示例 

ConfigLightController.cpp , InterfaceDemo.cpp , 以及 Recording.cpp .

◆ MV_CC_GetEnumValueEx() 

MV_CAMCTRL_API int __stdcall MV_CC_GetEnumValueEx ( IN void * handle, 

IN const char * strKey, 

IN OUT MVCC_ENUMVALUE_EX * pstEnumValue 

)

获取 Enum 属性值 (扩展接口 )

参数 

handle [IN] 设备句柄 /采集卡句柄 

strKey [IN] 属性键值，如获取像素格式信息则为 "PixelFormat" 

pstEnumValue [IN][OUT] 返回给调用者有关设备属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

￿ 连接设备之后调用该接口可以获取 Enum 类型的指定节点的值。 

￿ 该接口返回的枚举有效个数扩展到 256 个。 

◆ MV_CC_SetEnumValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetEnumValue ( IN void * handle, 

IN const char * strKey, IN unsigned int nValue 

)

设置 Enum 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如设置像素格式信息则为 "PixelFormat" 

nValue [IN] 想要设置的设备的属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 Enum 类型的指定节点的值。 

示例 

ChunkData.cpp , ConfigLightController.cpp , ConnectSpecCamera.cpp ,

ConvertPixelType.cpp , Events.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp ,

MultiLightCtrl_ImageStitching.cpp , ParametrizeCamera_LineScanIOSettings.cpp ,

QuickSoftwareTrigger.cpp , 以及 Recording.cpp .

◆ MV_CC_GetEnumEntrySymbolic() 

MV_CAMCTRL_API int __stdcall MV_CC_GetEnumEntrySymbolic ( IN void * handle, 

IN const char * strKey, 

IN OUT MVCC_ENUMENTRY * pstEnumEntry 

)

获取 Enum 型节点指定值的符号 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如获取像素格式信息则为 "PixelFormat" pstEnumEntry [IN][OUT] 想要获取的设备的属性符号 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 Enum 类型的指定节点的值。 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CC_SetEnumValueByString() 

MV_CAMCTRL_API int __stdcall MV_CC_SetEnumValueByString ( IN void * handle, 

IN const char * strKey, 

IN const char * strValue 

)

设置 Enum 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如设置像素格式信息则为 "PixelFormat" 

strValue [IN] 想要设置的设备的属性字符串 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 Enum 类型的指定节点的值。 

示例 

ChunkData.cpp , Grab_ActionCommand.cpp , GrabStrategies.cpp ,

LineScanSoftwareTrigger.cpp , ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ MV_CC_GetFloatValue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetFloatValue ( IN void * handle, IN const char * strKey, 

IN OUT MVCC_FLOATVALUE * pstFloatValue 

)

获取 Float 属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

pstFloatValue [IN][OUT] 返回给调用者有关设备属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 float 类型的指定节点的值。 

示例 

ConfigLightController.cpp , InterfaceDemo.cpp , 以及 Recording.cpp .

◆ MV_CC_SetFloatValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetFloatValue ( IN void * handle, 

IN const char * strKey, 

IN float fValue 

)

设置 Float 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

fValue [IN] 想要设置的设备的属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 float 类型的指定节点的值。 示例 

ConfigLightController.cpp , InterfaceDemo.cpp , 以及 

ParametrizeCamera_AreaScanIOSettings.cpp .

◆ MV_CC_GetBoolValue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBoolValue ( IN void * handle, 

IN const char * strKey, 

IN OUT bool * pbValue 

)

获取 Boolean 属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

pbValue [OUT] 返回给调用者有关设备属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 bool 类型的指定节点的值。 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CC_SetBoolValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBoolValue ( IN void * handle, 

IN const char * strKey, 

IN bool bValue 

)

设置 Boolean 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 bValue [IN] 想要设置的设备的属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 bool 类型的指定节点的值。 

示例 

ChunkData.cpp , ConfigLightController.cpp , InterfaceDemo.cpp ,

LineScanSoftwareTrigger.cpp , ParametrizeCamera_AreaScanIOSettings.cpp , 以及 ParametrizeCamera_LineScanIOSettings.cpp .

◆ MV_CC_GetStringValue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetStringValue ( IN void * handle, 

IN const char * strKey, 

IN OUT MVCC_STRINGVALUE * pstStringValue 

)

获取 String 属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

pstStringValue [IN][OUT] 返回给调用者有关设备属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 string 类型的指定节点的值。 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CC_SetStringValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetStringValue ( IN void * handle, 

IN const char * strKey, IN const char * strValue 

)

设置 String 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

strValue [IN] 想要设置的设备的属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 string 类型的指定节点的值。 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CC_SetCommandValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetCommandValue ( IN void * handle, 

IN const char * strKey 

)

设置 Command 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置指定的 Command 类型节点。 

示例 

GrabStrategies.cpp , LineScanSoftwareTrigger.cpp ,

ParametrizeCamera_FileAccess.cpp , 以及 QuickSoftwareTrigger.cpp .◆ MV_CC_FeatureLoad() 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureLoad ( IN void * handle, 

IN const char * strFileName 

)

导入设备属性 

参数 

handle [IN] 设备句柄 

strFileName [IN] 属性文件名 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ParametrizeCamera_LoadAndSave.cpp .

◆ MV_CC_FeatureLoadEx() 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureLoadEx ( IN void * handle, 

IN const char * strFileName, 

IN OUT MVCC_NODE_ERROR_LIST * pstNodeErrorList 

)

导入设备属性并保存错误信息列表 

参数 

handle [IN] 设备句柄 /采集卡句柄 

strFileName [IN] 属性文件名 

pstNodeErrorList [IN][OUT] 错误信息列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 部分节点导入失败时，接口返回 MV_OK ，通过错误信息列表中 stNodeError 获取出错 节点及失败原因 • pstNodeErrorList 由用户在外部申请并由内部填充数据，该参数可接受填入 null ，代表 用户不关心导入时的错误信息 

◆ MV_CC_FeatureSave() 

MV_CAMCTRL_API int __stdcall MV_CC_FeatureSave ( IN void * handle, 

IN const char * strFileName 

)

保存设备属性 

参数 

handle [IN] 设备句柄 

strFileName [IN] 属性文件名 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ParametrizeCamera_LoadAndSave.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 读写寄存器 

> 参数设置

通过寄存器地址获取和设置相机寄存器数据 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_ReadMemory (IN void * handle , IN OUT void *pBuffer, IN int64_t nAddress, IN int64_t nLength) 

读内存 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_WriteMemory (IN void * handle , IN const void *pBuffer, IN int64_t nAddress, IN int64_t nLength) 

写内存 更多 ... 

# 详细描述 

通过寄存器地址获取和设置相机寄存器数据 

# 函数说明 

◆ MV_CC_ReadMemory() 

MV_CAMCTRL_API int __stdcall MV_CC_ReadMemory ( IN void * handle, 

IN OUT void * pBuffer, 

IN int64_t nAddress, 

IN int64_t nLength 

)

读内存 

参数 

handle [IN] 设备句柄 pBuffer [IN][OUT] 作为返回值使用，保存读到的内存值（ GEV 设备内存值是按照大端模 式存储的，其它协议设备按照小端存储） 

nAddress [IN] 待读取的内存地址，该地址可以从设备的 Camera.xml 文件中获取，形如 

xxx_RegAddr 的xml 节点值 

nLength [IN] 待读取的内存长度 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

访问设备，读取某段寄存器的数据。 

◆ MV_CC_WriteMemory() 

MV_CAMCTRL_API int __stdcall MV_CC_WriteMemory ( IN void * handle, 

IN const void * pBuffer, 

IN int64_t nAddress, 

IN int64_t nLength 

)

写内存 

参数 

handle [IN] 设备句柄 

pBuffer [IN] 待写入的内存值（注意 GEV 设备内存值要按照大端模式存储，其它协议设备 按照小端存储） 

nAddress [IN] 待写入的内存地址，该地址可以从设备的 Camera.xml 文件中获取，形如 

xxx_RegAddr 的xml 节点值 

nLength [IN] 待写入的内存长度 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

访问设备，把一段数据写入某段寄存器。 

示例 

ForceIPEx.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 设备 XML 文件 

> 参数设置

包含获取设备 XML 文件接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_InvalidateNodes (IN void * handle )

清除 GenICam 节点缓存 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_GetGenICamXML (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT unsigned int *pnDataLen) 

获取设备属性树 XML 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_GetNodeAccessMode (IN void * handle , IN const char *strName, IN OUT enum MV_XML_AccessMode 

*penAccessMode) 

获得当前节点的访问模式 更多 ... MV_CAMCTRL_API int __stdcall MV_XML_GetNodeInterfaceType (IN void * handle , IN const char *strName, IN OUT enum MV_XML_InterfaceType 

*penInterfaceType) 

获得当前节点的类型 更多 ... 

# 详细描述 

包含获取设备 XML 文件接口 

# 函数说明 

◆ MV_CC_InvalidateNodes() 

MV_CAMCTRL_API int __stdcall MV_CC_InvalidateNodes ( IN void * handle )

清除 GenICam 节点缓存 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

在加载工业相机节点时需要读取 GenICam 配置文件，该接口可以起到清除 GenICam 缓存 的功能。 

◆ MV_XML_GetGenICamXML() 

MV_CAMCTRL_API int __stdcall MV_XML_GetGenICamXML ( IN void * handle, 

IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT unsigned int * pnDataLen 

)获取设备属性树 XML 

参数 

handle [IN] 设备句柄 

pData [IN][OUT] XML 数据接收缓存 

nDataSize [IN] 接收缓存大小 

pnDataLen [IN][OUT] 实际数据大小 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 当pData 为NULL 或nDataSize 比实际的 xml 文件小时，不拷贝数据，由 pnDataLen 返回 

xml 文件大小。 

• 当pData 为有效缓存地址，且缓存足够大时，拷贝完整数据保存在该缓存里面，并由 

pnDataLen 返回 xml 文件实际大小。 

◆ MV_XML_GetNodeAccessMode() 

MV_CAMCTRL_API int __stdcall MV_XML_GetNodeAccessMode ( IN void * handle, 

IN const char * strName, 

IN OUT enum MV_XML_AccessMode * penAccessMode 

)

获得当前节点的访问模式 

参数 

handle [IN] 设备句柄 

strName [IN] 节点名称 

penAccessMode [IN][OUT] 节点的访问模式 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , InterfaceDemo.cpp , LineScanSoftwareTrigger.cpp , 以及 ParametrizeCamera_LineScanIOSettings.cpp .◆ MV_XML_GetNodeInterfaceType() 

MV_CAMCTRL_API int __stdcall MV_XML_GetNodeInterfaceType ( IN void * handle, 

IN const char * strName, 

IN OUT enum MV_XML_InterfaceType * penInterfaceType 

)

获得当前节点的类型 

参数 

handle [IN] 设备句柄 

strName [IN] 节点名称 

penInterfaceType [IN][OUT] 节点的类型 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口可以在调用万能接口之前，提前知道节点类型，方便用户选择合适的万能接口进 行节点值的设置和获取。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 函数 

# 读写相机文件 

> 参数设置

包含从设备读取文件、将文件写入设备等接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessRead (IN void * handle , IN 

MV_CC_FILE_ACCESS *pstFileAccess) 

从设备读取文件 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessReadEx (IN void * handle , IN OUT 

MV_CC_FILE_ACCESS_EX *pstFileAccessEx) 

从设备读取文件（扩展接口，文件是 Data 数据） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessWrite (IN void * handle , IN 

MV_CC_FILE_ACCESS *pstFileAccess) 

将文件写入设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessWriteEx (IN void * handle , IN OUT 

MV_CC_FILE_ACCESS_EX *pstFileAccessEx) 

将缓存（ buffer ）写入设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetFileAccessProgress (IN void * handle , IN OUT 

MV_CC_FILE_ACCESS_PROGRESS 

*pstFileAccessProgress) 

获取文件存取的进度 更多 ... 

# 详细描述 

包含从设备读取文件、将文件写入设备等接口 

# 函数说明 ◆ MV_CC_FileAccessRead() 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessRead ( IN void * handle, 

IN MV_CC_FILE_ACCESS * pstFileAccess 

)

从设备读取文件 

参数 

handle [IN] 设备句柄 

pstFileAccess [IN] 文件存取结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ParametrizeCamera_FileAccess.cpp .

◆ MV_CC_FileAccessReadEx() 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessReadEx ( IN void * handle, 

IN OUT MV_CC_FILE_ACCESS_EX * pstFileAccessEx 

)

从设备读取文件（扩展接口，文件是 Data 数据） 

参数 

handle [IN] 设备句柄 

pstFileAccessEx [IN][OUT] 文件存取结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口直接使用缓存数据，进行读写操作，避免直接操作文件出现无权限的问题。该接 口是 MV_CC_FileAccessRead() 的扩展接口。 ◆ MV_CC_FileAccessWrite() 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessWrite ( IN void * handle, 

IN MV_CC_FILE_ACCESS * pstFileAccess 

)

将文件写入设备 

参数 

handle [IN] 设备句柄 

pstFileAccess [IN] 文件存取结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ParametrizeCamera_FileAccess.cpp .

◆ MV_CC_FileAccessWriteEx() 

MV_CAMCTRL_API int __stdcall MV_CC_FileAccessWriteEx ( IN void * handle, 

IN OUT MV_CC_FILE_ACCESS_EX * pstFileAccessEx 

)

将缓存（ buffer ）写入设备 

参数 

handle [IN] 设备句柄 

pstFileAccessEx [IN][OUT] 文件存取结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口直接使用缓存数据，进行写操作，避免直接将文件写入 C盘，系统保护出现写失 败。该接口是 MV_CC_FileAccessWrite() 的扩展接口。 ◆ MV_CC_GetFileAccessProgress() 

MV_CAMCTRL_API int __stdcall MV_CC_GetFileAccessProgr ess ( IN void * handle, 

IN OUT 

MV_CC_FILE_ACCESS_PROGRESS *

pstFileAccessProgre ss 

)

获取文件存取的进度 

参数 

handle [IN] 设备句柄 

pstFileAccessProgress [IN][OUT] 进度内容 

返回 

成功，返回 MV_OK ；失败，返回 状态码 （当前文件存取的状态）。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 图像采集 包含图像获取（回调取图、主动取图）、开始 /结束取流接口等。 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx (IN void * handle , IN 

MvImageCallbackEx cbOutput, IN void *pUser) 

注册图像数据回调 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx2 (IN void * handle , IN 

MvImageCallbackEx2 cbOutput, IN void *pUser, IN bool bAutoFree) 

注册图像数据回调 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_StartGrabbing (IN void * handle )

开始取流 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_StopGrabbing (IN void * handle )

停止取流 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageBuffer (IN void * handle , IN OUT 

MV_FRAME_OUT *pstFrame, IN unsigned int nMsec) 

使用内部缓存获取一帧图片（与 MV_CC_Display() 不能同时 使用） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_FreeImageBuffer (IN void * handle , IN 

MV_FRAME_OUT *pstFrame) 

释放图像缓存（此接口用于释放不再使用的图像缓存，与 

MV_CC_GetImageBuffer() 配套使用） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameTimeout (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pstFrameInfo, IN unsigned int nMsec) 

采用超时机制获取一帧图片， SDK 内部等待直到有数据时返回 

更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ClearImageBuffer (IN void * handle )

清除取流数据缓存 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_GetValidImageNum (IN void * handle , IN OUT unsigned int *pnValidImageNum) 

获取当前图像缓存区的有效图像个数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetImageNodeNum (IN void * handle , IN unsigned int nNum) 

设置 SDK 内部图像缓存节点个数，大于等于 1，在抓图前调用 

更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGrabStrategy (IN void * handle , IN 

MV_GRAB_STRATEGY enGrabStrategy) 

设置取流策略 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetOutputQueueSize (IN void * handle , IN unsigned int nOutputQueueSize) 

设置输出缓存个数（只有在 MV_GrabStrategy_LatestImages 

策略下才有效，范围： 1-ImageNodeNum ） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetPayloadSize (IN void * handle , IN OUT uint64_t *pnPayloadSize, IN OUT unsigned int *pnAlignment) 

获取设备 payload 大小（ payload 包含图像数据和 Chunk 数据） 和内存对其方式，用于 SDK 外部注册缓存时，应用层分配足够 的缓存及正确的内存对齐方式 更多 ... 

# 详细描述 

包含图像获取（回调取图、主动取图）、开始 /结束取流接口等。 

支持通过 ISP 工具生成的配置文件在取图接口内部对图像进行 ISP 算法处理。 

使用时需要先安装 ISP 插件库，并在 C盘个人目录下创建 “ISPTool” 文件夹（例如 

C:/Users/zhangsan/ISPTool ），并将连接相机生成的配置文件以相机型号或序列号命名的文件夹形 式放置在 ISPTool 下。 

具体配置文件请联系技术支持获取。 

# 函数说明 ◆ MV_CC_RegisterImageCallBackEx() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx ( IN void * handle, 

IN MvImageCallbackEx cbOutput, 

IN void * pUser 

)

注册图像数据回调 

参数 

handle [IN] 设备句柄 

cbOutput [IN] 回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以设置图像数据回调函数，在 MV_CC_CreateHandle() 之后即可调用 。

• 图像数据采集有两种方式，两种方式不能复用： 

1. 调用 MV_CC_RegisterImageCallBackEx() 设置图像数据回调函数，然后调用 

MV_CC_StartGrabbing() 开始采集，采集的图像数据在设置的回调函数中返回 。

2. 调用 MV_CC_StartGrabbing() 开始采集，然后在应用层循环调用 

MV_CC_GetImageBuffer() 和 MV_CC_FreeImageBuffer() 获取指定像素格式 的帧数据，获取帧数据时上层应用程序需要根据帧率控制好调用该接口的频率。 

• 该接口不支持 MV_CAMERALINK_DEVICE() 的设备。 

◆ MV_CC_RegisterImageCallBackEx2() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackEx2 ( IN void * handle, 

IN MvImageCallbackEx2 cbOutput, 

IN void * pUser, 

IN bool bAutoFree )

注册图像数据回调 

参数 

handle [IN] 设备句柄 

cbOutput [IN] 回调函数指针 

bAutoFree [IN] 图像缓存自动回收标记 

￿ true ：回调结束后，图像缓存会被 SDK 回收 

￿ false ：回调结束后，需要调用 MV_CC_FreeImageBuffer() 接口才能 回收图像缓存 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

￿ 通过该接口可以设置图像数据回调函数，在 MV_CC_CreateHandle() 之后即可 调用。 

￿ 该接口不支持 MV_CAMERALINK_DEVICE 类型的设备。 

￿ 该方式与 MV_CC_RegisterImageCallBackEx() 等注册图像回调函数的接口互 斥； 

￿ 该接口与 MV_CC_GetImageBuffer() 、 MV_CC_GetOneFrameTimeout() 等主动取流接口互斥； 

￿ 该接口中 MvImageCallbackEx2 的“MV_FRAME_OUT* pstFrame” 为SDK 内部 变量。如需在回调函数外使用，您需浅拷贝 pstFrame 结构体 (不需要拷贝图像数 据)。

示例 

ChunkData.cpp , Events_Interface.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , ParametrizeCamera_AreaScanIOSettings.cpp , 以及 ParametrizeCamera_LineScanIOSettings.cpp .

◆ MV_CC_StartGrabbing() 

MV_CAMCTRL_API int __stdcall MV_CC_StartGrabbing ( IN void * handle )开始取流 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口不支持 CameraLink 设备。 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , Grab_ActionCommand.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_StopGrabbing() 

MV_CAMCTRL_API int __stdcall MV_CC_StopGrabbing ( IN void * handle )

停止取流 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口不支持 CameraLink 设备。 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Events_Interface.cpp , Grab_ActionCommand.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_GetImageBuffer() 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageBuffer ( IN void * handle, 

IN OUT MV_FRAME_OUT * pstFrame, 

IN unsigned int nMsec 

)

使用内部缓存获取一帧图片（与 MV_CC_Display() 不能同时使用） 

参数 

handle [IN] 设备句柄 

pstFrame [IN][OUT] 图像数据和图像信息 

nMsec [IN] 等待超时时间，输入 INFINITE 时表示无限等待，直到收到一帧数据或者停止 取流 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 调用该接口获取图像数据帧之前需要先调用 MV_CC_StartGrabbing() 启动图像采集 。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率 。该接口支持设置超时时间， SDK 内部等待直到有数据时返回，可以增加取流平稳性， 适合用于对平稳性要求较高的场合。 

• 该接口与 MV_CC_FreeImageBuffer() 配套使用，当处理完取到的数据后，需要用 

MV_CC_FreeImageBuffer() 接口将 pstFrame 内的数据指针权限进行释放。 

• 该接口与 MV_CC_GetOneFrameTimeout() 相比，有着更高的效率。且其取流缓存 的分配是由 sdk 内部自动分配的，而 MV_CC_GetOneFrameTimeout() 接口是需要客户 自行分配。 

• 该接口在调用 MV_CC_Display() 后无法取流。 

• 该接口对于 U3V 、GIGE 设备均可支持。 

• 该接口不支持 CameraLink 设备。 

示例 ConnectSpecCamera.cpp , ConvertPixelType.cpp , Grab_ActionCommand.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_FreeImageBuffer() 

MV_CAMCTRL_API int __stdcall MV_CC_FreeImageBuffer ( IN void * handle, 

IN MV_FRAME_OUT * pstFrame 

)

释放图像缓存（此接口用于释放不再使用的图像缓存，与 MV_CC_GetImageBuffer() 配套使 用） 

参数 

handle [IN] 设备句柄 

pstFrame [IN] 图像数据和图像数据 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 该接口与 MV_CC_GetImageBuffer() 配套使用，使用 MV_CC_GetImageBuffer() 接口取到的图像数据 pstFrame ，需要用 MV_CC_FreeImageBuffer() 接口进行权限释放。 

• 该接口对于取流效率高于 MV_CC_GetOneFrameTimeout() 接口，且 

MV_CC_GetImageBuffer() 在不进行 Free 的情况下，最大支持输出的节点数与 

MV_CC_SetImageNodeNum() 接口所设置的节点数相等，默认节点数是 1。

• 该接口对于 U3V 、GIGE 设备均可支持。 

• 该接口不支持 CameraLink 设备。 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

Events_Interface.cpp , Grab_ActionCommand.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_CC_GetOneFrameTimeout() 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameTimeout ( IN void * handle, 

IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT MV_FRAME_OUT_INFO_EX * pstFrameInfo, 

IN unsigned int nMsec 

)

采用超时机制获取一帧图片， SDK 内部等待直到有数据时返回 

参数 

handle [IN] 设备句柄 

pData [IN][OUT] 图像数据接收指针 

nDataSize [IN] 接收缓存大小 

pstFrameInfo [IN][OUT] 图像信息结构体 

nMsec [IN] 等待超时时间 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 调用该接口获取图像数据帧之前需要先调用 MV_CC_StartGrabbing() 启动图像采集 。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率 。该接口支持设置超时时间， SDK 内部等待直到有数据时返回，可以增加取流平稳性， 适合用于对平稳性要求较高的场合。 

• 该接口对于 U3V 、GIGE 设备均可支持。 

• 该接口不支持 CameraLink 设备。 

◆ MV_CC_ClearImageBuffer() 

MV_CAMCTRL_API int __stdcall MV_CC_ClearImageBuffer ( IN void * handle )

清除取流数据缓存 参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 该接口允许用户在不停止取流的时候，就能清除缓存中不需要的图像。 

• 该接口在连续模式切触发模式后，可以清除历史数据。 

• 该接口当前仅支持清除 SDK 内部的图像缓存，暂不支持清除采集卡内的缓存。 

◆ MV_CC_GetValidImageNum() 

MV_CAMCTRL_API int __stdcall MV_CC_GetValidImageNum ( IN void * handle, 

IN OUT unsigned int * pnValidImageNum 

)

获取当前图像缓存区的有效图像个数 

参数 

handle [IN] 设备句柄 

pnValidImageNum [IN][OUT] 当前图像缓存区中有效图像个数的指针 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

该接口只统计 SDK 内部的有效图像个数，不包括采集卡缓存内的有效图像个数 

◆ MV_CC_SetImageNodeNum() 

MV_CAMCTRL_API int __stdcall MV_CC_SetImageNodeNum ( IN void * handle, 

IN unsigned int nNum 

)

设置 SDK 内部图像缓存节点个数，大于等于 1，在抓图前调用 

参数 

handle [IN] 设备句柄 nNum [IN] 缓存节点个数 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

￿ 调用该接口可以设置 SDK 内部图像缓存节点个数，在调用 

MV_CC_StartGrabbing() 开始抓图前调用。 

￿ 由于不同相机的取流方式不同，在不调用 MV_CC_SetImageNodeNum 接口情 况下，不同相机的默认缓存节点个数不同。比如双 U内部默认分配 3个节点。 

￿ SDK 实际分配的节点个数 = SDK 内部预分配的个数 + 通过调用该接口分配的节 点；若系统内存资源不够， SDK 内部将重新计算预分配的缓存节点个数，在该情 况下， SDK 实际分配的节点个数以重新计算的节点个数为准。 

￿ 该接口不支持 CameraLink 设备。 CameraLink 设备可以通过 GenTL 方式连接并设 置缓存节点个数。 

示例 

GrabStrategies.cpp .

◆ MV_CC_SetGrabStrategy() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGrabStrategy ( IN void * handle, 

IN MV_GRAB_STRATEGY enGrabStrategy 

)

设置取流策略 

参数 

handle [IN] 设备句柄 

enGrabStrategy [IN] 策略枚举值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口定义了四种取流策略，用户可以根据实际需求进行选择。具体描述如下： 

￿ OneByOne ：从旧到新一帧一帧的从输出缓存列表中获取图像，打开设备后默认 为该策略 ￿ LatestImagesOnly ：仅从输出缓存列表中获取最新的一帧图像，同时清空输出缓 存列表 

￿ LatestImages ：从输出缓存列表中获取最新的 OutputQueueSize 帧图像，其中 

OutputQueueSize 范围为 1-ImageNodeNum ，可用 

MV_CC_SetOutputQueueSize() 接口设置， ImageNodeNum 默认为 1，可用 

MV_CC_SetImageNodeNum() 接口设置 OutputQueueSize 设置成 1等同于 

LatestImagesOnly 策略， OutputQueueSize 设置成 ImageNodeNum 等同于 

OneByOne 策略 

￿ UpcomingImage ：在调用取流接口时忽略输出缓存列表中所有图像，并等待设 备即将生成的一帧图像。该策略仅支持 GigE 设备和 USB 设备 

• 该接口仅支持 GigE 和USB 设备。 

示例 

GrabStrategies.cpp .

◆ MV_CC_SetOutputQueueSize() 

MV_CAMCTRL_API int __stdcall MV_CC_SetOutputQueueSize ( IN void * handle, 

IN unsigned int nOutputQueueSize 

)

设置输出缓存个数（只有在 MV_GrabStrategy_LatestImages 策略下才有效，范围： 1-ImageNodeNum ）

参数 

handle [IN] 设备句柄 

nOutputQueueSize [IN] 输出缓存个数 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

￿ 该接口需与 LatestImages 取流策略配套调用，可用于设置 LatestImages 策略下最 多允许缓存图像的个数。通过该接口，您可以在取流过程中动态调节输出缓存个 数。 

￿ 若您使用的是双 U口相机，则 nOutputQueueSize 最小应设置为 2。

￿ 该接口仅支持 GigE 和USB 设备。 示例 

GrabStrategies.cpp .

◆ MV_CC_GetPayloadSize() 

MV_CAMCTRL_API int __stdcall MV_CC_GetPayloadSize ( IN void * handle, 

IN OUT uint64_t * pnPayloadSize, 

IN OUT unsigned int * pnAlignment 

)

获取设备 payload 大小（ payload 包含图像数据和 Chunk 数据）和内存对其方式，用于 SDK 外部 注册缓存时，应用层分配足够的缓存及正确的内存对齐方式 

参数 

handle [IN] 设备句柄 

pnPayloadSize [IN][OUT] 负载长度 

pnAlignment [IN][OUT] 负载内存对齐的字节数 

返回 

成功，返回 MV_OK ，失败，返回 状态码。 

备注 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> 函数

# 图像渲染 

包含图像渲染相关接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrameEx (IN void * handle , IN void *hWnd, IN MV_DISPLAY_FRAME_INFO_EX *pstDisplayInfo) 

显示一帧图像（扩展接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrameEx2 (IN void * handle , IN void *hWnd, IN MV_CC_IMAGE *pstImage, unsigned int enRenderMode) 

显示一帧图像（扩展接口 2） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DrawRect (IN void * handle , IN MVCC_RECT_INFO 

*pRectInfo) 

在图像上绘制矩形框辅助线 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DrawCircle (IN void * handle , IN 

MVCC_CIRCLE_INFO *pCircleInfo) 

在图像上绘制圆形辅助线 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DrawLines (IN void * handle , IN 

MVCC_LINES_INFO *pLinesInfo) 

在图像上绘制线条 更多 ... 

# 详细描述 

包含图像渲染相关接口 函数说明 

◆ MV_CC_DisplayOneFrameEx() 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrameEx ( IN void * handle, 

IN void * hWnd, 

IN MV_DISPLAY_FRAME_INFO_EX * pstDisplayInfo 

)

显示一帧图像（扩展接口） 

参数 

handle [IN] 设备句柄 

hWnd [IN] 窗口句柄 

pstDisplayInfo [IN] 图像信息 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口支持渲染的图像宽、高可达到 Int 类型。可选择 GDI 或D3D 渲染模式，默认选择 

GDI 模式。关于渲染模式的说明如下： 

￿ GDI 模式：对电脑的显卡性能没有要求，适用于所有电脑。 

￿ D3D 模式：适用于已安装显卡驱动且显卡内存大于 1GB 的电脑。在该模式下，客 户端预览的图像效果会优于 GDI 模式下的图像效果。该模式支持的最大图像分辨 率为 16384 * 163840 。

◆ MV_CC_DisplayOneFrameEx2() 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrameEx2 ( IN void * handle, 

IN void * hWnd, 

IN MV_CC_IMAGE * pstImage, 

unsigned int enRenderMode 

)显示一帧图像（扩展接口 2）

参数 

handle [IN] 设备句柄 

hWnd [IN] 窗口句柄 

pstImage [IN] 图像信息 

enRenderMode [IN] 渲染方式： 0-GDI 1-D3D 2-OpenGL 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

• 此接口支持 4GB 以上超大图渲染，调用时需要输入 MV_CC_IMAGE 结构体中 

nImageLen 的值。 

• D3D 和OpenGL 模式适用于安装显卡驱动且显卡内存大于 1GB 的电脑，该模式下客户 端预览的图像效果会优于 GDI 模式下的图像效果。渲染模式为 D3D 时，支持的最大分辨 率为 16384 * 163840 。

• 根据图像大小是否超过 4GB ，该接口可选的渲染模式不同，详情如下： 

￿ 若图像大小大于 4GB ，仅支持使用 OpenGL 模式渲染图像，并且支持渲染 

RGB8_Packed ，BGR8_Packed 和Mono8 格式的图像。 

￿ 若图像大小小于 4GB ，可根据实际情况选择 GDI 、D3D 或OpenGL 模式。若选择 渲染的图像格式为 RGB8_Packed ，BGR8_Packed 或Mono8 格式，该渲染图像 的宽高可达到 int 类型。 

示例 

GrabImage_Display.cpp .

◆ MV_CC_DrawRect() 

MV_CAMCTRL_API int __stdcall MV_CC_DrawRect ( IN void * handle, 

IN MVCC_RECT_INFO * pRectInfo 

)

在图像上绘制矩形框辅助线 

参数 

handle [IN] 设备句柄 

pRectInfo [IN] 矩形辅助线的信息 返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_DrawCircle() 

MV_CAMCTRL_API int __stdcall MV_CC_DrawCircle ( IN void * handle, 

IN MVCC_CIRCLE_INFO * pCircleInfo 

)

在图像上绘制圆形辅助线 

参数 

handle [IN] 设备句柄 

pCircleInfo [IN] 圆形辅助线的信息 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_DrawLines() 

MV_CAMCTRL_API int __stdcall MV_CC_DrawLines ( IN void * handle, 

IN MVCC_LINES_INFO * pLinesInfo 

)

在图像上绘制线条 

参数 

handle [IN] 设备句柄 

pLinesInfo [IN] 线条辅助线信息 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 图像处理 

包括图像显示、图像保存和图像格式转换接口等 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx3 (IN void * handle , IN OUT 

MV_SAVE_IMAGE_PARAM_EX3 *pstSaveParam) 

保存图片，支持 Bmp 和Jpeg 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFileEx (IN void * handle , IN OUT 

MV_SAVE_IMAGE_TO_FILE_PARAM_EX 

*pstSaveFileParam) 

保存图像到文件 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFileEx2 (IN void * handle , IN 

MV_CC_IMAGE *pstImage, IN 

MV_CC_SAVE_IMAGE_PARAM *pSaveImageParam, IN const char *pcImagePath) 

保存图像到文件 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RotateImage (IN void * handle , IN OUT 

MV_CC_ROTATE_IMAGE_PARAM *pstRotateParam) 

图像旋转 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_FlipImage (IN void * handle , IN OUT 

MV_CC_FLIP_IMAGE_PARAM *pstFlipParam) 

图像翻转 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ConvertPixelTypeEx (IN void * handle , IN OUT 

MV_CC_PIXEL_CONVERT_PARAM_EX *pstCvtParam) 

像素格式转换 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCvtQuality (IN void * handle , IN unsigned int nBayerCvtQuality) 

设置插值算法类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerFilterEnable (IN void * handle , IN bool bFilterEnable) 

插值算法平滑使能设置 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerGammaValue (IN void * handle , IN float fBayerGammaValue) 

设置 Bayer 格式的 Gamma 值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGammaValue (IN void * handle , IN enum 

MvGvspPixelType enSrcPixelType, IN float fGammaValue) 

设置 Mono8/Bayer8/10/12/16 格式的 Gamma 值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerGammaParam (IN void * handle , IN 

MV_CC_GAMMA_PARAM *pstGammaParam) 

设置 Bayer 格式的 Gamma 信息 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCCMParam (IN void * handle , IN 

MV_CC_CCM_PARAM *pstCCMParam) 

设置 Bayer 格式的 CCM 使能和矩阵，量化系数默认 1024 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCCMParamEx (IN void * handle , IN 

MV_CC_CCM_PARAM_EX *pstCCMParam) 

设置 Bayer 格式的 CCM 使能和矩阵 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ImageContrast (IN void * handle , IN OUT 

MV_CC_CONTRAST_PARAM *pstContrastParam) 

图像对比度调节 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_PurpleFringing (IN void * handle , IN 

MV_CC_PURPLE_FRINGING_PARAM 

*pstPurpleFringingParam) 

图像去紫边 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetISPConfig (void * handle , IN 

MV_CC_ISP_CONFIG_PARAM *pstParam) 

设置 ISP 参数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ISPProcess (void * handle , IN MV_CC_IMAGE 

*pstInputImage, MV_CC_IMAGE *pstOutputImage) 

对图像进行 ISP 算法处理 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_HB_Decode (IN void * handle , IN OUT 

MV_CC_HB_DECODE_PARAM *pstDecodeParam) 

无损解码 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_StartRecord (IN void * handle , IN 

MV_CC_RECORD_PARAM *pstRecordParam) 

开始录像 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_InputOneFrame (IN void * handle , IN 

MV_CC_INPUT_FRAME_INFO *pstInputFrameInfo) 

输入录像数据 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_StopRecord (IN void * handle )

停止录像 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ReconstructImage (IN void * handle , IN OUT 

MV_RECONSTRUCT_IMAGE_PARAM 

*pstReconstructParam) 

重构图像（用于分时曝光功能） 更多 ... 

# 详细描述 

包括图像显示、图像保存和图像格式转换接口等 函数说明 

◆ MV_CC_SaveImageEx3() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx3 ( IN void * handle, 

IN OUT MV_SAVE_IMAGE_PARAM_EX3 * pstSaveParam 

)

保存图片，支持 Bmp 和Jpeg 

参数 

handle [IN] 设备句柄 

pstSaveParam [IN][OUT] 保存图片参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以将从设备采集到的原始图像数据转换成 JPEG 或者 BMP 等格式并存放 在指定内存中，然后用户可以将转换之后的数据直接保存成图片文件。 

• 该接口调用无接口顺序要求，有图像源数据就可以进行转换，可以先调用 

MV_CC_GetOneFrameTimeout() 或者 MV_CC_RegisterImageCallBackEx() 设置回 调函数，获取一帧图像数据，然后再通过该接口转换格式。 

• 该接口支持长乘宽至 UINT_MAX ，其中 MV_CC_SaveImageEx2() 支持长乘宽最大至 

USHRT_MAX ，JPEG 格式最大支持宽高为 65500 。

◆ MV_CC_SaveImageToFileEx() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFile Ex ( IN void * handle, 

IN OUT 

MV_SAVE_IMAGE_TO_FILE_PARAM_EX *

pstSaveFilePara m

)

保存图像到文件 参数 

handle [IN] 设备句柄 

pstSaveFileParam [IN][OUT] 保存图片文件参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 该接口支持 BMP/JPEG/PNG/TIFF 。

• 该接口支持保存的图像长乘宽至 UINT_MAX ， MV_CC_SaveImageToFile() 支持长 乘宽最大至 USHRT_MAX 。JPEG 格式最大支持宽高为 65500 px 。

• 该接口是 MV_CC_SaveImageToFile() 接口的扩展接口。 

◆ MV_CC_SaveImageToFileEx2() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFileEx2 ( IN void * handle, 

IN MV_CC_IMAGE * pstImage, 

IN MV_CC_SAVE_IMAGE_PARAM * pSaveImageParam, 

IN const char * pcImagePath 

)

保存图像到文件 

参数 

handle [IN] 设备句柄 

pstImage [IN] 图像信息 

pSaveImageParam [IN] 存图参数 

pcImagePath [IN] 存图路径 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 该接口支持 4G 以上超大图的 PNG/TIFF 存图，非超大图像支持 BMP/JPEG/TIFF/PNG 

。

• JPEG 格式最大支持宽高为 65500 px 。

示例 HighBandwidthDecode.cpp , ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ MV_CC_RotateImage() 

MV_CAMCTRL_API int __stdcall MV_CC_RotateImage ( IN void * handle, 

IN OUT MV_CC_ROTATE_IMAGE_PARAM * pstRotateParam 

)

图像旋转 

参数 

handle [IN] 设备句柄 

pstRotateParam [IN][OUT] 图像旋转参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口只支持 MONO8/RGB24/BGR24 格式数据的 90/180/270 度旋转。 

◆ MV_CC_FlipImage() 

MV_CAMCTRL_API int __stdcall MV_CC_FlipImage ( IN void * handle, 

IN OUT MV_CC_FLIP_IMAGE_PARAM * pstFlipParam 

)

图像翻转 

参数 

handle [IN] 设备句柄 

pstFlipParam [IN][OUT] 图像翻转结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 该接口只支持 MONO8/RGB24/BGR24 格式数据的垂直和水平翻转。 

◆ MV_CC_ConvertPixelTypeEx() 

MV_CAMCTRL_API int __stdcall MV_CC_ConvertPixelTypeE x ( IN void * handle, 

IN OUT MV_CC_PIXEL_CONVERT_PARAM_EX 

*

pstCvtParam 

)

像素格式转换 

参数 

handle [IN] 设备句柄 

pstCvtParam [IN][OUT] 像素格式转换参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以将从设备采集到的原始图像数据转换成用户所需的像素格式并存放在 指定内存中。 

• 该接口调用无接口顺序要求，有图像源数据就可以进行转换，可以先调用 

MV_CC_GetOneFrameTimeout() 或者 MV_CC_RegisterImageCallBackEx() 设置回 调函数，获取一帧图像数据，然后再通过该接口转换格式。如果设备当前采集图像是 

JPEG 压缩的格式，则不支持调用该接口进行转换。 

• 该接口支持转换的图像长乘宽至 UINT_MAX 。

• 像素格式转换能力的详情，如下表所示。第一列为输入像素格式，第一行为转换后的 像素格式。 “ √ ”代表可以转换为目标像素格式。 

输入格式 \输出格 式 Mono8 RGB24 BGR24 YUV422 YV12 YUV422 YUYV 

Mono8 × √ √ √ √ ×

Mono10 √ √ √ √ √ ×

Mono10P √ √ √ √ √ ×

Mono12 √ √ √ √ √ ×

Mono12P √ √ √ √ √ ×BayerGR8 √ √ √ √ √ ×

BayerRG8 √ √ √ √ √ ×

BayerGB8 √ √ √ √ √ ×

BayerBG8 √ √ √ √ √ ×

BayerRBGG8 × √ √ × × ×

BayerGR10 √ √ √ √ √ ×

BayerRG10 √ √ √ √ √ ×

BayerGB10 √ √ √ √ √ ×

BayerBG10 √ √ √ √ √ ×

BayerGR12 √ √ √ √ √ ×

BayerRG12 √ √ √ √ √ ×

BayerGB12 √ √ √ √ √ ×

BayerBG12 √ √ √ √ √ ×

BayerGR10P √ √ √ √ √ ×

BayerRG10P √ √ √ √ √ ×

BayerGB10P √ √ √ √ √ ×

BayerBG10P √ √ √ √ √ ×

BayerGR12P √ √ √ √ √ ×

BayerRG12P √ √ √ √ √ ×

BayerGB12P √ √ √ √ √ ×

BayerBG12P √ √ √ √ √ ×

RGB8P √ × √ √ √ ×

BGR8P √ √ × √ √ ×

YUV422P √ √ √ × √ ×

YUV422 YUYV √ √ √ √ √ ×

示例 

ConvertPixelType.cpp .

◆ MV_CC_SetBayerCvtQuality() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCvtQuality ( IN void * handle, IN unsigned int nBayerCvtQuality 

)

设置插值算法类型 

参数 

handle [IN] 设备句柄 

BayerCvtQuality [IN] Bayer 的插值方法 0：快速 1：均衡 2：最优（默认为最优） 3：最优 

+

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

设置内部图像转换接口的 Bayer 插值算法类型参数， MV_CC_ConvertPixelTypeEx() 、

MV_CC_GetImageForRGB() 和 MV_CC_GetImageForBGR() 接口内部使用的插值算 法是该接口所设定的。 

示例 

ConvertPixelType.cpp .

◆ MV_CC_SetBayerFilterEnable() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerFilterEnable ( IN void * handle, 

IN bool bFilterEnable 

)

插值算法平滑使能设置 

参数 

handle [IN] 设备句柄 

bFilterEnable [IN] 平滑使能（默认关闭） 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

设置内部图像转换接口的贝尔插值平滑使能参数， MV_CC_ConvertPixelTypeEx() 、

MV_CC_SaveImageEx3() 接口内部使用的插值算法是该接口所设定的。 ◆ MV_CC_SetBayerGammaValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerGammaValue ( IN void * handle, 

IN float fBayerGammaValue 

)

设置 Bayer 格式的 Gamma 值

参数 

handle [IN] 设备句柄 

fBayerGammaValue [IN] Gamma 值： 0.1 ~ 4.0 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

设置该值后，在调用 MV_CC_ConvertPixelTypeEx() 、 MV_CC_SaveImageEx3() 、

MV_CC_SaveImageToFile() 接口将 Bayer8/10/12/16 格式转成 RGB24/48 ，

RGBA32/64 ，BGR24/48 ，BGRA32/64 时起效。 

◆ MV_CC_SetGammaValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGammaValue ( IN void * handle, 

IN enum MvGvspPixelType enSrcPixelType, 

IN float fGammaValue 

)

设置 Mono8/Bayer8/10/12/16 格式的 Gamma 值

参数 

handle [IN] 设备句柄 

MvGvspPixelType enSrcPixelType [IN] 像素格式 ,支持 

PixelType_Gvsp_Mono8,Bayer8/10/12/16 

fGammaValue [IN] Gamma 值:0.1 ~ 4.0 

返回 

成功，返回 MV_OK ；失败，返回 状态码 注解 

• 设置 Mono8 的gamma 值后，在调用 MV_CC_ConvertPixelType() 接口将 Mono8 转成 

Mono8 时gamma 值起效。 

• 设置 Bayer8/10/12/16 的gamma 值后，在调用 MV_CC_ConvertPixelType() 、

MV_CC_SaveImageToFile() 、 MV_CC_SaveImageEx3() 接口将 Bayer8/10/12/16 转

RGB24/48 ， RGBA32/64 ，BGR24/48 ，BGRA32/64 时gamma 值起效。 

• 该接口兼容 MV_CC_SetBayerGammaValue() 接口，新增支持 Mono8 像素格式。 

◆ MV_CC_SetBayerGammaParam() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerGammaParam ( IN void * handle, 

IN MV_CC_GAMMA_PARAM * pstGammaParam 

)

设置 Bayer 格式的 Gamma 信息 

参数 

handle [IN] 设备句柄 

pstGammaParam [IN] Gamma 信息 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

• 设置该信息后，在调用 MV_CC_ConvertPixelTypeEx() 、

MV_CC_SaveImageEx3() 接口将 Bayer8/10/12/16 格式转成 RGB24/48 ， RGBA32/64 

，BGR24/48 ，BGRA32/64 时起效。 

• 以相机实际支持为准。 

◆ MV_CC_SetBayerCCMParam() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCCMParam ( IN void * handle, 

IN MV_CC_CCM_PARAM * pstCCMParam 

)

设置 Bayer 格式的 CCM 使能和矩阵，量化系数默认 1024 参数 

handle [IN] 设备句柄 

pstCCMParam [IN] CCM 参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

开启 CCM 并设置 CCM 矩阵后，在调用 MV_CC_ConvertPixelTypeEx() 、

MV_CC_SaveImageEx3() 接口将 Bayer8/10/12/16 格式转成 RGB24/48 ， RGBA32/64 

，BGR24/48 ，BGRA32/64 时起效。 

◆ MV_CC_SetBayerCCMParamEx() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCCMParamEx ( IN void * handle, 

IN MV_CC_CCM_PARAM_EX * pstCCMParam 

)

设置 Bayer 格式的 CCM 使能和矩阵 

参数 

handle [IN] 设备句柄 

pstCCMParam [IN] CCM 参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

开启 CCM 并设置 CCM 矩阵后，在调用 MV_CC_ConvertPixelTypeEx() 、

MV_CC_SaveImageEx3() 接口将 Bayer8/10/12/16 格式转成 RGB24/48 ， RGBA32/64 

，BGR24/48 ，BGRA32/64 时起效。 

◆ MV_CC_ImageContrast() 

MV_CAMCTRL_API int __stdcall MV_CC_ImageContrast ( IN void * handle, 

IN OUT MV_CC_CONTRAST_PARAM * pstContrastParam 

)图像对比度调节 

参数 

handle [IN] 设备句柄 

pstContrastParam [IN][OUT] 对比度调节参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

示例 

ImageContrast.cpp .

◆ MV_CC_PurpleFringing() 

MV_CAMCTRL_API int __stdcall MV_CC_PurpleFringing ( IN void * handle, 

IN MV_CC_PURPLE_FRINGING_PARAM * pstPurpleFringingParam 

)

图像去紫边 

参数 

handle [IN] 设备句柄 

pstPurpleFringingParam [IN][OUT] 去紫边参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

像素格式仅支持 PixelType_Gvsp_RGB8_Packed 和PixelType_Gvsp_BGR8_Packed 。

◆ MV_CC_SetISPConfig() 

MV_CAMCTRL_API int __stdcall MV_CC_SetISPConfig ( void * handle, 

IN MV_CC_ISP_CONFIG_PARAM * pstParam 

)

设置 ISP 参数 参数 

handle [IN] 设备句柄 

pstParam [IN] ISP 配置参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

◆ MV_CC_ISPProcess() 

MV_CAMCTRL_API int __stdcall MV_CC_ISPProcess ( void * handle, 

IN MV_CC_IMAGE * pstInputImage, 

MV_CC_IMAGE * pstOutputImage 

)

对图像进行 ISP 算法处理 

参数 

handle [IN] 设备句柄 

pstInputImage [IN] 输入图像结构体 

pstOutputImage [IN][OUT] 输出图像结构体 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

备注 

需要先调用 MV_CC_SetISPConfig 传入配置文件 , 配置文件由 ISP 工具生成 

◆ MV_CC_HB_Decode() 

MV_CAMCTRL_API int __stdcall MV_CC_HB_Decode ( IN void * handle, 

IN OUT MV_CC_HB_DECODE_PARAM * pstDecodeParam 

)

无损解码 

参数 

handle [IN] 设备句柄 

pstDecodeParam [IN][OUT] 无损解码参数结构体 返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 将从相机中取到的无损压缩码流解码成裸数据，同时支持解析当前相机实时图像的水 印信息（如果输入的无损码流不是当前相机或者不是实时取流的，则水印解析可能异常 ）； 

• 若解码失败，请依次检查以下情况： 

1. CPU 是否支持 SSE AVX 指令集。 

2. 当前帧是否异常（丢包等），若存在，可能导致解码异常。 

3. 相机出图是否异常，即使不丢包也会异常。 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ MV_CC_StartRecord() 

MV_CAMCTRL_API int __stdcall MV_CC_StartRecord ( IN void * handle, 

IN MV_CC_RECORD_PARAM * pstRecordParam 

)

开始录像 

参数 

handle [IN] 设备句柄 

pstRecordParam [IN] 录像参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口最大支持 Width*Height 为8000*8000 大小。若超出，会导致调用 

MV_CC_InputOneFrame() 接口错误。 

示例 

Recording.cpp .◆ MV_CC_InputOneFrame() 

MV_CAMCTRL_API int __stdcall MV_CC_InputOneFrame ( IN void * handle, 

IN MV_CC_INPUT_FRAME_INFO * pstInputFrameInfo 

)

输入录像数据 

参数 

handle [IN] 设备句柄 

pstInputFrameInfo [IN] 录像数据结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

Recording.cpp .

◆ MV_CC_StopRecord() 

MV_CAMCTRL_API int __stdcall MV_CC_StopRecord ( IN void * handle )

停止录像 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

Recording.cpp .

◆ MV_CC_ReconstructImage() 

MV_CAMCTRL_API int __stdcall MV_CC_ReconstructIma ge ( IN void * handle, IN OUT 

MV_RECONSTRUCT_IMAGE_PARAM *

pstReconstructPara m

)

重构图像（用于分时曝光功能） 

参数 

handle [IN] 设备句柄 

pstRestruParam [IN][OUT] 重构图像参数 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

图像分割功能可将多个不同曝光值所对应的图像交叠合并为 1张图像。 

使用时，需与线阵相机的 “MultiLightControl” 节点搭配。假设设置该节点为 2，则相机会 将2个不同曝光值所对应的两张图像交叠合并为 1张图像（实际高度为 2张图像的高度） 发送给上层应用程序。 

此时，调用该接口并传入分时曝光值 nExposureNum 为2，可将相机发送的 1张图像分割 为2张图像，并且这 2张图像分别对应 1个曝光值。 

若使用普通相机或未打开线阵相机的 “MultiLightControl” 节点，且 nExposureNum 设置为 

n，则图像分割无意义，只是将图像按行分割为 n张图像，每张图像的高度变为原图像的 

1/n 。

示例 

MultiLightCtrl_ImageStitching.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明 

> 函数

# 事件及异常 

包括事件及异常接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterExceptionCallBack (IN void * handle , IN 

MvExceptionCallback cbException, IN void *pUser) 

注册异常消息回调，在打开设备之后调用 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterAllEventCallBack (IN void * handle , IN 

MvEventCallback cbEvent, IN void *pUser) 

注册全部事件回调，在打开设备之后调用 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterEventCallBackEx (IN void * handle , IN const char *strEventName, IN MvEventCallback cbEvent, IN void *pUser) 

注册单个事件回调，在打开设备之后调用 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EventNotificationOn (IN void * handle , IN const char *strEventName) 

开启设备指定事件 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EventNotificationOff (IN void * handle , IN const char *strEventName) 

关闭设备指定事件 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterStreamExceptionCallBack (IN void *handle , IN MvStreamExceptionCallback 

cbStreamException, IN void *pUser) 

注册流异常消息回调 更多 ... 详细描述 

包括事件及异常接口 

# 函数说明 

◆ MV_CC_RegisterExceptionCallBack() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterExceptionCallBack ( IN void * handle, 

IN MvExceptionCallback cbException, 

IN void * pUser 

)

注册异常消息回调，在打开设备之后调用 

参数 

handle [IN] 设备句柄 

cbException [IN] 异常回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 该接口需要在 MV_CC_OpenDevice() 打开设备之后调用。 

• 设备异常断开连接后可以在回调里面获取到异常消息， GigE 设备掉线之后需要先调用 

MV_CC_CloseDevice() 接口关闭设备，再调用 MV_CC_OpenDevice() 接口重新打开 设备。 

宏定义 宏定义值 含义 

MV_EXCEPTION_DEV_DISCONNECT 0x00008001 设备断开连接 

◆ MV_CC_RegisterAllEventCallBack() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterAllEventCallBack ( IN void * handle, 

IN MvEventCallback cbEvent, IN void * pUser 

)

注册全部事件回调，在打开设备之后调用 

参数 

handle [IN] 设备句柄 

cbEvent [IN] 事件回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

￿ 通过该接口设置事件回调，可以在回调函数里面获取采集、曝光等事件信息。 

￿ 该接口不支持 CameraLink 设备。 

◆ MV_CC_RegisterEventCallBackEx() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterEventCallBackEx ( IN void * handle, 

IN const char * strEventName, 

IN MvEventCallback cbEvent, 

IN void * pUser 

)

注册单个事件回调，在打开设备之后调用 

参数 

handle [IN] 设备句柄 

strEventName [IN] 事件名称 

cbEvent [IN] 事件回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 ￿ 通过该接口设置事件回调，可以在回调函数里面获取采集、曝光等事件信息。 

￿ 该接口不支持 CameraLink 设备。 

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ MV_CC_EventNotificationOn() 

MV_CAMCTRL_API int __stdcall MV_CC_EventNotificationOn ( IN void * handle, 

IN const char * strEventName 

)

开启设备指定事件 

参数 

handle [IN] 设备句柄 

strEventName [IN] 事件名称 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ MV_CC_EventNotificationOff() 

MV_CAMCTRL_API int __stdcall MV_CC_EventNotificationOff ( IN void * handle, 

IN const char * strEventName 

)

关闭设备指定事件 

参数 

handle [IN] 设备句柄 

strEventName [IN] 事件名称 

返回 

成功，返回 MV_OK ；失败，返回 状态码 ◆ MV_CC_RegisterStreamExceptionCallBack() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterStreamExceptionCallBa ck ( IN void * handle, 

IN 

MvStreamExceptionCallback 

cbStreamExceptio n, 

IN void * pUser 

)

注册流异常消息回调 

参数 

handle [IN] 设备句柄 

cbStreamException [IN] 异常回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

￿ 该接口注册的回调函数中不能调用 MV_CC_StopGrabbing() 、

MV_CC_CloseDevice() 和 MV_CC_DestroyHandle() 接口，只用于消息通知 。

￿ 该接口不支持虚拟相机和导入三方 cti 的场景。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明 

> 函数

# 串口控制相关 

用于在工业相机外接串口设备时（如液态镜头），通过 SDK 串口控制相关接口，实现与相机外接的 串口设备进行通信。 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Open (IN void * handle )

打开串口 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Write (IN void * handle , IN const void *pBuffer, IN unsigned int nLength, OUT unsigned int *pnWriteLen) 

向串口写数据，一次最大写 1024 字节的数据。 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Read (IN void * handle , OUT void *pBuffer, IN unsigned int nLength, OUT unsigned int *pnReadLen, IN unsigned int nMsec) 

读串口数据 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_ClearBuffer (IN void * handle )

清空已接收的串口数据 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Close (IN void * handle )

关闭串口 更多 ... 

# 详细描述 

用于在工业相机外接串口设备时（如液态镜头），通过 SDK 串口控制相关接口，实现与相机外接的 串口设备进行通信。 函数说明 

◆ MV_CC_SerialPort_Open() 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Open ( IN void * handle )

打开串口 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

此接口适用于支持串口通信的相机。 

◆ MV_CC_SerialPort_Write() 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Write ( IN void * handle, 

IN const void * pBuffer, 

IN unsigned int nLength, 

OUT unsigned int * pnWriteLen 

)

向串口写数据，一次最大写 1024 字节的数据。 

参数 

handle [IN] 设备句柄 

pBuffer [IN] 数据缓冲区 

nLength [IN] 数据长度 

pnWriteLen [OUT] 实际写成功的数据长度 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

接口为阻塞模式，数据全部发送完成或者发送失败时返回。 ◆ MV_CC_SerialPort_Read() 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Read ( IN void * handle, 

OUT void * pBuffer, 

IN unsigned int nLength, 

OUT unsigned int * pnReadLen, 

IN unsigned int nMsec 

)

读串口数据 

参数 

handle [IN] 设备句柄 

pBuffer [IN] 数据缓冲区 

nLength [IN] 数据缓冲区长度 

pnReadLen [OUT] 实际读到的数据长度 

nMsec [IN] 超时时间，单位： ms 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

备注 

接口为阻塞模式，有收到数据、超时时间到、出现异常时返回 

◆ MV_CC_SerialPort_ClearBuffer() 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_ClearBuffer ( IN void * handle )

清空已接收的串口数据 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_SerialPort_Close() 

MV_CAMCTRL_API int __stdcall MV_CC_SerialPort_Close ( IN void * handle )关闭串口 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# GigE 相机 

仅GigE 相机支持的接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_GetOptimalPacketSize (IN void * handle )

获取最佳的 packet size ，该接口目前只支持 GigE 相机 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetEnumDevTimeout (IN unsigned int nMilTimeout) 设置枚举超时时间，仅支持 GigE 协议，范围 1-UINT_MAX （包括 1，不包括 UINT_MAX ） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_ForceIpEx (IN void * handle , IN unsigned int nIP, IN unsigned int nSubNetMask, IN unsigned int nDefaultGateWay) 

强制 IP 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetIpConfig (IN void * handle , IN unsigned int nType) 

配置 IP 方式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetNetTransMode (IN void * handle , IN unsigned int nType) 

设置仅使用某种模式， type: MV_NET_TRANS_x ，不设置时 ，默认优先使用 driver 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetNetTransInfo (IN void * handle , IN OUT 

MV_NETTRANS_INFO *pstInfo) 

获取网络传输信息 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetDiscoveryMode (IN unsigned int nMode) 

设置枚举命令的回复包类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGvspTimeout (IN void * handle , IN unsigned int nMillisec) 

设置 GVSP 取流超时时间 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGvspTimeout (IN void * handle , IN OUT unsigned int *pnMillisec) 

获取 GVSP 取流超时时间 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGvcpTimeout (IN void * handle , IN unsigned int nMillisec) 

设置 GVCP 命令超时时间 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGvcpTimeout (IN void * handle , IN OUT unsigned int *pnMillisec) 

获取 GVCP 命令超时时间 更多 ... MV_CAMCTRL_API int __stdcall MV_GIGE_SetRetryGvcpTimes (IN void * handle , IN unsigned int nRetryGvcpTimes) 

设置重传 GVCP 命令次数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetRetryGvcpTimes (IN void * handle , IN OUT unsigned int *pnRetryGvcpTimes) 

获取重传 GVCP 命令次数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResend (IN void * handle , IN unsigned int bEnable, IN unsigned int nMaxResendPercent, IN unsigned int nResendTimeout) 

设置是否打开重发包支持，及重发包设置 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResendMaxRetryTimes (IN void * handle , IN unsigned int nRetryTimes) 

设置重传命令最大尝试次数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetResendMaxRetryTimes (IN void * handle , IN OUT unsigned int *pnRetryTimes) 

获取重传命令最大尝试次数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResendTimeInterval (IN void * handle , IN unsigned int nMillisec) 

设置同一重传包多次请求之间的时间间隔 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetResendTimeInterval (IN void * handle , IN OUT unsigned int *pnMillisec) 

获取同一重传包多次请求之间的时间间隔 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetTransmissionType (IN void * handle , IN 

MV_TRANSMISSION_TYPE *pstTransmissionType) 

设置传输模式，可以为单播模式、组播模式等 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_IssueActionCommand (IN 

MV_ACTION_CMD_INFO *pstActionCmdInfo, IN OUT 

MV_ACTION_CMD_RESULT_LIST *pstActionCmdResults) 

发出动作命令 更多 ... MV_CAMCTRL_API int __stdcall MV_GIGE_GetMulticastStatus (IN MV_CC_DEVICE_INFO 

*pstDevInfo, IN OUT bool *pbStatus) 

获取组播状态 更多 ... 

# 详细描述 

仅GigE 相机支持的接口 

# 函数说明 

◆ MV_CC_GetOptimalPacketSize() 

MV_CAMCTRL_API int __stdcall MV_CC_GetOptimalPacketSize ( IN void * handle )

获取最佳的 packet size ，该接口目前只支持 GigE 相机 

参数 

handle [IN] 设备句柄 

返回 

最佳 packetsize 

注解 

• 获取最佳的 packet size ，对应 GigEVision 设备是 SCPS ，对应 U3V 设备是每次从驱动读 取的包大小，该大小即网络上传输一个包的大小。 

• 该接口需要在 MV_CC_OpenDevice() 之后、 MV_CC_StartGrabbing() 之前调用。 

• 该接口不支持 CameraLink 设备、 U3V 设备。 

• 该接口不支持 GenTL 设备（协议不支持），如果是 GenTL 方式添加的网口相机，建议 根据网络实际情况配置 GevSCPSPacketSize ，或者配置 1500 。

示例 

ConnectSpecCamera.cpp , ConvertPixelType.cpp , Events.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ MV_GIGE_SetEnumDevTimeout() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetEnumDevTimeout ( IN unsigned int nMilTimeout )

设置枚举超时时间，仅支持 GigE 协议，范围 1-UINT_MAX （包括 1，不包括 UINT_MAX ）

参数 

nMilTimeout [IN] 超时时间（ ms ），需设置整数，默认 100 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 在调用 MV_CC_EnumDevices() 等枚举接口前使用该接口，可设置枚举 GIGE 设备的 网卡最大超时时间（默认 100ms ），可以减少最大超时时间，以加快枚举 GIGE 设备的速 度。 

• 该接口仅支持输入无符号整数。 • 仅支持 GigEVision 设备。 

◆ MV_GIGE_ForceIpEx() 

MV_CAMCTRL_API int __stdcall MV_GIGE_ForceIpEx ( IN void * handle, 

IN unsigned int nIP, 

IN unsigned int nSubNetMask, 

IN unsigned int nDefaultGateWay 

)

强制 IP 

参数 

handle [IN] 设备句柄 

nIP [IN] 设置的 IP 

nSubNetMask [IN] 子网掩码 

nDefaultGateWay [IN] 默认网关 

返回 

成功，返回 MV_OK ；失败，返回 状态码 注解 

• 强制设置设备网络参数（包括 IP 、子网掩码、默认网关），强制设置之后将需要重新 创建设备句柄，仅 GigEVision 设备支持。 

• 如果设备为 DHCP 的状态，调用该接口强制设置设备网络参数之后设备将会重启。 

示例 

ForceIPEx.cpp .

◆ MV_GIGE_SetIpConfig() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetIpConfig ( IN void * handle, 

IN unsigned int nType 

)

配置 IP 方式 

参数 

handle [IN] 设备句柄 

nType [IN] IP 类型，见 MV_IP_CFG_x 

宏定义 宏定义值 含义 

MV_IP_CFG_STATIC 0x05000000 固定 IP 地址模式 

MV_IP_CFG_DHCP 0x06000000 DHCP 自动获取 IP 模式 

MV_IP_CFG_LLA 0x04000000 LLA(Link-local address) ，链路本地地址 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

发送命令设置设备的 IP 方式，如 DHCP 、LLA 等，仅 GigEVision 设备支持。 

示例 

ForceIPEx.cpp .

◆ MV_GIGE_SetNetTransMode() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetNetTransMode ( IN void * handle, 

IN unsigned int nType 

)设置仅使用某种模式， type: MV_NET_TRANS_x ，不设置时，默认优先使用 driver 

参数 

handle [IN] 设备句柄 

nType [IN] 网络传输模式，见 MV_NET_TRANS_x 

宏定义 宏定义值 含义 

MV_NET_TRANS_DRIVER 0x00000001 驱动模式 

MV_NET_TRANS_SOCKET 0x00000002 Socket 模式 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过该接口可以设置 SDK 内部优先使用的网络模式，默认优先使用驱动模式，仅 

GigEVision 设备支持。 

◆ MV_GIGE_GetNetTransInfo() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetNetTransInfo ( IN void * handle, 

IN OUT MV_NETTRANS_INFO * pstInfo 

)

获取网络传输信息 

参数 

handle [IN] 设备句柄 

pstInfo [IN][OUT] 信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过该接口可以获取网络传输相关信息，包括已接收数据大小、丢帧数量等，在 

MV_CC_StartGrabbing() 开启采集之后调用。仅 GigEVision 相机支持。 

◆ MV_GIGE_SetDiscoveryMode() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetDiscoveryMode ( IN unsigned int nMode )设置枚举命令的回复包类型 

参数 

nMode [IN] 回复包类型（默认广播）， 0-单播， 1-广播 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口只对 GigE 相机有效。 

◆ MV_GIGE_SetGvspTimeout() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGvspTimeout ( IN void * handle, 

IN unsigned int nMillisec 

)

设置 GVSP 取流超时时间 

参数 

handle [IN] 设备句柄 

nMillisec [IN] 超时时间，默认 300ms ，范围： >10ms 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后，取流动作发生前，调用该接口可以设置 GVSP 取流超时时间。 GVSP 取流 超时设置过短可能造成图像异常，设置过长可能造成取流时间变长。 

◆ MV_GIGE_GetGvspTimeout() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGvspTimeout ( IN void * handle, 

IN OUT unsigned int * pnMillisec 

)

获取 GVSP 取流超时时间 

参数 handle [IN] 设备句柄 

pnMillisec [IN][OUT] 超时时间指针，以毫秒为单位 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于获取当前的 GVSP 取流超时时间。 

◆ MV_GIGE_SetGvcpTimeout() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGvcpTimeout ( IN void * handle, 

IN unsigned int nMillisec 

)

设置 GVCP 命令超时时间 

参数 

handle [IN] 设备句柄 

nMillisec [IN] 超时时间，默认 500ms ，范围： 0-10000ms 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 GVCP 命令超时时间。 

◆ MV_GIGE_GetGvcpTimeout() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGvcpTimeout ( IN void * handle, 

IN OUT unsigned int * pnMillisec 

)

获取 GVCP 命令超时时间 

参数 

handle [IN] 设备句柄 

pnMillisec [IN][OUT] 超时时间指针，以毫秒为单位 

返回 成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于获取当前的 GVCP 超时时间。 

◆ MV_GIGE_SetRetryGvcpTimes() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetRetryGvcpTimes ( IN void * handle, 

IN unsigned int nRetryGvcpTimes 

)

设置重传 GVCP 命令次数 

参数 

handle [IN] 设备句柄 

nRetryGvcpTimes [IN] 重传次数，范围： 0-100 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于在 GVCP 包传输异常时，增加重传的次数，在一定程度上可以避免设备掉线 ，范围为 0-100 。

◆ MV_GIGE_GetRetryGvcpTimes() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetRetryGvcpTimes ( IN void * handle, 

IN OUT unsigned int * pnRetryGvcpTimes 

)

获取重传 GVCP 命令次数 

参数 

handle [IN] 设备句柄 

pnRetryGvcpTimes [IN][OUT] 重传次数指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 注解 

该接口用于获取当前的 GVCP 重传次数，默认 3次。 

◆ MV_GIGE_SetResend() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResend ( IN void * handle, 

IN unsigned int bEnable, 

IN unsigned int nMaxResendPercent, 

IN unsigned int nResendTimeout 

)

设置是否打开重发包支持，及重发包设置 

参数 

handle [IN] 设备句柄 

bEnable [IN] 是否支持重发包 

nMaxResendPercent [IN] 最大重发比 

nResendTimeout [IN] 重发超时时间 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置重发包属性，仅 GigEVision 相机支持。 

◆ MV_GIGE_SetResendMaxRetryTimes() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResendMaxRetryTimes ( IN void * handle, 

IN unsigned int nRetryTimes 

)

设置重传命令最大尝试次数 

参数 

handle [IN] 设备句柄 

nRetryTimes [IN] 重传命令最大尝试次数，默认值 20 

返回 成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口必须在调用 MV_GIGE_SetResend() 开启重传包功能之后调用，否则失败且返回 

MV_E_CALLORDER 。

◆ MV_GIGE_GetResendMaxRetryTimes() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetResendMaxRetryTimes ( IN void * handle, 

IN OUT unsigned int * pnRetryTimes 

)

获取重传命令最大尝试次数 

参数 

handle [IN] 设备句柄 

pnRetryTimes [IN][OUT] 重传命令最大尝试次数 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口必须在调用 MV_GIGE_SetResend() 开启重传包功能之后调用，否则失败且返回 

MV_E_CALLORDER 。

◆ MV_GIGE_SetResendTimeInterval() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetResendTimeInterval ( IN void * handle, 

IN unsigned int nMillisec 

)

设置同一重传包多次请求之间的时间间隔 

参数 

handle [IN] 设备句柄 

nMillisec [IN] 同一重传包多次请求之间的时间间隔，默认 10ms 

返回 

成功，返回 MV_OK ；失败，返回 状态码 注解 

该接口必须在调用 MV_GIGE_SetResend() 开启重传包功能之后调用，否则失败且返回 

MV_E_CALLORDER 。

◆ MV_GIGE_GetResendTimeInterval() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetResendTimeInterval ( IN void * handle, 

IN OUT unsigned int * pnMillisec 

)

获取同一重传包多次请求之间的时间间隔 

参数 

handle [IN] 设备句柄 

pnMillisec [IN][OUT] 同一重传包多次请求之间的时间间隔 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口必须在调用 MV_GIGE_SetResend() 开启重传包功能之后调用，否则失败且返回 

MV_E_CALLORDER 。

◆ MV_GIGE_SetTransmissionType() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetTransmissionType ( IN void * handle, 

IN MV_TRANSMISSION_TYPE * pstTransmissionType 

)

设置传输模式，可以为单播模式、组播模式等 

参数 

handle [IN] 设备句柄 

pstTransmissionT ype 

[IN] 传输模式结构体 

宏定义 宏定义 值

含义MV_GIGE_TRANSTYPE_UNICAST 0 单播

MV_GIGE_TRANSTYPE_MULTICAST 1 组播

MV_GIGE_TRANSTYPE_LIMITEDBROADCAST 2

表示局域网内广播

MV_GIGE_TRANSTYPE_SUBNETBROADCAS T 3

表示子网内广播

MV_GIGE_TRANSTYPE_CAMERADEFINED 4

表示从相机获取

MV_GIGE_TRANSTYPE_UNICAST_DEFINED_ PORT 5

表示用户自定义应用端接收图像数据

Por t号

MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_ RECV 

000100 00 

表示设置了单播，但本实例不接收图像数据

MV_GIGE_TRANSTYPE_MULTICAST_WITHOU T_RECV 

000100 01 

表示组播模式，但本实例不接收图像数据

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过该接口可以设置传输模式为单播、组播等模式，仅 GigEVision 相机支持。 

示例 

MultiCast.cpp .

◆ MV_GIGE_IssueActionCommand() 

MV_CAMCTRL_API int __stdcall MV_GIGE_IssueActionComm and ( IN MV_ACTION_CMD_INFO * pstActionCmdInfo, 

IN OUT 

MV_ACTION_CMD_RESULT_LIST *

pstActionCmdResult s

)

发出动作命令 

参数 

pstActionCmdInfo [IN] 动作命令信息 

pstActionCmdResults [IN][OUT] 动作命令返回信息列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

仅GigEVision 相机支持。 

示例 

Grab_ActionCommand.cpp .◆ MV_GIGE_GetMulticastStatus() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetMulticastStatus ( IN MV_CC_DEVICE_INFO * pstDevInfo, 

IN OUT bool * pbStatus 

)

获取组播状态 

参数 

pstDevInfo [IN] 设备信息结构体 

pbStatus [IN][OUT] 组播状态（ true ：组播状态； false ：非组播） 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于判断设备当前是否处于组播状态，解决客户端枚举时需要打开设备判断组播 的问题。 

仅支持标准 GigE Vision 设备。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# U3V 相机 

仅U3V 相机支持的接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_USB_SetTransferSize (IN void * handle , IN unsigned int nTransferSize) 

设置 U3V 的传输包大小 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_GetTransferSize (IN void * handle , IN OUT unsigned int *pnTransferSize) 

获取 U3V 的传输包大小 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_SetTransferWays (IN void * handle , IN unsigned int nTransferWays) 

设置 U3V 的传输通道个数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_GetTransferWays (IN void * handle , unsigned int *pnTransferWays) 

获取 U3V 的传输通道个数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_SetEventNodeNum (IN void * handle , IN unsigned int nEventNodeNum) 

设置 U3V 的事件缓存节点个数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_SetSyncTimeOut (IN void * handle , IN unsigned int nMills) 

设置 U3V 相机同步读写超时时间，范围： 1000-UINT_MAX ，（包含 1000 ，不包含 UNIT_MAX ），默认 1000 ms 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_GetSyncTimeOut (IN void * handle , IN OUT unsigned int *pnMills) 

获取 U3V 相机同步读写超时时间 更多 ... 

# 详细描述 仅U3V 相机支持的接口 

# 函数说明 

◆ MV_USB_SetTransferSize() 

MV_CAMCTRL_API int __stdcall MV_USB_SetTransferSize ( IN void * handle, 

IN unsigned int nTransferSize 

)

设置 U3V 的传输包大小 

参数 

handle [IN] 设备句柄 

nTransferSize [IN] 传输的包大小， Byte ，默认为 1M ，rang ：>=0x400 ，建议最大值： 

[windows] rang <= 0x400000 ；[Linux] rang <= 0x200000 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

增加传输包大小可以适当降低取流时的 CPU 占用率。但不同的 PC 和不同 USB 扩展卡存在 不同的兼容性，如果该参数设置过大可能会出现取不到图像的风险。 

◆ MV_USB_GetTransferSize() 

MV_CAMCTRL_API int __stdcall MV_USB_GetTransferSize ( IN void * handle, 

IN OUT unsigned int * pnTransferSize 

)

获取 U3V 的传输包大小 

参数 

handle [IN] 设备句柄 

pnTransferSize [IN][OUT] 传输的包大小指针， Byte 

返回 

成功，返回 MV_OK ；失败，返回 状态码 注解 

该接口用于获取当前的 U3V 传输包大小，默认 1M 。

◆ MV_USB_SetTransferWays() 

MV_CAMCTRL_API int __stdcall MV_USB_SetTransferWays ( IN void * handle, 

IN unsigned int nTransferWays 

)

设置 U3V 的传输通道个数 

参数 

handle [IN] 设备句柄 

nTransferWays [IN] 传输通道个数，范围： 1-10 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可根据 PC 的性能、设备出图帧率、图像大小和内存使用率等因素对该参数进行调节。但 不同的 PC 和不同的 USB 扩展卡存在不同的兼容性。 

◆ MV_USB_GetTransferWays() 

MV_CAMCTRL_API int __stdcall MV_USB_GetTransferWays ( IN void * handle, 

unsigned int * pnTransferWays 

)

获取 U3V 的传输通道个数 

参数 

handle [IN] 设备句柄 

pnTransferWays [IN][OUT] 传输通道个数指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于获取当前的 U3V 异步取流节点个数， U口相机传输通道个数和像素格式对应 的负载包大小相关，可通过（最大异步注册长度 /像素格式对应的负载包大小）计算得出 。

2000W 设备的 MONO8 默认为 3个， YUV 为默认 2个， RGB 为默认 1个，其它情况默认 8个节点。 

◆ MV_USB_SetEventNodeNum() 

MV_CAMCTRL_API int __stdcall MV_USB_SetEventNodeNum ( IN void * handle, 

IN unsigned int nEventNodeNum 

)

设置 U3V 的事件缓存节点个数 

参数 

handle [IN] 设备句柄 

nEventNodeNum [IN] 事件缓存节点个数，范围： 1-64 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于设置当前的 U3V 事件缓存节点个数，默认情况下为 5个。 

◆ MV_USB_SetSyncTimeOut() 

MV_CAMCTRL_API int __stdcall MV_USB_SetSyncTimeOut ( IN void * handle, 

IN unsigned int nMills 

)

设置 U3V 相机同步读写超时时间，范围： 1000-UINT_MAX ，（包含 1000 ，不包含 UNIT_MAX 

），默认 1000 ms 

参数 

handle [IN] 设备句柄 

nMills [IN] 设置同步读写超时时间（ ms ），默认值为 1000 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 增加设置同步读取时间接口，兼容部分相机配置参数很慢，超过 1s 的情况。 

◆ MV_USB_GetSyncTimeOut() 

MV_CAMCTRL_API int __stdcall MV_USB_GetSyncTimeOut ( IN void * handle, 

IN OUT unsigned int * pnMills 

)

获取 U3V 相机同步读写超时时间 

参数 

handle [IN] 设备句柄 

pnMills [IN][OUT] 获取的超时时间（ ms ）

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于获取当前的 U3V 同步读写超时时间大小，默认 1000ms 。

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 串口设备 

仅串口设备（ Camera Link 相机、串口光源控制器支持的接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CAML_SetDeviceBaudrate (IN void * handle , IN unsigned int nBaudrate) 

设置设备波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_GetDeviceBaudrate (IN void * handle , IN OUT unsigned int *pnCurrentBaudrate) 

获取设备波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSupportBaudrates (IN void * handle , IN OUT unsigned int *pnBaudrateAblity) 

获取设备与主机间连接支持的波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_SetGenCPTimeOut (IN void * handle , IN unsigned int nMillisec) 

设置串口操作等待时长 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSerialPortList (IN OUT 

MV_CAML_SERIAL_PORT_LIST *pstSerialPortList) 

获取串口信息列表 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_SetEnumSerialPorts (IN 

MV_CAML_SERIAL_PORT_LIST *pstSerialPortList) 

设置指定枚举串口列表 更多 ... 

# 详细描述 

仅串口设备（ Camera Link 相机、串口光源控制器支持的接口 

# 函数说明 ◆ MV_CAML_SetDeviceBaudrate() 

MV_CAMCTRL_API int __stdcall MV_CAML_SetDeviceBaudrate ( IN void * handle, 

IN unsigned int nBaudrate 

)

设置设备波特率 

参数 

handle [IN] 设备句柄 

nBaudrate [IN] 设置的波特率值，数值参考 CameraParams.h 中宏定义 

CamercaLink 波特率定义 值 对应的波特率值 

MV_CAML_BAUDRATE_9600 0x00000001 9600 

MV_CAML_BAUDRATE_19200 0x00000002 19200 

MV_CAML_BAUDRATE_38400 0x00000004 38400 

MV_CAML_BAUDRATE_57600 0x00000008 57600 

MV_CAML_BAUDRATE_115200 0x00000010 115200 

MV_CAML_BAUDRATE_230400 0x00000020 230400 

MV_CAML_BAUDRATE_460800 0x00000040 460800 

MV_CAML_BAUDRATE_921600 0x00000080 921600 

MV_CAML_BAUDRATE_AUTOMAX 0x40000000 最大值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口支持在设备未连接时调用。通过 GenTL 协议访问设备时，需要先连接设备，才能 调用该接口。 因硬件 /系统 /外部干扰等因素，配置高波特率可能导致通信异常，建议配置波特率最大小 于115200 。

◆ MV_CAML_GetDeviceBaudrate() 

MV_CAMCTRL_API int __stdcall MV_CAML_GetDeviceBaudrate ( IN void * handle, 

IN OUT unsigned int * pnCurrentBaudrate )

获取设备波特率 

参数 

handle [IN] 设备句柄 

pnCurrentBaudrate [IN][OUT] 波特率信息指针，数值参考 CameraParams.h 中宏定义 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口支持在设备未连接时调用。 

◆ MV_CAML_GetSupportBaudrates() 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSupportBaudrates ( IN void * handle, 

IN OUT unsigned int * pnBaudrateAblity 

)

获取设备与主机间连接支持的波特率 

参数 

handle [IN] 设备句柄 

pnBaudrateAblity [IN][OUT] 支持的波特率信息的指针。所支持波特率的或运算结果，单 个数值参考 CameraParams.h 中宏定义 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口支持在设备未连接时调用。 

◆ MV_CAML_SetGenCPTimeOut() 

MV_CAMCTRL_API int __stdcall MV_CAML_SetGenCPTimeOut ( IN void * handle, 

IN unsigned int nMillisec 

)设置串口操作等待时长 

参数 

handle [IN] 设备句柄 

nMillisec [IN] 串口操作的等待时长，单位为 ms 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CAML_GetSerialPortList() 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSerialPortList ( IN OUT MV_CAML_SERIAL_PORT_LIST * pstSerialPortList )

获取串口信息列表 

参数 

pstSerialPortList [IN][OUT] 串口信息列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于获取本地的串口信息。 

◆ MV_CAML_SetEnumSerialPorts() 

MV_CAMCTRL_API int __stdcall MV_CAML_SetEnumSerialPorts ( IN MV_CAML_SERIAL_PORT_LIST * pstSerialPortList )

设置指定枚举串口列表 

参数 

pstSerialPortList [IN] 串口信息列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口用于设置枚举 CameraLink 设备的指定串口。 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# GenTL 

GenTL 相关接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_EnumInterfacesByGenTL (IN OUT 

MV_GENTL_IF_INFO_LIST *pstIFList, IN const char *strGenTLPath) 

通过 GenTL 枚举 Interfaces 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_UnloadGenTLLibrary (IN const char *pGenTLPath) 

卸载 cti 库 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesByGenTL (IN MV_GENTL_IF_INFO 

*pstIFInfo, IN OUT MV_GENTL_DEV_INFO_LIST *pstDevList) 

通过 GenTL Interface 枚举设备 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_CreateHandleByGenTL (IN OUT void ** handle , IN const MV_GENTL_DEV_INFO *pstDevInfo) 通过 GenTL 设备信息创建设备句柄 更多 ... 

# 详细描述 

GenTL 相关接口 

# 函数说明 

◆ MV_CC_EnumInterfacesByGenTL() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumInterfacesByGenTL ( IN OUT MV_GENTL_IF_INFO_LIST * pstIFList, 

IN const char * strGenTLPath 

)

通过 GenTL 枚举 Interfaces 

参数 

pstIFList [IN][OUT] Interfaces 列表 

strGenTLPath [IN] GenTL 的cti 文件路径 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• Interfaces 列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存 的释放和申请，建议尽量避免多线程枚举操作。 

• 暂不支持直接调用 MvProducerU3V.cti 和MvProducerGEV.cti ， 支持调用其他 .cti 文件 

◆ MV_CC_UnloadGenTLLibrary() 

MV_CAMCTRL_API int __stdcall MV_CC_UnloadGenTLLibrary ( IN const char * pGenTLPath )

卸载 cti 库

参数 pGenTLPath [IN] 枚举卡时加载的 cti 文件路径 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

卸载前需要保证通过该 cti 枚举出的相机已全部关闭，否则报错前置条件错误。 

◆ MV_CC_EnumDevicesByGenTL() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumDevicesByGenTL ( IN MV_GENTL_IF_INFO * pstIFInfo, 

IN OUT MV_GENTL_DEV_INFO_LIST * pstDevList 

)

通过 GenTL Interface 枚举设备 

参数 

pstIFInfo [IN] Interface 信息 

pstDevList [IN][OUT] 设备列表 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

设备列表的内存是在 SDK 内部分配的，多线程调用该接口时会进行设备列表内存的释放 和申请，建议尽量避免多线程枚举操作。 

◆ MV_CC_CreateHandleByGenTL() 

MV_CAMCTRL_API int __stdcall MV_CC_CreateHandleByGenTL ( IN OUT void ** handle, 

IN const MV_GENTL_DEV_INFO * pstDevInfo 

)

通过 GenTL 设备信息创建设备句柄 

参数 

handle [IN][OUT] 设备句柄 

pstDevInfo [IN] 设备信息结构体指针 返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

根据输入的设备信息，创建库内部必须的资源和初始化内部模块。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 类型定义

# 回调函数定义 

注册图像数据、异常消息的回调函数 更多 ... 

# 类型定义 

typedef void(__stdcall * MvImageCallbackEx ) (unsigned char *pData, 

MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser) 

取图回调函数 更多 ... 

typedef void(__stdcall * MvImageCallbackEx2 ) ( MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

取图回调函数 更多 ... typedef void(__stdcall * MvEventCallback ) ( MV_EVENT_OUT_INFO *pEventInfo, void *pUser) 

事件回调函数 更多 ... 

typedef void(__stdcall * MvStreamExceptionCallback )(MV_CC_STREAM_EXCEPTION_INFO *pstStreamExceptionInfo, void *pUser) 

流异常回调函数 更多 ... 

typedef void(__stdcall * MvExceptionCallback ) (unsigned int nMsgType, void *pUser) 

异常消息回调 更多 ... 

# 详细描述 

注册图像数据、异常消息的回调函数 

# 类型定义说明 

◆ MvImageCallbackEx 

typedef void(__stdcall * MvImageCallbackEx) (unsigned char *pData, 

MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser) 

取图回调函数 

参数 

pData [OUT] 图像数据指针 

pFrameInfo [OUT] 图像信息结构体 

pUser [OUT] 用户自定义变量 

◆ MvImageCallbackEx2 

typedef void(__stdcall * MvImageCallbackEx2) ( MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

取图回调函数 参数 

pstFrame [OUT] 图像数据和图像信息 

pUser [OUT] 用户自定义变量 

bAutoFree [OUT] true-回调函数退出后自动释放图像缓存， false-回调结束不释放图像缓存 ，需调用 MV_CC_FreeImageBuffer() 

◆ MvEventCallback 

typedef void(__stdcall * MvEventCallback) ( MV_EVENT_OUT_INFO *pEventInfo, void *pUser) 

事件回调函数 

参数 

pEventInfo [OUT] 事件信息 

pUser [OUT] 用户自定义变量 

◆ MvStreamExceptionCallback 

typedef void(__stdcall * MvStreamExceptionCallback) ( MV_CC_STREAM_EXCEPTION_INFO 

*pstStreamExceptionInfo, void *pUser) 

流异常回调函数 

参数 

pstStreamExceptionInfo [OUT] 流异常信息 

pUser [OUT] 用户自定义变量 

◆ MvExceptionCallback 

typedef void(__stdcall * MvExceptionCallback) (unsigned int nMsgType, void *pUser) 

异常消息回调 

参数 

nMsgType [OUT] 异常类型 

pUser [OUT] 用户自定义变量 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 设备升级 

包含设备升级和获取升级进度接口 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_LocalUpgrade (IN void * handle , IN const void *strFilePathName) 

设备本地升级 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetUpgradeProcess (IN void * handle , IN OUT unsigned int *pnProcess) 

获取升级进度 更多 ... 

# 详细描述 

包含设备升级和获取升级进度接口 函数说明 

◆ MV_CC_LocalUpgrade() 

MV_CAMCTRL_API int __stdcall MV_CC_LocalUpgrade ( IN void * handle, 

IN const void * strFilePathName 

)

设备本地升级 

参数 

handle [IN] 设备句柄 

strFilePathName [IN] 文件名 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过该接口可以将升级固件文件发送给设备进行升级。该接口需要等待升级固件文件成 功传给设备端之后再返回，响应时间可能较长。 

◆ MV_CC_GetUpgradeProcess() 

MV_CAMCTRL_API int __stdcall MV_CC_GetUpgradeProcess ( IN void * handle, 

IN OUT unsigned int * pnProcess 

)

获取升级进度 

参数 

handle [IN] 设备句柄 

pnProcess [IN][OUT] 进度接收地址 

返回 

成功，返回 MV_OK ；失败，返回 状态码 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 结构体

# 结构体定义 

包含相关结构体定义 更多 ... 

# 结构体 

struct MV_GIGE_DEVICE_INFO 

GigE 设备信息 更多 ... 

struct MV_USB3_DEVICE_INFO 

USB 设备信息 更多 ... 

struct MV_CamL_DEV_INFO 

CameraLink 设备信息 更多 ... 

struct MV_CXP_DEVICE_INFO 

CoaXPress 相机信息 更多 ... 

struct MV_CML_DEVICE_INFO 

Camera Link 相机信息 更多 ... struct MV_XOF_DEVICE_INFO 

XoFLink 相机信息 更多 ... 

struct MV_GENTL_VIR_DEVICE_INFO 

虚拟相机信息 更多 ... 

struct MV_CC_DEVICE_INFO 

设备信息 更多 ... 

struct MV_CC_DEVICE_INFO_LIST 

设备信息列表 更多 ... 

struct MV_INTERFACE_INFO 

采集卡信息 更多 ... 

struct MV_INTERFACE_INFO_LIST 

采集卡信息列表 更多 ... 

struct MV_GENTL_IF_INFO 

通过 GenTL 枚举到的接口信息 更多 ... 

struct MV_GENTL_IF_INFO_LIST 

通过 GenTL 枚举到的接口信息列表 更多 ... 

struct MV_GENTL_DEV_INFO 

通过 GenTL 枚举到的设备信息 更多 ... 

struct MV_GENTL_DEV_INFO_LIST 

通过 GenTL 枚举到的设备信息列表 更多 ... 

struct MV_CHUNK_DATA_CONTENT 

Chunk 内容 更多 ... 

struct MV_CC_IMAGE 

图像信息 更多 ... 

struct MV_FRAME_OUT_INFO_EX 

输出帧的信息 更多 ... struct MV_FRAME_OUT 

图像结构体，输出图像地址及图像信息 更多 ... 

struct MV_NETTRANS_INFO 

网络传输的相关信息 更多 ... 

struct MV_ALL_MATCH_INFO 

全匹配的一种信息结构体 更多 ... 

struct MV_MATCH_INFO_NET_DETECT 

网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT 更多 

... 

struct MV_MATCH_INFO_USB_DETECT 

host 收到从 u3v 设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT 更多 

... 

struct MV_DISPLAY_FRAME_INFO_EX 

显示帧信息（适用于例如线阵相机等宽高大于 65535 的设备） 更多 ... 

struct MV_CC_ROTATE_IMAGE_PARAM 

图像旋转结构体 更多 ... 

struct MV_CC_FLIP_IMAGE_PARAM 

图像翻转结构体 更多 ... 

struct MV_CC_CONTRAST_PARAM 

对比度调节结构体 更多 ... 

struct MV_CC_GAMMA_PARAM 

Gamma 信息结构体 更多 ... 

struct MV_CC_CCM_PARAM 

CCM 参数 更多 ... 

struct MV_CC_CCM_PARAM_EX 

CCM 参数（适用于例如线阵相机等宽高大于 65535 的设备） 更多 ... 

struct MV_CC_SHARPEN_PARAM 锐化结构体 更多 ... 

struct MV_CC_RECT_I 

矩形 ROI 结构体 更多 ... 

struct MV_CC_NOISE_ESTIMATE_PARAM 

噪声估计结构体 更多 ... 

struct MV_CC_LSC_CALIB_PARAM 

LSC 标定结构体 更多 ... 

struct MV_CC_LSC_CORRECT_PARAM 

LSC 校正结构体 更多 ... 

struct MV_CC_FRAME_SPEC_INFO 

水印信息 更多 ... 

struct MV_CC_PURPLE_FRINGING_PARAM 

去紫边结构体 更多 ... 

struct MV_CC_ISP_CONFIG_PARAM 

ISP 配置结构体 更多 ... 

struct MV_CC_HB_DECODE_PARAM 

无损解码参数 更多 ... 

struct MV_CC_RECORD_PARAM 

录像参数 更多 ... 

struct MV_CC_INPUT_FRAME_INFO 

传入的图像数据 更多 ... 

struct MV_CC_STREAM_EXCEPTION_INFO 

流异常回调信息 更多 ... 

struct MV_EVENT_OUT_INFO 

Event 事件回调信息 更多 ... 

struct MV_CC_FILE_ACCESS 文件存取 更多 ... 

struct MV_CC_FILE_ACCESS_EX 

文件存取 更多 ... 

struct MV_CC_FILE_ACCESS_PROGRESS 

文件存取进度 更多 ... 

struct MV_TRANSMISSION_TYPE 

网络传输模式 更多 ... 

struct MV_ACTION_CMD_INFO 

动作命令信息 更多 ... 

struct MV_ACTION_CMD_RESULT 

动作命令返回信息 更多 ... 

struct MV_ACTION_CMD_RESULT_LIST 

动作命令返回信息列表 更多 ... 

struct MVCC_NODE_ERROR 

节点错误信息 更多 ... 

struct MVCC_NODE_ERROR_LIST 

节点错误信息列表 更多 ... 

struct MVCC_ENUMVALUE 

枚举类型值 更多 ... 

struct MVCC_ENUMVALUE_EX 

枚举类型值 更多 ... 

struct MVCC_ENUMENTRY 

枚举类型条目 更多 ... 

struct MVCC_INTVALUE 

Int 类型值 更多 ... 

struct MVCC_INTVALUE_EX Int 类型值 Ex 更多 ... 

struct MVCC_FLOATVALUE 

Float 类型值 更多 ... 

struct MVCC_STRINGVALUE 

String 类型值 更多 ... 

struct MVCC_COLORF 

辅助线颜色 更多 ... 

struct MVCC_POINTF 

自定义点 更多 ... 

struct MVCC_RECT_INFO 

矩形框区域信息 更多 ... 

struct MVCC_CIRCLE_INFO 

圆形框区域信息 更多 ... 

struct MVCC_LINES_INFO 

线条辅助线信息 更多 ... 

struct MV_OUTPUT_IMAGE_INFO 

图像重构后的图像列表 更多 ... 

struct MV_RECONSTRUCT_IMAGE_PARAM 

重构图像参数信息 更多 ... 

struct MV_CAML_SERIAL_PORT 

串口信息 更多 ... 

struct MV_CAML_SERIAL_PORT_LIST 

串口信息列表 更多 ... 

struct MV_SAVE_IMAGE_PARAM_EX3 

图片保存参数 更多 ... 

struct MV_SAVE_IMAGE_TO_FILE_PARAM_EX 保存图片到文件参数 更多 ... 

struct MV_CC_SAVE_IMAGE_PARAM 

保存图片所需参数 更多 ... 

struct MV_CC_PIXEL_CONVERT_PARAM_EX 

像素转换结构体 更多 ... 

struct MV_SAVE_POINT_CLOUD_PARAM 

保存 3D 数据到缓存（自 4.4.1 版本废弃） 更多 ... 

struct MV_DISPLAY_FRAME_INFO 

显示帧信息（自 4.4.1 版本废弃） 更多 ... 

# 详细描述 

包含相关结构体定义 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GIGE_DEVICE_INFO 结构体 参考 

> 结构体定义

GigE 设备信息 更多 ... 

# 成员变量 

unsigned int nIpCfgOption 

[OUT] IP 配置选项 更多 ... 

unsigned int nIpCfgCurrent 

[OUT] 当前 IP 配置 更多 ... 

unsigned int nCurrentIp 

[OUT] 当前 IP 地址 更多 ... 

unsigned int nCurrentSubNetMask 

[OUT] 当前子网掩码 更多 ... 

unsigned int nDefultGateWay 

[OUT] 当前网关 更多 ... 

unsigned char chManufacturerName [32] 

[OUT] 制造商名称 更多 ... 

unsigned char chModelName [32] 

[OUT] 型号名称 更多 ... 

unsigned char chDeviceVersion [32] 

[OUT] 设备版本 更多 ... 

unsigned char chManufacturerSpecificInfo [48] 

[OUT] 制造商的具体信息 更多 ... 

unsigned char chSerialNumber [16] 

[OUT] 序列号 更多 ... 

unsigned char chUserDefinedName [16] [OUT] 用户自定义名称 更多 ... 

unsigned int nNetExport 

[OUT] 网口 IP 地址 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

GigE 设备信息 

示例 

ConnectSpecCamera.cpp .

# 结构体成员变量说明 

◆ nIpCfgOption 

unsigned int nIpCfgOption 

[OUT] IP 配置选项 

◆ nIpCfgCurrent 

unsigned int nIpCfgCurrent 

[OUT] 当前 IP 配置 

◆ nCurrentIp 

unsigned int nCurrentIp 

[OUT] 当前 IP 地址 示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ nCurrentSubNetMask 

unsigned int nCurrentSubNetMask 

[OUT] 当前子网掩码 

示例 

ForceIPEx.cpp .

◆ nDefultGateWay 

unsigned int nDefultGateWay 

[OUT] 当前网关 

示例 

ForceIPEx.cpp .

◆ chManufacturerName 

unsigned char chManufacturerName[32] 

[OUT] 制造商名称 

◆ chModelName unsigned char chModelName[32] 

[OUT] 型号名称 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ chDeviceVersion 

unsigned char chDeviceVersion[32] 

[OUT] 设备版本 

◆ chManufacturerSpecificInfo 

unsigned char chManufacturerSpecificInfo[48] 

[OUT] 制造商的具体信息 

◆ chSerialNumber 

unsigned char chSerialNumber[16] 

[OUT] 序列号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ chUserDefinedName 

unsigned char chUserDefinedName[16] 

[OUT] 用户自定义名称 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ nNetExport 

unsigned int nNetExport 

[OUT] 网口 IP 地址 

示例 

ConnectSpecCamera.cpp .

◆ nReserved 

unsigned int nReserved[4] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_USB3_DEVICE_INFO 结构体 参考 

> 结构体定义

USB 设备信息 更多 ... 

# 成员变量 

unsigned char CrtlInEndPoint 

[OUT] 控制输入端点 更多 ... 

unsigned char CrtlOutEndPoint 

[OUT] 控制输出端点 更多 ... 

unsigned char StreamEndPoint 

[OUT] 流端点 更多 ... 

unsigned char EventEndPoint 

[OUT] 事件端点 更多 ... 

unsigned short idVendor 

[OUT] 供应商 ID 号 更多 ... unsigned short idProduct 

[OUT] 产品 ID 号 更多 ... 

unsigned int nDeviceNumber 

[OUT] 设备索引号 更多 ... 

unsigned char chDeviceGUID [INFO_MAX_BUFFER_SIZE ]

[OUT] 设备 GUID 号 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

[OUT] 供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 更多 ... 

unsigned char chFamilyName [INFO_MAX_BUFFER_SIZE ]

[OUT] 家族名字 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

[OUT] 设备版本 更多 ... 

unsigned char chManufacturerName [INFO_MAX_BUFFER_SIZE ]

[OUT] 制造商名字 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

[OUT] 用户自定义名字 更多 ... 

unsigned int nbcdUSB 

[OUT] 支持的 USB 协议 更多 ... 

unsigned int nDeviceAddress 

[OUT] 设备地址 更多 ... 

unsigned int nReserved [2] 

预留 更多 ... 详细描述 

USB 设备信息 

# 结构体成员变量说明 

◆ CrtlInEndPoint 

unsigned char CrtlInEndPoint 

[OUT] 控制输入端点 

◆ CrtlOutEndPoint 

unsigned char CrtlOutEndPoint 

[OUT] 控制输出端点 

◆ StreamEndPoint 

unsigned char StreamEndPoint 

[OUT] 流端点 

◆ EventEndPoint 

unsigned char EventEndPoint 

[OUT] 事件端点 

◆ idVendor 

unsigned short idVendor [OUT] 供应商 ID 号

◆ idProduct 

unsigned short idProduct 

[OUT] 产品 ID 号

◆ nDeviceNumber 

unsigned int nDeviceNumber 

[OUT] 设备索引号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ chDeviceGUID 

unsigned char chDeviceGUID[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备 GUID 号

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 供应商名字 ◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 

◆ chFamilyName 

unsigned char chFamilyName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 家族名字 

◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备版本 

◆ chManufacturerName 

unsigned char chManufacturerName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 制造商名字 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 用户自定义名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ nbcdUSB 

unsigned int nbcdUSB 

[OUT] 支持的 USB 协议 

◆ nDeviceAddress 

unsigned int nDeviceAddress 

[OUT] 设备地址 

◆ nReserved 

unsigned int nReserved[2] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CamL_DEV_INFO 结构体 参考 

> 结构体定义

CameraLink 设备信息 更多 ... 

# 成员变量 

unsigned char chPortID [INFO_MAX_BUFFER_SIZE ]

[OUT] 端口号 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 更多 ... 

unsigned char chFamilyName [INFO_MAX_BUFFER_SIZE ]

[OUT] 名称 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ][OUT] 设备版本 更多 ... 

unsigned char chManufacturerName [INFO_MAX_BUFFER_SIZE ]

[OUT] 制造商名字 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 更多 ... 

unsigned int nReserved [38] 

预留 更多 ... 

# 详细描述 

CameraLink 设备信息 

# 结构体成员变量说明 

◆ chPortID 

unsigned char chPortID[ INFO_MAX_BUFFER_SIZE ]

[OUT] 端口号 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 

◆ chFamilyName 

unsigned char chFamilyName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 名称 ◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备版本 

◆ chManufacturerName 

unsigned char chManufacturerName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 制造商名字 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 

◆ nReserved 

unsigned int nReserved[38] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_CXP_DEVICE_INFO 结构体 参考 

> 结构体定义

CoaXPress 相机信息 更多 ... 

# 成员变量 

unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

采集卡 ID 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

型号名字 更多 ... 

unsigned char chManufacturerInfo [INFO_MAX_BUFFER_SIZE ]

厂商信息 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

相机版本 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

序列号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

用户自定义名字 更多 ... 

unsigned char chDeviceID [INFO_MAX_BUFFER_SIZE ]

相机 ID 更多 ... 

unsigned int nReserved [7] 

保留字段 更多 ... 详细描述 

CoaXPress 相机信息 

# 结构体成员变量说明 

◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

采集卡 ID 

示例 

QuickSoftwareTrigger.cpp .

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

供应商名字 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

型号名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .◆ chManufacturerInfo 

unsigned char chManufacturerInfo[ INFO_MAX_BUFFER_SIZE ]

厂商信息 

◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

相机版本 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

序列号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

用户自定义名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ chDeviceID 

unsigned char chDeviceID[ INFO_MAX_BUFFER_SIZE ]

相机 ID 

◆ nReserved 

unsigned int nReserved[7] 

保留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CML_DEVICE_INFO 结构体 参考 

> 结构体定义

Camera Link 相机信息 更多 ... 

# 成员变量 

unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

采集卡 ID 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

型号名字 更多 ... 

unsigned char chManufacturerInfo [INFO_MAX_BUFFER_SIZE ]

厂商信息 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

相机版本 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

序列号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

用户自定义名字 更多 ... 

unsigned char chDeviceID [INFO_MAX_BUFFER_SIZE ]

相机 ID 更多 ... 

unsigned int nReserved [7] 

保留字段 更多 ... 

# 详细描述 Camera Link 相机信息 

# 结构体成员变量说明 

◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

采集卡 ID 

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

供应商名字 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

型号名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ chManufacturerInfo 

unsigned char chManufacturerInfo[ INFO_MAX_BUFFER_SIZE ]

厂商信息 ◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

相机版本 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

序列号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

用户自定义名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .◆ chDeviceID 

unsigned char chDeviceID[ INFO_MAX_BUFFER_SIZE ]

相机 ID 

◆ nReserved 

unsigned int nReserved[7] 

保留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_XOF_DEVICE_INFO 结构体 参考 

> 结构体定义

XoFLink 相机信息 更多 ... 

# 成员变量 unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

采集卡 ID 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

型号名字 更多 ... 

unsigned char chManufacturerInfo [INFO_MAX_BUFFER_SIZE ]

厂商信息 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

相机版本 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

序列号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

用户自定义名字 更多 ... 

unsigned char chDeviceID [INFO_MAX_BUFFER_SIZE ]

相机 ID 更多 ... 

unsigned int nReserved [7] 

保留字段 更多 ... 

# 详细描述 

XoFLink 相机信息 

# 结构体成员变量说明 

◆ chInterfaceID unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

采集卡 ID 

示例 

QuickSoftwareTrigger.cpp .

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

供应商名字 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

型号名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ chManufacturerInfo 

unsigned char chManufacturerInfo[ INFO_MAX_BUFFER_SIZE ]

厂商信息 

◆ chDeviceVersion unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

相机版本 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

序列号 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

用户自定义名字 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .◆ chDeviceID 

unsigned char chDeviceID[ INFO_MAX_BUFFER_SIZE ]

相机 ID 

◆ nReserved 

unsigned int nReserved[7] 

保留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GENTL_VIR_DEVICE_INFO 结构体 参考 

> 结构体定义

虚拟相机信息 更多 ... 

# 成员变量 unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

采集卡 ID 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

型号名字 更多 ... 

unsigned char chManufacturerInfo [INFO_MAX_BUFFER_SIZE ]

厂商信息 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

相机版本 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

序列号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

用户自定义名字 更多 ... 

unsigned char chDeviceID [INFO_MAX_BUFFER_SIZE ]

相机 ID 更多 ... 

unsigned char chTLType [INFO_MAX_BUFFER_SIZE ]

传输层类型 更多 ... 

unsigned int nReserved [7] 

保留字段 更多 ... 

# 详细描述 

虚拟相机信息 

# 结构体成员变量说明 ◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

采集卡 ID 

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

供应商名字 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

型号名字 

◆ chManufacturerInfo 

unsigned char chManufacturerInfo[ INFO_MAX_BUFFER_SIZE ]

厂商信息 

◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

相机版本 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

序列号 ◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

用户自定义名字 

◆ chDeviceID 

unsigned char chDeviceID[ INFO_MAX_BUFFER_SIZE ]

相机 ID 

◆ chTLType 

unsigned char chTLType[ INFO_MAX_BUFFER_SIZE ]

传输层类型 

◆ nReserved 

unsigned int nReserved[7] 

保留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_CC_DEVICE_INFO 结构体 参考 

> 结构体定义

设备信息 更多 ... 

# 成员变量 

unsigned short nMajorVer 

[OUT] 主要版本 更多 ... 

unsigned short nMinorVer 

[OUT] 次要版本 更多 ... 

unsigned int nMacAddrHigh 

[OUT] 高MAC 地址 更多 ... 

unsigned int nMacAddrLow 

[OUT] 低MAC 地址 更多 ... 

unsigned int nTLayerType 

[OUT] 设备传输层协议类型 更多 ... 

unsigned int nDevTypeInfo 

[OUT] 设备类型信息 设备类型规则： 

7 - 0 bit: 预留 

15 - 8 bit ：产品子类别 

23 - 16 bit ：产品类型 

31 - 24bit ：产品线（如 : 0x01 标准产品； 0x02 3D 产品； 0x03 智能 ID 产品） 更多 ... 

unsigned int nReserved [3] 

预留 更多 ... union { 

MV_GIGE_DEVICE_INFO stGigEInfo 

[OUT] GigE 设备信息 更多 ... 

MV_USB3_DEVICE_INFO stUsb3VInfo 

[OUT] USB 设备信息 更多 ... 

MV_CamL_DEV_INFO stCamLInfo 

[OUT] CameraLink 设备信息 更多 ... 

MV_CML_DEVICE_INFO stCMLInfo 

[OUT] 采集卡 CameraLink 设备信息 更多 ... 

MV_CXP_DEVICE_INFO stCXPInfo 

[OUT] 采集卡 CoaXPress 设备信息 更多 ... 

MV_XOF_DEVICE_INFO stXoFInfo 

[OUT] 采集卡 XoF 设备信息 更多 ... 

MV_GENTL_VIR_DEVICE_INFO stVirInfo 

[OUT] 采集卡虚拟设备信息 , 仅支持协议 

MV_GENTL_VIR_DEVICE 更多 ... 

} SpecialInfo 

# 详细描述 

设备信息 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,ParametrizeCamera_AreaScanIOSettings.cpp , ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

# 结构体成员变量说明 

◆ nMajorVer 

unsigned short nMajorVer 

[OUT] 主要版本 

◆ nMinorVer 

unsigned short nMinorVer 

[OUT] 次要版本 

◆ nMacAddrHigh 

unsigned int nMacAddrHigh 

[OUT] 高MAC 地址 

◆ nMacAddrLow 

unsigned int nMacAddrLow 

[OUT] 低MAC 地址 

◆ nTLayerType 

unsigned int nTLayerType 

[OUT] 设备传输层协议类型 示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ nDevTypeInfo 

unsigned int nDevTypeInfo 

[OUT] 设备类型信息 设备类型规则： 

7 - 0 bit: 预留 

15 - 8 bit ：产品子类别 

23 - 16 bit ：产品类型 

31 - 24bit ：产品线（如 : 0x01 标准产品； 0x02 3D 产品； 0x03 智能 ID 产品） 

◆ nReserved 

unsigned int nReserved[3] 

预留 

◆ stGigEInfo 

MV_GIGE_DEVICE_INFO stGigEInfo 

[OUT] GigE 设备信息 

示例 ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ stUsb3VInfo 

MV_USB3_DEVICE_INFO stUsb3VInfo 

[OUT] USB 设备信息 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ stCamLInfo 

MV_CamL_DEV_INFO stCamLInfo 

[OUT] CameraLink 设备信息 

◆ stCMLInfo MV_CML_DEVICE_INFO stCMLInfo 

[OUT] 采集卡 CameraLink 设备信息 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ stCXPInfo 

MV_CXP_DEVICE_INFO stCXPInfo 

[OUT] 采集卡 CoaXPress 设备信息 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ stXoFInfo 

MV_XOF_DEVICE_INFO stXoFInfo 

[OUT] 采集卡 XoF 设备信息 

示例 ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ stVirInfo 

MV_GENTL_VIR_DEVICE_INFO stVirInfo 

[OUT] 采集卡虚拟设备信息 , 仅支持协议 MV_GENTL_VIR_DEVICE 

◆ SpecialInfo 

union { ... } SpecialInfo 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_DEVICE_INFO_LIST 结构体 参考 

> 结构体定义

设备信息列表 更多 ... 

# 成员变量 

unsigned int nDeviceNum 

[OUT] 在线设备数量 更多 ... 

MV_CC_DEVICE_INFO * pDeviceInfo [MV_MAX_DEVICE_NUM ]

[OUT] 支持最多 256 个设备 更多 ... 

# 详细描述 

设备信息列表 

示例 ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp , ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp , ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

# 结构体成员变量说明 

◆ nDeviceNum 

unsigned int nDeviceNum 

[OUT] 在线设备数量 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ pDeviceInfo 

MV_CC_DEVICE_INFO * pDeviceInfo[ MV_MAX_DEVICE_NUM ][OUT] 支持最多 256 个设备 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_INTERFACE_INFO 结构体 参考 

> 结构体定义

采集卡信息 更多 ... 成员变量 

unsigned int nTLayerType 

采集卡类型 更多 ... 

unsigned int nPCIEInfo 

采集卡的 PCIE 插槽信息 更多 ... 

unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

采集卡 ID 更多 ... 

unsigned char chDisplayName [INFO_MAX_BUFFER_SIZE ]

显示名称 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

序列号 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

[OUT] 型号 更多 ... 

unsigned char chManufacturer [INFO_MAX_BUFFER_SIZE ]

[OUT] 厂商 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

[OUT] 版本号 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

[OUT] 自定义名称 更多 ... 

unsigned int nReserved [64] 

保留字段 更多 ... 

# 详细描述 

采集卡信息 示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

# 结构体成员变量说明 

◆ nTLayerType 

unsigned int nTLayerType 

采集卡类型 

示例 

QuickSoftwareTrigger.cpp .

◆ nPCIEInfo 

unsigned int nPCIEInfo 

采集卡的 PCIE 插槽信息 

◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

采集卡 ID 

示例 

QuickSoftwareTrigger.cpp .

◆ chDisplayName 

unsigned char chDisplayName[ INFO_MAX_BUFFER_SIZE ]

显示名称 

示例 ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

序列号 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 型号 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ chManufacturer 

unsigned char chManufacturer[ INFO_MAX_BUFFER_SIZE ]

[OUT] 厂商 

◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

[OUT] 版本号 

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ][OUT] 自定义名称 

◆ nReserved 

unsigned int nReserved[64] 

保留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_INTERFACE_INFO_LIST 结构体 参考 

> 结构体定义

采集卡信息列表 更多 ... 

# 成员变量 

unsigned int nInterfaceNum 

[OUT] 采集卡数量 更多 ... 

MV_INTERFACE_INFO * pInterfaceInfos [MV_MAX_INTERFACE_NUM ][OUT] 采集卡信息，支持最多 64 个设备 更多 ... 

# 详细描述 

采集卡信息列表 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

# 结构体成员变量说明 

◆ nInterfaceNum 

unsigned int nInterfaceNum 

[OUT] 采集卡数量 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ pInterfaceInfos 

MV_INTERFACE_INFO * pInterfaceInfos[ MV_MAX_INTERFACE_NUM ]

[OUT] 采集卡信息，支持最多 64 个设备 

示例 

ConfigLightController.cpp , Events_Interface.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , 以及 QuickSoftwareTrigger.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GENTL_IF_INFO 结构体 参考 

> 结构体定义

通过 GenTL 枚举到的接口信息 更多 ... 

# 成员变量 

unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

[OUT] GenTL 接口 ID 更多 ... 

unsigned char chTLType [INFO_MAX_BUFFER_SIZE ]

[OUT] 传输层类型 更多 ... 

unsigned char chDisplayName [INFO_MAX_BUFFER_SIZE ]

[OUT] Interface 显示名称 更多 ... 

unsigned int nCtiIndex 

[OUT] GenTL 的cti 文件索引 更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 详细描述 

通过 GenTL 枚举到的接口信息 

# 结构体成员变量说明 

◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

[OUT] GenTL 接口 ID 

◆ chTLType 

unsigned char chTLType[ INFO_MAX_BUFFER_SIZE ]

[OUT] 传输层类型 

◆ chDisplayName 

unsigned char chDisplayName[ INFO_MAX_BUFFER_SIZE ]

[OUT] Interface 显示名称 

◆ nCtiIndex 

unsigned int nCtiIndex 

[OUT] GenTL 的cti 文件索引 

◆ nReserved 

unsigned int nReserved[8] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GENTL_IF_INFO_LIST 结构体 参考 

> 结构体定义

通过 GenTL 枚举到的接口信息列表 更多 ... 

# 成员变量 

unsigned int nInterfaceNum 

[OUT] 在线接口数量 更多 ... 

MV_GENTL_IF_INFO * pIFInfo [MV_MAX_GENTL_IF_NUM ]

[OUT] 支持最多 256 个接口 更多 ... 

# 详细描述 通过 GenTL 枚举到的接口信息列表 

# 结构体成员变量说明 

◆ nInterfaceNum 

unsigned int nInterfaceNum 

[OUT] 在线接口数量 

◆ pIFInfo 

MV_GENTL_IF_INFO * pIFInfo[ MV_MAX_GENTL_IF_NUM ]

[OUT] 支持最多 256 个接口 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GENTL_DEV_INFO 结构体 参考 

> 结构体定义

通过 GenTL 枚举到的设备信息 更多 ... 

# 成员变量 

unsigned char chInterfaceID [INFO_MAX_BUFFER_SIZE ]

[OUT] GenTL 接口 ID 更多 ... 

unsigned char chDeviceID [INFO_MAX_BUFFER_SIZE ]

[OUT] 设备 ID 更多 ... 

unsigned char chVendorName [INFO_MAX_BUFFER_SIZE ]

[OUT] 供应商名字 更多 ... 

unsigned char chModelName [INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 更多 ... 

unsigned char chTLType [INFO_MAX_BUFFER_SIZE ]

[OUT] 传输层类型 更多 ... 

unsigned char chDisplayName [INFO_MAX_BUFFER_SIZE ]

[OUT] 设备显示名称 更多 ... 

unsigned char chUserDefinedName [INFO_MAX_BUFFER_SIZE ]

[OUT] 用户自定义名字 更多 ... 

unsigned char chSerialNumber [INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 更多 ... 

unsigned char chDeviceVersion [INFO_MAX_BUFFER_SIZE ]

[OUT] 设备版本号 更多 ... 

unsigned int nCtiIndex 

[OUT] GenTL 的cti 文件索引 更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 详细描述 

通过 GenTL 枚举到的设备信息 

# 结构体成员变量说明 

◆ chInterfaceID 

unsigned char chInterfaceID[ INFO_MAX_BUFFER_SIZE ]

[OUT] GenTL 接口 ID 

◆ chDeviceID 

unsigned char chDeviceID[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备 ID 

◆ chVendorName 

unsigned char chVendorName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 供应商名字 

◆ chModelName 

unsigned char chModelName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 型号名字 

◆ chTLType 

unsigned char chTLType[ INFO_MAX_BUFFER_SIZE ]

[OUT] 传输层类型 ◆ chDisplayName 

unsigned char chDisplayName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备显示名称 

◆ chUserDefinedName 

unsigned char chUserDefinedName[ INFO_MAX_BUFFER_SIZE ]

[OUT] 用户自定义名字 

◆ chSerialNumber 

unsigned char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

[OUT] 序列号 

◆ chDeviceVersion 

unsigned char chDeviceVersion[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备版本号 

◆ nCtiIndex 

unsigned int nCtiIndex 

[OUT] GenTL 的cti 文件索引 

◆ nReserved 

unsigned int nReserved[8] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_GENTL_DEV_INFO_LIST 结构体 参考 

> 结构体定义

通过 GenTL 枚举到的设备信息列表 更多 ... 

# 成员变量 

unsigned int nDeviceNum 

[OUT] 在线设备数量 更多 ... 

MV_GENTL_DEV_INFO * pDeviceInfo [MV_MAX_GENTL_DEV_NUM ]

[OUT] 支持最多 256 个设备 更多 ... 

# 详细描述 

通过 GenTL 枚举到的设备信息列表 结构体成员变量说明 

◆ nDeviceNum 

unsigned int nDeviceNum 

[OUT] 在线设备数量 

◆ pDeviceInfo 

MV_GENTL_DEV_INFO * pDeviceInfo[ MV_MAX_GENTL_DEV_NUM ]

[OUT] 支持最多 256 个设备 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CHUNK_DATA_CONTENT 结构体 参考 

> 结构体定义

Chunk 内容 更多 ... 成员变量 

unsigned char * pChunkData 

[OUT] Chunk 数据 更多 ... 

unsigned int nChunkID 

[OUT] Chunk ID 更多 ... 

unsigned int nChunkLen 

[OUT] Chunk 的长度 更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 

# 详细描述 

Chunk 内容 

示例 

ChunkData.cpp .

# 结构体成员变量说明 

◆ pChunkData 

unsigned char* pChunkData 

[OUT] Chunk 数据 

◆ nChunkID 

unsigned int nChunkID 

[OUT] Chunk ID 示例 

ChunkData.cpp .

◆ nChunkLen 

unsigned int nChunkLen 

[OUT] Chunk 的长度 

示例 

ChunkData.cpp .

◆ nReserved 

unsigned int nReserved[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_IMAGE 结构体 参考 

> 结构体定义

图像信息 更多 ... 

# 成员变量 

unsigned int nWidth 

图像宽 更多 ... 

unsigned int nHeight 

图像高 更多 ... 

enum MvGvspPixelType enPixelType 

像素格式 更多 ... 

unsigned char * pImageBuf 

图像缓存 更多 ... 

uint64_t nImageBufSize 

图像缓存大小 更多 ... 

uint64_t nImageLen 

图像长度 更多 ... 

unsigned int nReserved [4] 

预留字段 更多 ... 

# 详细描述 

图像信息 

示例 

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

# 结构体成员变量说明 ◆ nWidth 

unsigned int nWidth 

图像宽 

示例 

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ nHeight 

unsigned int nHeight 

图像高 

示例 

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType 

像素格式 

示例 

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ pImageBuf 

unsigned char* pImageBuf 

图像缓存 

示例 

GrabImage_Display.cpp , HighBandwidthDecode.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .◆ nImageBufSize 

uint64_t nImageBufSize 

图像缓存大小 

◆ nImageLen 

uint64_t nImageLen 

图像长度 

示例 

LensShadingCorrection.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ nReserved 

unsigned int nReserved[4] 

预留字段 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 成员变量 

# MV_FRAME_OUT_INFO_EX 结构体 参考 

> 结构体定义

输出帧的信息 更多 ... 

# 成员变量 

unsigned short nWidth 

[OUT] 图像宽 (最大 65535 ，超 出请用 nExtendWidth) 更多 ... 

unsigned short nHeight 

[OUT] 图像高 (最大 65535 ，超 出请用 nExtendHeight) 更多 ... 

enum MvGvspPixelType enPixelType 

[OUT] 像素格式 更多 ... 

unsigned int nFrameNum 

[OUT] 帧号 更多 ... 

unsigned int nDevTimeStampHigh 

[OUT] 时间戳高 32 位 更多 ... 

unsigned int nDevTimeStampLow 

[OUT] 时间戳低 32 位 更多 ... 

unsigned int nReserved0 

[OUT] 保留， 8字节对齐 更多 

... 

int64_t nHostTimeStamp 

[OUT] 主机生成的时间戳 更多 

... 

unsigned int nFrameLen [OUT] 帧的长度 (4GB 以上图像 使用 nFrameLenEx 替代 ) 更多 

... 

unsigned int nSecondCount 

[OUT] 设备水印时标：秒数 更多... 

unsigned int nCycleCount 

[OUT] 设备水印时标：周期数 

更多 ... 

unsigned int nCycleOffset 

[OUT] 设备水印时标：周期偏 移量 更多 ... 

float fGain 

[OUT] 增益 更多 ... 

float fExposureTime 

[OUT] 曝光时间 更多 ... 

unsigned int nAverageBrightness 

[OUT] 平均亮度 更多 ... 

unsigned int nRed 

[OUT] 白平衡相关：红色 更多 

... 

unsigned int nGreen 

[OUT] 白平衡相关：绿色 更多 

... 

unsigned int nBlue 

[OUT] 白平衡相关：蓝色 更多 

... 

unsigned int nFrameCounter 

[OUT] 总帧数 更多 ... unsigned int nTriggerIndex 

[OUT] 触发计数 更多 ... 

unsigned int nInput 

[OUT] 输入 更多 ... 

unsigned int nOutput 

[OUT] 输出 更多 ... 

unsigned short nOffsetX 

[OUT] ROI 区域水平偏移量 更多... 

unsigned short nOffsetY 

[OUT] ROI 区域垂直偏移量 更多... 

unsigned short nChunkWidth 

[OUT] ROI 区域 Chunk 宽 更多 

... 

unsigned short nChunkHeight 

[OUT] ROI 区域 Chunk 高 更多 

... 

unsigned int nLostPacket 

[OUT] 本帧丢包数 更多 ... 

unsigned int nUnparsedChunkNum 

[OUT] 未解析的 Chunkdata 个数 更多 ... 

union { 

MV_CHUNK_DATA_CONTENT * pUnparsedChunkContent 

[OUT] 未解析的 Chunk 更多 ... 

int64_t nAligning 

[OUT] 校准 更多 ... } UnparsedChunkList 

[OUT] 未解析的 Chunk 联合体 

更多 ... 

unsigned int nExtendWidth 

[OUT] 图像宽 (扩展变量 ) 更多 

... 

unsigned int nExtendHeight 

[OUT] 图像高 (扩展变量 ) 更多 

... 

uint64_t nFrameLenEx 

[OUT] 帧的长度 更多 ... 

unsigned int nReserved1 

[OUT] 保留，用于对齐 更多 ... 

unsigned int nSubImageNum 

[OUT] 图像缓存中的子图个数 

更多 ... 

union { 

MV_CC_IMAGE * pstSubImage 

[OUT] 子图信息 更多 ... 

int64_t nAligning 

[OUT] 校准 更多 ... 

} SubImageList 

[OUT] 图像缓存中的子图信息 联合体（子图指的是采集卡通 过分时频闪和图像拆分处理所 获得的图像片段）。 更多 ... 

union { 

void * pUser [OUT] 自定义指针 (外部注册缓 存时，内存地址对应的用户自 定义指针 ) 更多 ... 

int64_t nAligning 

[OUT] 校准 更多 ... 

} UserPtr 

[OUT] 外部注册缓存时，内存 地址对应的用户自定义指针联 合体 更多 ... 

unsigned int nReserved [26] 

预留 更多 ... 

# 详细描述 

输出帧的信息 

示例 

DynamicallyLoadDLL.cpp .

# 结构体成员变量说明 

◆ nWidth 

unsigned short nWidth 

[OUT] 图像宽 (最大 65535 ，超出请用 nExtendWidth) 

示例 

ConnectSpecCamera.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp ,

Events_Interface.cpp , Grab_ActionCommand.cpp , GrabImage.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , LensShadingCorrection.cpp , MultiCast.cpp , 以及 

Recording.cpp .◆ nHeight 

unsigned short nHeight 

[OUT] 图像高 (最大 65535 ，超出请用 nExtendHeight) 

示例 

ConnectSpecCamera.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp ,

Events_Interface.cpp , Grab_ActionCommand.cpp , GrabImage.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , LensShadingCorrection.cpp , MultiCast.cpp , 以及 

Recording.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[OUT] 像素格式 

示例 

ConvertPixelType.cpp , GrabImage_Display.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nFrameNum 

unsigned int nFrameNum 

[OUT] 帧号 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events_Interface.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ nDevTimeStampHigh 

unsigned int nDevTimeStampHigh 

[OUT] 时间戳高 32 位

◆ nDevTimeStampLow 

unsigned int nDevTimeStampLow 

[OUT] 时间戳低 32 位

◆ nReserved0 

unsigned int nReserved0 

[OUT] 保留， 8字节对齐 

◆ nHostTimeStamp 

int64_t nHostTimeStamp 

[OUT] 主机生成的时间戳 

◆ nFrameLen 

unsigned int nFrameLen 

[OUT] 帧的长度 (4GB 以上图像使用 nFrameLenEx 替代 )

示例 

ConvertPixelType.cpp , ImageContrast.cpp , ImageSave.cpp , 以及 Recording.cpp .

◆ nSecondCount unsigned int nSecondCount 

[OUT] 设备水印时标：秒数 

示例 

ChunkData.cpp .

◆ nCycleCount 

unsigned int nCycleCount 

[OUT] 设备水印时标：周期数 

示例 

ChunkData.cpp .

◆ nCycleOffset 

unsigned int nCycleOffset 

[OUT] 设备水印时标：周期偏移量 

示例 

ChunkData.cpp .

◆ fGain 

float fGain 

[OUT] 增益 

◆ fExposureTime 

float fExposureTime 

[OUT] 曝光时间 

示例 

ChunkData.cpp .◆ nAverageBrightness 

unsigned int nAverageBrightness 

[OUT] 平均亮度 

◆ nRed 

unsigned int nRed 

[OUT] 白平衡相关：红色 

◆ nGreen 

unsigned int nGreen 

[OUT] 白平衡相关：绿色 

◆ nBlue 

unsigned int nBlue 

[OUT] 白平衡相关：蓝色 

◆ nFrameCounter 

unsigned int nFrameCounter 

[OUT] 总帧数 

◆ nTriggerIndex 

unsigned int nTriggerIndex 

[OUT] 触发计数 ◆ nInput 

unsigned int nInput 

[OUT] 输入 

◆ nOutput 

unsigned int nOutput 

[OUT] 输出 

◆ nOffsetX 

unsigned short nOffsetX 

[OUT] ROI 区域水平偏移量 

◆ nOffsetY 

unsigned short nOffsetY 

[OUT] ROI 区域垂直偏移量 

◆ nChunkWidth 

unsigned short nChunkWidth 

[OUT] ROI 区域 Chunk 宽

◆ nChunkHeight 

unsigned short nChunkHeight 

[OUT] ROI 区域 Chunk 高◆ nLostPacket 

unsigned int nLostPacket 

[OUT] 本帧丢包数 

◆ nUnparsedChunkNum 

unsigned int nUnparsedChunkNum 

[OUT] 未解析的 Chunkdata 个数 

示例 

ChunkData.cpp .

◆ pUnparsedChunkContent 

MV_CHUNK_DATA_CONTENT * pUnparsedChunkContent 

[OUT] 未解析的 Chunk 

示例 

ChunkData.cpp .

◆ nAligning 

int64_t nAligning 

[OUT] 校准 

◆ UnparsedChunkList 

union { ... } UnparsedChunkList 

[OUT] 未解析的 Chunk 联合体 

示例 

ChunkData.cpp .◆ nExtendWidth 

unsigned int nExtendWidth 

[OUT] 图像宽 (扩展变量 )

示例 

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage_Display.cpp ,

InterfaceAndDeviceDemo.cpp , LineScanSoftwareTrigger.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ nExtendHeight 

unsigned int nExtendHeight 

[OUT] 图像高 (扩展变量 )

示例 

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage_Display.cpp ,

InterfaceAndDeviceDemo.cpp , LineScanSoftwareTrigger.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 QuickSoftwareTrigger.cpp .

◆ nFrameLenEx 

uint64_t nFrameLenEx 

[OUT] 帧的长度 

示例 

Grab_Asynchronous.cpp , GrabImage_Display.cpp , HighBandwidthDecode.cpp ,

ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nReserved1 unsigned int nReserved1 

[OUT] 保留，用于对齐 

◆ nSubImageNum 

unsigned int nSubImageNum 

[OUT] 图像缓存中的子图个数 

◆ pstSubImage 

MV_CC_IMAGE * pstSubImage 

[OUT] 子图信息 

◆ SubImageList 

union { ... } SubImageList 

[OUT] 图像缓存中的子图信息联合体（子图指的是采集卡通过分时频闪和图像拆分处理所获得 的图像片段）。 

◆ pUser 

void* pUser 

[OUT] 自定义指针 (外部注册缓存时，内存地址对应的用户自定义指针 )

◆ UserPtr 

union { ... } UserPtr 

[OUT] 外部注册缓存时，内存地址对应的用户自定义指针联合体 

◆ nReserved unsigned int nReserved[26] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_FRAME_OUT 结构体 参考 

> 结构体定义

图像结构体，输出图像地址及图像信息 更多 ... 

# 成员变量 

unsigned char * pBufAddr 

[OUT] 图像指针地址 更多 ... 

MV_FRAME_OUT_INFO_EX stFrameInfo 

[OUT] 图像信息 更多 ... 

unsigned int nRes [16] 

预留 更多 ... 详细描述 

图像结构体，输出图像地址及图像信息 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events_Interface.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp , ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

# 结构体成员变量说明 

◆ pBufAddr 

unsigned char* pBufAddr 

[OUT] 图像指针地址 

示例 

ConvertPixelType.cpp , Grab_Asynchronous.cpp , GrabImage_Display.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , MultiLightCtrl_ImageStitching.cpp , 以及 

Recording.cpp .

◆ stFrameInfo 

MV_FRAME_OUT_INFO_EX stFrameInfo 

[OUT] 图像信息 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events_Interface.cpp , Grab_ActionCommand.cpp ,Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ nRes 

unsigned int nRes[16] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_NETTRANS_INFO 结构体 参考 

> 结构体定义

网络传输的相关信息 更多 ... 成员变量 

int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 StartGrabbing 和StopGrabbing 之间的数据量 ] 更多 ... 

int nThrowFrameCount 

[OUT] 丢帧数量 更多 ... 

unsigned int nNetRecvFrameCount 

[OUT] 已接收的帧数 更多 ... 

int64_t nRequestResendPacketCount 

[OUT] 请求重发包数 更多 ... 

int64_t nResendPacketCount 

[OUT] 重发包数 更多 ... 

# 详细描述 

网络传输的相关信息 

示例 

DynamicallyLoadDLL.cpp .

# 结构体成员变量说明 

◆ nReceiveDataSize 

int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 StartGrabbing 和StopGrabbing 之间的数据量 ]

◆ nThrowFrameCount int nThrowFrameCount 

[OUT] 丢帧数量 

◆ nNetRecvFrameCount 

unsigned int nNetRecvFrameCount 

[OUT] 已接收的帧数 

◆ nRequestResendPacketCount 

int64_t nRequestResendPacketCount 

[OUT] 请求重发包数 

◆ nResendPacketCount 

int64_t nResendPacketCount 

[OUT] 重发包数 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> 成员变量

# MV_ALL_MATCH_INFO 结构体 参考 

> 结构体定义

全匹配的一种信息结构体 更多 ... 

# 成员变量 

unsigned int nType 

[IN] 需要输出的信息类型， e.g. MV_MATCH_TYPE_NET_DETECT 更多 ... 

void * pInfo 

[OUT] 输出的信息缓存，由调用者分配 更多 ... 

unsigned int nInfoSize 

[IN] 信息缓存的大小 更多 ... 

# 详细描述 

全匹配的一种信息结构体 

示例 

DynamicallyLoadDLL.cpp .

# 结构体成员变量说明 

◆ nType 

unsigned int nType 

[IN] 需要输出的信息类型， e.g. MV_MATCH_TYPE_NET_DETECT ◆ pInfo 

void* pInfo 

[OUT] 输出的信息缓存，由调用者分配 

◆ nInfoSize 

unsigned int nInfoSize 

[IN] 信息缓存的大小 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_MATCH_INFO_NET_DETECT 结构体 参考 

> 结构体定义

网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT 更多 ... 

# 成员变量 int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 StartGrabbing 和StopGrabbing 之间的数据量 ] 更多 ... 

int64_t nLostPacketCount 

[OUT] 丢失的包数量 更多 ... 

unsigned int nLostFrameCount 

[OUT] 丢帧数量 更多 ... 

unsigned int nNetRecvFrameCount 

[OUT] 接收到的图像帧数 更多 ... 

int64_t nRequestResendPacketCount 

[OUT] 请求重发包数 更多 ... 

int64_t nResendPacketCount 

[OUT] 重发包数 更多 ... 

# 详细描述 

网络流量和丢包信息反馈结构体，对应类型为 MV_MATCH_TYPE_NET_DETECT 

# 结构体成员变量说明 

◆ nReceiveDataSize 

int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 StartGrabbing 和StopGrabbing 之间的数据量 ]

◆ nLostPacketCount 

int64_t nLostPacketCount 

[OUT] 丢失的包数量 ◆ nLostFrameCount 

unsigned int nLostFrameCount 

[OUT] 丢帧数量 

◆ nNetRecvFrameCount 

unsigned int nNetRecvFrameCount 

[OUT] 接收到的图像帧数 

◆ nRequestResendPacketCount 

int64_t nRequestResendPacketCount 

[OUT] 请求重发包数 

◆ nResendPacketCount 

int64_t nResendPacketCount 

[OUT] 重发包数 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_MATCH_INFO_USB_DETECT 结构体 参考 

> 结构体定义

host 收到从 u3v 设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT 更多 ... 

# 成员变量 

int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 OpenDevicce 和CloseDevice 之间的数据量 ] 更多 ... 

unsigned int nReceivedFrameCount 

[OUT] 已收到的帧数 更多 ... 

unsigned int nErrorFrameCount 

[OUT] 错误帧数 更多 ... 

unsigned int nReserved [2] 

保留 更多 ... 

# 详细描述 

host 收到从 u3v 设备端的总字节数，对应类型为 MV_MATCH_TYPE_USB_DETECT 

# 结构体成员变量说明 

◆ nReceiveDataSize 

int64_t nReceiveDataSize 

[OUT] 已接收数据大小 [统计 OpenDevicce 和CloseDevice 之间的数据量 ]◆ nReceivedFrameCount 

unsigned int nReceivedFrameCount 

[OUT] 已收到的帧数 

◆ nErrorFrameCount 

unsigned int nErrorFrameCount 

[OUT] 错误帧数 

◆ nReserved 

unsigned int nReserved[2] 

保留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_DISPLAY_FRAME_INFO_EX 结构体 参考 结构体定义 

显示帧信息（适用于例如线阵相机等宽高大于 65535 的设备） 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽 更多 ... 

unsigned int nHeight 

[IN] 图像高 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pImageBuf 

[IN] 输入图像缓存 更多 ... 

unsigned int nImageBufLen 

[IN] 输入图像长度 更多 ... 

unsigned int enRenderMode 

[IN] 图像渲染方式。 0表示 GDI 模式， 1表示 D3D 模式， 2表示 OpenGL 

模式 更多 ... 

unsigned int nRes [3] 

保留 更多 ... 

# 详细描述 

显示帧信息（适用于例如线阵相机等宽高大于 65535 的设备） 

# 结构体成员变量说明 ◆ nWidth 

unsigned int nWidth 

[IN] 图像宽 

◆ nHeight 

unsigned int nHeight 

[IN] 图像高 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ pImageBuf 

unsigned char* pImageBuf 

[IN] 输入图像缓存 

◆ nImageBufLen 

unsigned int nImageBufLen 

[IN] 输入图像长度 

◆ enRenderMode 

unsigned int enRenderMode 

[IN] 图像渲染方式。 0表示 GDI 模式， 1表示 D3D 模式， 2表示 OpenGL 模式 ◆ nRes 

unsigned int nRes[3] 

保留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_ROTATE_IMAGE_PARAM 结构体 参考 

> 结构体定义

图像旋转结构体 更多 ... 

# 成员变量 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned int nWidth 

[IN][OUT] 图像宽 更多 ... 

unsigned int nHeight [IN][OUT] 图像高 更多 ... 

unsigned char * pSrcData 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcDataLen 

[IN] 输入数据长度 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

MV_IMG_ROTATION_ANGLE enRotationAngle 

[IN] 旋转角度 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

图像旋转结构体 

# 结构体成员变量说明 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 ◆ nWidth 

unsigned int nWidth 

[IN][OUT] 图像宽 

◆ nHeight 

unsigned int nHeight 

[IN][OUT] 图像高 

◆ pSrcData 

unsigned char* pSrcData 

[IN] 输入数据缓存 

◆ nSrcDataLen 

unsigned int nSrcDataLen 

[IN] 输入数据长度 

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 ◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 

◆ enRotationAngle 

MV_IMG_ROTATION_ANGLE enRotationAngle 

[IN] 旋转角度 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_FLIP_IMAGE_PARAM 结构体 参考 结构体定义 

图像翻转结构体 更多 ... 

# 成员变量 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned int nWidth 

[IN] 图像宽 更多 ... 

unsigned int nHeight 

[IN] 图像高 更多 ... 

unsigned char * pSrcData 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcDataLen 

[IN] 输入数据长度 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

MV_IMG_FLIP_TYPE enFlipType 

[IN] 翻转类型 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 详细描述 

图像翻转结构体 

# 结构体成员变量说明 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽 

◆ nHeight 

unsigned int nHeight 

[IN] 图像高 

◆ pSrcData 

unsigned char* pSrcData 

[IN] 输入数据缓存 

◆ nSrcDataLen 

unsigned int nSrcDataLen 

[IN] 输入数据长度 ◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 

◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 

◆ enFlipType 

MV_IMG_FLIP_TYPE enFlipType 

[IN] 翻转类型 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_CONTRAST_PARAM 结构体 参考 

> 结构体定义

对比度调节结构体 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽度（最小 8） 更多 ... 

unsigned int nHeight 

[IN] 图像高度（最小 8） 更多 ... 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据大小 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nContrastFactor 

[IN] 对比度值， [1, 10000] 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

对比度调节结构体 

示例 

ImageContrast.cpp .

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽度（最小 8）

示例 

ImageContrast.cpp .

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度（最小 8）

示例 

ImageContrast.cpp .◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

示例 

ImageContrast.cpp .

◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据大小 

示例 

ImageContrast.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

示例 

ImageContrast.cpp .

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

示例 

ImageContrast.cpp .

◆ nDstBufSize 

unsigned int nDstBufSize [IN] 提供的输出缓冲区大小 

示例 

ImageContrast.cpp .

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 

◆ nContrastFactor 

unsigned int nContrastFactor 

[IN] 对比度值， [1, 10000] 

示例 

ImageContrast.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_GAMMA_PARAM 结构体 参考 

> 结构体定义

Gamma 信息结构体 更多 ... 

# 成员变量 

MV_CC_GAMMA_TYPE enGammaType 

[IN] Gamma 类型 更多 ... 

float fGammaValue 

[IN] Gamma 值[0.1, 4.0] 更多 ... 

unsigned char * pGammaCurveBuf 

[IN] Gamma 曲线缓存 更多 ... 

unsigned int nGammaCurveBufLen 

[IN] Gamma 曲线长度 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

Gamma 信息结构体 

# 结构体成员变量说明 ◆ enGammaType 

MV_CC_GAMMA_TYPE enGammaType 

[IN] Gamma 类型 

◆ fGammaValue 

float fGammaValue 

[IN] Gamma 值[0.1, 4.0] 

◆ pGammaCurveBuf 

unsigned char* pGammaCurveBuf 

[IN] Gamma 曲线缓存 

◆ nGammaCurveBufLen 

unsigned int nGammaCurveBufLen 

[IN] Gamma 曲线长度 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_CCM_PARAM 结构体 参考 

> 结构体定义

CCM 参数 更多 ... 

# 成员变量 

bool bCCMEnable 

[IN] 是否启用 CCM 更多 ... 

int nCCMat [9] 

[IN] CCM 矩阵 [-8192~8192] 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

CCM 参数 

# 结构体成员变量说明 

◆ bCCMEnable bool bCCMEnable 

[IN] 是否启用 CCM 

◆ nCCMat 

int nCCMat[9] 

[IN] CCM 矩阵 [-8192~8192] 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_CCM_PARAM_EX 结构体 参考 

> 结构体定义

CCM 参数（适用于例如线阵相机等宽高大于 65535 的设备） 更多 ... 

# 成员变量 

bool bCCMEnable 

[IN] 是否启用 CCM 更多 ... 

int nCCMat [9] 

[IN] CCM 矩阵 [-65536~65536] 更多 ... 

unsigned int nCCMScale 

[IN] 量化系数（ 2的整数幂，最大 65536 ） 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

CCM 参数（适用于例如线阵相机等宽高大于 65535 的设备） 

# 结构体成员变量说明 

◆ bCCMEnable 

bool bCCMEnable 

[IN] 是否启用 CCM 

◆ nCCMat 

int nCCMat[9] 

[IN] CCM 矩阵 [-65536~65536] ◆ nCCMScale 

unsigned int nCCMScale 

[IN] 量化系数（ 2的整数幂，最大 65536 ）

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_SHARPEN_PARAM 结构体 参考 

> 结构体定义

锐化结构体 更多 ... 

# 成员变量 unsigned int nWidth 

[IN] 图像宽度（最小 8） 更多 ... 

unsigned int nHeight 

[IN] 图像高度（最小 8） 更多 ... 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据大小 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nSharpenAmount 

[IN] 锐度调节强度 [0,500] 更多 ... 

unsigned int nSharpenRadius 

[IN] 锐度调节半径 [1,21] （半径越大，耗时越长） 更多 ... 

unsigned int nSharpenThreshold 

[IN] 锐度调节阈值 [0,255] 更多 ... 

unsigned int nSharpenPosAmount 

[IN] 锐度调节正向强度，范围 :[0,500] 更多 ... 

unsigned int nSharpenNegAmount 

[IN] 锐度调节负向强度，范围 :[0,500] 更多 ... unsigned int nRes [6] 

预留 更多 ... 

# 详细描述 

锐化结构体 

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽度（最小 8）

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度（最小 8）

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据大小 ◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 

◆ nSharpenAmount 

unsigned int nSharpenAmount 

[IN] 锐度调节强度 [0,500] 

◆ nSharpenRadius 

unsigned int nSharpenRadius 

[IN] 锐度调节半径 [1,21] （半径越大，耗时越长） ◆ nSharpenThreshold 

unsigned int nSharpenThreshold 

[IN] 锐度调节阈值 [0,255] 

◆ nSharpenPosAmount 

unsigned int nSharpenPosAmount 

[IN] 锐度调节正向强度，范围 :[0,500] 

◆ nSharpenNegAmount 

unsigned int nSharpenNegAmount 

[IN] 锐度调节负向强度，范围 :[0,500] 

◆ nRes 

unsigned int nRes[6] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_CC_RECT_I 结构体 参考 

> 结构体定义

矩形 ROI 结构体 更多 ... 

# 成员变量 

unsigned int nX 

矩形左上角 X轴坐标 更多 ... 

unsigned int nY 

矩形左上角 Y轴坐标 更多 ... 

unsigned int nWidth 

矩形宽度 更多 ... 

unsigned int nHeight 

矩形高度 更多 ... 

# 详细描述 

矩形 ROI 结构体 

# 结构体成员变量说明 

◆ nX 

unsigned int nX 

矩形左上角 X轴坐标 ◆ nY 

unsigned int nY 

矩形左上角 Y轴坐标 

◆ nWidth 

unsigned int nWidth 

矩形宽度 

◆ nHeight 

unsigned int nHeight 

矩形高度 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_NOISE_ESTIMATE_PARAM 结构体 参考 结构体定义 

噪声估计结构体 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽度 更多 ... 

unsigned int nHeight 

[IN] 图像高度 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据大小 更多 ... 

MV_CC_RECT_I * pstROIRect 

[IN] 图像 ROI 更多 ... 

unsigned int nROINum 

[IN] ROI 个数 更多 ... 

unsigned int nNoiseThreshold 

[IN] 噪声阈值 [0,4095] 更多 ... 

unsigned char * pNoiseProfile 

[OUT] 输出噪声特性 更多 ... 

unsigned int nNoiseProfileSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nNoiseProfileLen 

[OUT] 输出噪声特性长度 更多 ... unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

噪声估计结构体 

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽度 

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 ◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据大小 

◆ pstROIRect 

MV_CC_RECT_I * pstROIRect 

[IN] 图像 ROI 

◆ nROINum 

unsigned int nROINum 

[IN] ROI 个数 

◆ nNoiseThreshold 

unsigned int nNoiseThreshold 

[IN] 噪声阈值 [0,4095] 

◆ pNoiseProfile 

unsigned char* pNoiseProfile 

[OUT] 输出噪声特性 

◆ nNoiseProfileSize 

unsigned int nNoiseProfileSize 

[IN] 提供的输出缓冲区大小 ◆ nNoiseProfileLen 

unsigned int nNoiseProfileLen 

[OUT] 输出噪声特性长度 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_LSC_CALIB_PARAM 结构体 参考 

> 结构体定义

LSC 标定结构体 更多 ... 

# 成员变量 unsigned int nWidth 

[IN] 图像宽度（ 16-65535 ） 更多 ... 

unsigned int nHeight 

[IN] 图像高度（ 16-65535 ） 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据长度 更多 ... 

unsigned char * pCalibBuf 

[OUT] 输出标定表缓存 更多 ... 

unsigned int nCalibBufSize 

[IN] 提供的标定表缓冲大小 (nWidth*nHeight*sizeof(unsigned short)) 

更多 ... 

unsigned int nCalibBufLen 

[OUT] 输出标定表缓存长度 更多 ... 

unsigned int nSecNumW 

[IN] 宽度分块数 更多 ... 

unsigned int nSecNumH 

[IN] 高度分块数 更多 ... 

unsigned int nPadCoef 

[IN] 边缘填充系数 [1-5] 更多 ... 

unsigned int nCalibMethod 

[IN] 标定方式（ 0-中心为基准； 1-最亮区域为基准； 2-目标亮度） 更多... 

unsigned int nTargetGray [IN] 目标亮度（标定方式为 2时有效） 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

LSC 标定结构体 

示例 

LensShadingCorrection.cpp .

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽度（ 16-65535 ）

示例 

LensShadingCorrection.cpp .

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度（ 16-65535 ）

示例 

LensShadingCorrection.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType [IN] 像素格式 

示例 

LensShadingCorrection.cpp .

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

示例 

LensShadingCorrection.cpp .

◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据长度 

示例 

LensShadingCorrection.cpp .

◆ pCalibBuf 

unsigned char* pCalibBuf 

[OUT] 输出标定表缓存 

示例 

LensShadingCorrection.cpp .

◆ nCalibBufSize 

unsigned int nCalibBufSize 

[IN] 提供的标定表缓冲大小 (nWidth*nHeight*sizeof(unsigned short)) 

示例 LensShadingCorrection.cpp .

◆ nCalibBufLen 

unsigned int nCalibBufLen 

[OUT] 输出标定表缓存长度 

示例 

LensShadingCorrection.cpp .

◆ nSecNumW 

unsigned int nSecNumW 

[IN] 宽度分块数 

示例 

LensShadingCorrection.cpp .

◆ nSecNumH 

unsigned int nSecNumH 

[IN] 高度分块数 

示例 

LensShadingCorrection.cpp .

◆ nPadCoef 

unsigned int nPadCoef 

[IN] 边缘填充系数 [1-5] 

示例 

LensShadingCorrection.cpp .◆ nCalibMethod 

unsigned int nCalibMethod 

[IN] 标定方式（ 0-中心为基准； 1-最亮区域为基准； 2-目标亮度） 

示例 

LensShadingCorrection.cpp .

◆ nTargetGray 

unsigned int nTargetGray 

[IN] 目标亮度（标定方式为 2时有效） 

￿ 8位，范围： [0,255] 

￿ 10 位，范围： [0,1023] 

￿ 12 位，范围： [0,4095] 

￿ 16 位，范围： [0,65535] 

示例 

LensShadingCorrection.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_LSC_CORRECT_PARAM 结构体 参考 

> 结构体定义

LSC 校正结构体 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽度 (16-65535) 更多 ... 

unsigned int nHeight 

[IN] 图像高度 (16-65535) 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据长度 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... unsigned char * pCalibBuf 

[IN] 输入标定表缓存 更多 ... 

unsigned int nCalibBufLen 

[IN] 输入标定表缓存长度 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

LSC 校正结构体 

示例 

LensShadingCorrection.cpp .

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽度 (16-65535) 

示例 

LensShadingCorrection.cpp .

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度 (16-65535) 

示例 

LensShadingCorrection.cpp .◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

示例 

LensShadingCorrection.cpp .

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

示例 

LensShadingCorrection.cpp .

◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据长度 

示例 

LensShadingCorrection.cpp .

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

示例 

LensShadingCorrection.cpp .

◆ nDstBufSize 

unsigned int nDstBufSize [IN] 提供的输出缓冲区大小 

示例 

LensShadingCorrection.cpp .

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 

◆ pCalibBuf 

unsigned char* pCalibBuf 

[IN] 输入标定表缓存 

示例 

LensShadingCorrection.cpp .

◆ nCalibBufLen 

unsigned int nCalibBufLen 

[IN] 输入标定表缓存长度 

示例 

LensShadingCorrection.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_FRAME_SPEC_INFO 结构体 参考 

> 结构体定义

水印信息 更多 ... 

# 成员变量 

unsigned int nSecondCount 

[OUT] 秒数 更多 ... 

unsigned int nCycleCount 

[OUT] 周期数 更多 ... 

unsigned int nCycleOffset 

[OUT] 周期偏移量 更多 ... 

float fGain 

[OUT] 增益 更多 ... 

float fExposureTime 

[OUT] 曝光时间 更多 ... unsigned int nAverageBrightness 

[OUT] 平均亮度 更多 ... 

unsigned int nRed 

[OUT] 红色 更多 ... 

unsigned int nGreen 

[OUT] 绿色 更多 ... 

unsigned int nBlue 

[OUT] 蓝色 更多 ... 

unsigned int nFrameCounter 

[OUT] 总帧数 更多 ... 

unsigned int nTriggerIndex 

[OUT] 触发计数 更多 ... 

unsigned int nInput 

[OUT] 输入 更多 ... 

unsigned int nOutput 

[OUT] 输出 更多 ... 

unsigned short nOffsetX 

[OUT] 水平偏移量 更多 ... 

unsigned short nOffsetY 

[OUT] 垂直偏移量 更多 ... 

unsigned short nFrameWidth 

[OUT] 水印宽 更多 ... 

unsigned short nFrameHeight 

[OUT] 水印高 更多 ... 

unsigned int nReserved [16] 

预留 更多 ... 详细描述 

水印信息 

# 结构体成员变量说明 

◆ nSecondCount 

unsigned int nSecondCount 

[OUT] 秒数 

◆ nCycleCount 

unsigned int nCycleCount 

[OUT] 周期数 

◆ nCycleOffset 

unsigned int nCycleOffset 

[OUT] 周期偏移量 

◆ fGain 

float fGain 

[OUT] 增益 

◆ fExposureTime 

float fExposureTime [OUT] 曝光时间 

◆ nAverageBrightness 

unsigned int nAverageBrightness 

[OUT] 平均亮度 

◆ nRed 

unsigned int nRed 

[OUT] 红色 

◆ nGreen 

unsigned int nGreen 

[OUT] 绿色 

◆ nBlue 

unsigned int nBlue 

[OUT] 蓝色 

◆ nFrameCounter 

unsigned int nFrameCounter 

[OUT] 总帧数 

◆ nTriggerIndex 

unsigned int nTriggerIndex 

[OUT] 触发计数 ◆ nInput 

unsigned int nInput 

[OUT] 输入 

◆ nOutput 

unsigned int nOutput 

[OUT] 输出 

◆ nOffsetX 

unsigned short nOffsetX 

[OUT] 水平偏移量 

◆ nOffsetY 

unsigned short nOffsetY 

[OUT] 垂直偏移量 

◆ nFrameWidth 

unsigned short nFrameWidth 

[OUT] 水印宽 

◆ nFrameHeight 

unsigned short nFrameHeight 

[OUT] 水印高 ◆ nReserved 

unsigned int nReserved[16] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_PURPLE_FRINGING_PARAM 结构体 参考 

> 结构体定义

去紫边结构体 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽度 (最小 4) 更多 ... 

unsigned int nHeight 

[IN] 图像高度 (最小 4) 更多 ... 

unsigned char * pSrcBuf [IN] 输入数据缓存 更多 ... 

unsigned int nSrcBufLen 

[IN] 输入数据大小 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nKernelSize 

[IN] 滤波核尺寸 ,仅支持 3,5,7,9 更多 ... 

unsigned int nEdgeThreshold 

[IN] 边缘阈值 [0,2040] 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

去紫边结构体 

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth [IN] 图像宽度 (最小 4) 

◆ nHeight 

unsigned int nHeight 

[IN] 图像高度 (最小 4) 

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

◆ nSrcBufLen 

unsigned int nSrcBufLen 

[IN] 输入数据大小 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 ◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据长度 

◆ nKernelSize 

unsigned int nKernelSize 

[IN] 滤波核尺寸 ,仅支持 3,5,7,9 

◆ nEdgeThreshold 

unsigned int nEdgeThreshold 

[IN] 边缘阈值 [0,2040] 

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_CC_ISP_CONFIG_PARAM 结构体 参考 

> 结构体定义

ISP 配置结构体 更多 ... 

# 成员变量 

char * pcConfigPath 

[IN] 配置文件路径 更多 ... 

unsigned int nRes [16] 

预留 更多 ... 

# 详细描述 

ISP 配置结构体 

# 结构体成员变量说明 

◆ pcConfigPath 

char* pcConfigPath 

[IN] 配置文件路径 

◆ nRes 

unsigned int nRes[16] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_HB_DECODE_PARAM 结构体 参考 

> 结构体定义

无损解码参数 更多 ... 

# 成员变量 

unsigned char * pSrcBuf 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcLen 

[IN] 输入数据大小 更多 ... 

unsigned int nWidth 

[OUT] 图像宽 更多 ... 

unsigned int nHeight 

[OUT] 图像高 更多 ... 

unsigned char * pDstBuf [OUT] 输出数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出数据大小 更多 ... 

enum MvGvspPixelType enDstPixelType 

[OUT] 输出的像素格式 更多 ... 

MV_CC_FRAME_SPEC_INFO stFrameSpecInfo 

[OUT] 水印信息 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

无损解码参数 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

# 结构体成员变量说明 

◆ pSrcBuf 

unsigned char* pSrcBuf 

[IN] 输入数据缓存 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .◆ nSrcLen 

unsigned int nSrcLen 

[IN] 输入数据大小 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nWidth 

unsigned int nWidth 

[OUT] 图像宽 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nHeight 

unsigned int nHeight 

[OUT] 图像高 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出数据缓存 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出数据大小 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ enDstPixelType 

enum MvGvspPixelType enDstPixelType 

[OUT] 输出的像素格式 

示例 

HighBandwidthDecode.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ stFrameSpecInfo 

MV_CC_FRAME_SPEC_INFO stFrameSpecInfo 

[OUT] 水印信息 

◆ nRes 

unsigned int nRes[8] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_RECORD_PARAM 结构体 参考 

> 结构体定义

录像参数 更多 ... 

# 成员变量 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 更多 ... 

unsigned short nWidth 

[IN] 图像宽（指定目标参数时需为 2的倍数） 更多 ... 

unsigned short nHeight 

[IN] 图像高（指定目标参数时需为 2的倍数） 更多 ... 

float fFrameRate [IN] 帧率 fps( 大于 1/16) 更多 ... 

unsigned int nBitRate 

[IN] 码率 kbps(128-16*1024) 更多 ... 

MV_RECORD_FORMAT_TYPE enRecordFmtType 

[IN] 录像格式 更多 ... 

char * strFilePath 

[IN] 录像文件存放路径（如果路径中存在中文，需转成 utf-8 ）

更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

录像参数 

示例 

DynamicallyLoadDLL.cpp , 以及 Recording.cpp .

# 结构体成员变量说明 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 

示例 

Recording.cpp .

◆ nWidth unsigned short nWidth 

[IN] 图像宽（指定目标参数时需为 2的倍数） 

示例 

Recording.cpp .

◆ nHeight 

unsigned short nHeight 

[IN] 图像高（指定目标参数时需为 2的倍数） 

示例 

Recording.cpp .

◆ fFrameRate 

float fFrameRate 

[IN] 帧率 fps( 大于 1/16) 

示例 

Recording.cpp .

◆ nBitRate 

unsigned int nBitRate 

[IN] 码率 kbps(128-16*1024) 

示例 

Recording.cpp .

◆ enRecordFmtType 

MV_RECORD_FORMAT_TYPE enRecordFmtType 

[IN] 录像格式 示例 

Recording.cpp .

◆ strFilePath 

char* strFilePath 

[IN] 录像文件存放路径（如果路径中存在中文，需转成 utf-8 ）

示例 

Recording.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_INPUT_FRAME_INFO 结构体 参考 

> 结构体定义

传入的图像数据 更多 ... 

# 成员变量 

unsigned char * pData 

[IN] 图像数据指针 更多 ... 

unsigned int nDataLen 

[IN] 图像大小 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

传入的图像数据 

示例 

DynamicallyLoadDLL.cpp , 以及 Recording.cpp .

# 结构体成员变量说明 

◆ pData 

unsigned char* pData 

[IN] 图像数据指针 

示例 

Recording.cpp .

◆ nDataLen 

unsigned int nDataLen [IN] 图像大小 

示例 

Recording.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_STREAM_EXCEPTION_INFO 结构体 参考 

> 结构体定义

流异常回调信息 更多 ... 

# 成员变量 

char chSerialNumber [INFO_MAX_BUFFER_SIZE ][OUT] 设备序列号 更多 ... 

unsigned int nStreamIndex 

[OUT] 流通道序号 更多 ... 

MV_CC_STREAM_EXCEPTION_TYPE enExceptionType 

[OUT] 流异常类型 更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 

# 详细描述 

流异常回调信息 

# 结构体成员变量说明 

◆ chSerialNumber 

char chSerialNumber[ INFO_MAX_BUFFER_SIZE ]

[OUT] 设备序列号 

◆ nStreamIndex 

unsigned int nStreamIndex 

[OUT] 流通道序号 

◆ enExceptionType 

MV_CC_STREAM_EXCEPTION_TYPE enExceptionType 

[OUT] 流异常类型 ◆ nReserved 

unsigned int nReserved[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_EVENT_OUT_INFO 结构体 参考 

> 结构体定义

Event 事件回调信息 更多 ... 

# 成员变量 

char EventName [MAX_EVENT_NAME_SIZE ]

[OUT] Event 名称 更多 ... 

unsigned short nEventID 

[OUT] Event 号 更多 ... 

unsigned short nStreamChannel [OUT] 流通道序号 更多 ... 

unsigned int nBlockIdHigh 

[OUT] 帧号高位 更多 ... 

unsigned int nBlockIdLow 

[OUT] 帧号低位 更多 ... 

unsigned int nTimestampHigh 

[OUT] 时间戳高位 更多 ... 

unsigned int nTimestampLow 

[OUT] 时间戳低位 更多 ... 

void * pEventData 

[OUT] Event 数据 更多 ... 

unsigned int nEventDataSize 

[OUT] Event 数据长度 更多 ... 

unsigned int nReserved [16] 

预留 更多 ... 

# 详细描述 

Event 事件回调信息 

示例 

ConfigLightController.cpp , DynamicallyLoadDLL.cpp , Events.cpp , 以及 

Events_Interface.cpp .

# 结构体成员变量说明 

◆ EventName char EventName[ MAX_EVENT_NAME_SIZE ]

[OUT] Event 名称 

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ nEventID 

unsigned short nEventID 

[OUT] Event 号

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ nStreamChannel 

unsigned short nStreamChannel 

[OUT] 流通道序号 

◆ nBlockIdHigh 

unsigned int nBlockIdHigh 

[OUT] 帧号高位 

示例 

Events.cpp .

◆ nBlockIdLow 

unsigned int nBlockIdLow 

[OUT] 帧号低位 

示例 

Events.cpp .◆ nTimestampHigh 

unsigned int nTimestampHigh 

[OUT] 时间戳高位 

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ nTimestampLow 

unsigned int nTimestampLow 

[OUT] 时间戳低位 

示例 

ConfigLightController.cpp , Events.cpp , 以及 Events_Interface.cpp .

◆ pEventData 

void* pEventData 

[OUT] Event 数据 

◆ nEventDataSize 

unsigned int nEventDataSize 

[OUT] Event 数据长度 

◆ nReserved 

unsigned int nReserved[16] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_FILE_ACCESS 结构体 参考 

> 结构体定义

文件存取 更多 ... 

# 成员变量 

const char * pUserFileName 

[IN] 用户文件名 更多 ... 

const char * pDevFileName 

[IN] 设备文件名 更多 ... 

unsigned int nReserved [32] 

预留 更多 ... 

# 详细描述 

文件存取 示例 

DynamicallyLoadDLL.cpp , 以及 ParametrizeCamera_FileAccess.cpp .

# 结构体成员变量说明 

◆ pUserFileName 

const char* pUserFileName 

[IN] 用户文件名 

示例 

ParametrizeCamera_FileAccess.cpp .

◆ pDevFileName 

const char* pDevFileName 

[IN] 设备文件名 

示例 

ParametrizeCamera_FileAccess.cpp .

◆ nReserved 

unsigned int nReserved[32] 

预留 

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_FILE_ACCESS_EX 结构体 参考 

> 结构体定义

文件存取 更多 ... 

# 成员变量 

char * pUserFileBuf 

[IN] 用户数据缓存 更多 ... 

unsigned int pFileBufSize 

[IN] 用户数据缓存大小 更多 ... 

unsigned int pFileBufLen 

[OUT][IN] 文件数据缓存总长度 (读取时输出文件数据总长度，写入时输入文件数据 总长度 ) 更多 ... 

const char * pDevFileName 

[IN] 设备文件名 更多 ... 

unsigned int nReserved [32] 

预留 更多 ... 

# 详细描述 

文件存取 结构体成员变量说明 

◆ pUserFileBuf 

char* pUserFileBuf 

[IN] 用户数据缓存 

◆ pFileBufSize 

unsigned int pFileBufSize 

[IN] 用户数据缓存大小 

◆ pFileBufLen 

unsigned int pFileBufLen 

[OUT][IN] 文件数据缓存总长度 (读取时输出文件数据总长度，写入时输入文件数据总长度 )

◆ pDevFileName 

const char* pDevFileName 

[IN] 设备文件名 

◆ nReserved 

unsigned int nReserved[32] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_FILE_ACCESS_PROGRESS 结构体 参考 

> 结构体定义

文件存取进度 更多 ... 

# 成员变量 

int64_t nCompleted 

[OUT] 已完成的长度 更多 ... 

int64_t nTotal 

[OUT] 总长度 更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 

# 详细描述 

文件存取进度 示例 

DynamicallyLoadDLL.cpp .

# 结构体成员变量说明 

◆ nCompleted 

int64_t nCompleted 

[OUT] 已完成的长度 

◆ nTotal 

int64_t nTotal 

[OUT] 总长度 

◆ nReserved 

unsigned int nReserved[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_TRANSMISSION_TYPE 结构体 参考 

> 结构体定义

网络传输模式 更多 ... 

# 成员变量 

MV_GIGE_TRANSMISSION_TYPE enTransmissionType 

[IN] 传输模式 更多 ... 

unsigned int nDestIp 

[IN] 目标 IP ，组播模式下有意义 更多 ... 

unsigned short nDestPort 

[IN] 目标 Port ，组播模式下有意义 更多 ... 

unsigned int nReserved [32] 

预留 更多 ... 

# 详细描述 

网络传输模式 

示例 

DynamicallyLoadDLL.cpp , 以及 MultiCast.cpp .

# 结构体成员变量说明 

◆ enTransmissionType MV_GIGE_TRANSMISSION_TYPE enTransmissionType 

[IN] 传输模式 

示例 

MultiCast.cpp .

◆ nDestIp 

unsigned int nDestIp 

[IN] 目标 IP ，组播模式下有意义 

示例 

MultiCast.cpp .

◆ nDestPort 

unsigned short nDestPort 

[IN] 目标 Port ，组播模式下有意义 

示例 

MultiCast.cpp .

◆ nReserved 

unsigned int nReserved[32] 

预留 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_ACTION_CMD_INFO 结构体 参考 

> 结构体定义

动作命令信息 更多 ... 

# 成员变量 

unsigned int nDeviceKey 

[IN] 设备密钥 更多 ... 

unsigned int nGroupKey 

[IN] 组键 更多 ... 

unsigned int nGroupMask 

[IN] 组掩码 更多 ... 

unsigned int bActionTimeEnable 

[IN] 只有设置成 1时Action Time 才有效，非 1时无效 更多 ... 

int64_t nActionTime 

[IN] 预定的时间，和主频有关 更多 ... 

const char * pBroadcastAddress 

[IN] 广播包地址 更多 ... 

unsigned int nTimeOut 

[IN] 等待 ACK 的超时时间，如果为 0表示不需要 ACK 更多 ... unsigned int bSpecialNetEnable 

[IN] 只有设置成 1时指定的网卡 IP 才有效，非 1时无效 更多 ... 

unsigned int nSpecialNetIP 

[IN] 指定的网卡 IP 更多 ... 

unsigned int nReserved [14] 

预留 更多 ... 

# 详细描述 

动作命令信息 

示例 

DynamicallyLoadDLL.cpp , 以及 Grab_ActionCommand.cpp .

# 结构体成员变量说明 

◆ nDeviceKey 

unsigned int nDeviceKey 

[IN] 设备密钥 

示例 

Grab_ActionCommand.cpp .

◆ nGroupKey 

unsigned int nGroupKey 

[IN] 组键 

示例 

Grab_ActionCommand.cpp .◆ nGroupMask 

unsigned int nGroupMask 

[IN] 组掩码 

示例 

Grab_ActionCommand.cpp .

◆ bActionTimeEnable 

unsigned int bActionTimeEnable 

[IN] 只有设置成 1时Action Time 才有效，非 1时无效 

示例 

Grab_ActionCommand.cpp .

◆ nActionTime 

int64_t nActionTime 

[IN] 预定的时间，和主频有关 

◆ pBroadcastAddress 

const char* pBroadcastAddress 

[IN] 广播包地址 

示例 

Grab_ActionCommand.cpp .

◆ nTimeOut 

unsigned int nTimeOut 

[IN] 等待 ACK 的超时时间，如果为 0表示不需要 ACK 示例 

Grab_ActionCommand.cpp .

◆ bSpecialNetEnable 

unsigned int bSpecialNetEnable 

[IN] 只有设置成 1时指定的网卡 IP 才有效，非 1时无效 

◆ nSpecialNetIP 

unsigned int nSpecialNetIP 

[IN] 指定的网卡 IP 

◆ nReserved 

unsigned int nReserved[14] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 成员变量 

# MV_ACTION_CMD_RESULT 结构体 参考 

> 结构体定义

动作命令返回信息 更多 ... 

# 成员变量 

unsigned char strDeviceAddress [12+3+1] 

[OUT] 设备 IP 更多 ... 

int nStatus 

[OUT] 状态码 

0x0000 ：成功。 

0x8001 ：设备不支持该命令 

0x8013 ：设备没有同步到主时钟作为时间参考。 

0x8015 ：设备队列或包数据溢出。 

0x8016 ：该请求已过时。 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

动作命令返回信息 

示例 

Grab_ActionCommand.cpp .

# 结构体成员变量说明 

◆ strDeviceAddress 

unsigned char strDeviceAddress[12+3+1] [OUT] 设备 IP 

示例 

Grab_ActionCommand.cpp .

◆ nStatus 

int nStatus 

[OUT] 状态码 

0x0000 ：成功。 

0x8001 ：设备不支持该命令 

0x8013 ：设备没有同步到主时钟作为时间参考。 

0x8015 ：设备队列或包数据溢出。 

0x8016 ：该请求已过时。 

示例 

Grab_ActionCommand.cpp .

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

> 成员变量

# MV_ACTION_CMD_RESULT_LIST 结构体 参考 

> 结构体定义

动作命令返回信息列表 更多 ... 

# 成员变量 

unsigned int nNumResults 

[OUT] 返回值个数 更多 ... 

MV_ACTION_CMD_RESULT * pResults 

[OUT] 动作命令结果 更多 ... 

# 详细描述 

动作命令返回信息列表 

示例 

DynamicallyLoadDLL.cpp , 以及 Grab_ActionCommand.cpp .

# 结构体成员变量说明 

◆ nNumResults 

unsigned int nNumResults 

[OUT] 返回值个数 

示例 

Grab_ActionCommand.cpp .◆ pResults 

MV_ACTION_CMD_RESULT * pResults 

[OUT] 动作命令结果 

示例 

Grab_ActionCommand.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_NODE_ERROR 结构体 参考 

> 结构体定义

节点错误信息 更多 ... 

# 成员变量 

char strName [MV_MAX_NODE_NAME_LEN ]

节点名称 更多 ... 

MVCC_NODE_ERR_TYPE enErrType 错误类型 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

节点错误信息 

# 结构体成员变量说明 

◆ strName 

char strName[ MV_MAX_NODE_NAME_LEN ]

节点名称 

◆ enErrType 

MVCC_NODE_ERR_TYPE enErrType 

错误类型 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_NODE_ERROR_LIST 结构体 参考 

> 结构体定义

节点错误信息列表 更多 ... 

# 成员变量 

unsigned int nErrorNum 

错误个数 更多 ... 

MVCC_NODE_ERROR stNodeError [MV_MAX_NODE_ERROR_NUM ]

错误信息 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

节点错误信息列表 

# 结构体成员变量说明 ◆ nErrorNum 

unsigned int nErrorNum 

错误个数 

◆ stNodeError 

MVCC_NODE_ERROR stNodeError[ MV_MAX_NODE_ERROR_NUM ]

错误信息 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_ENUMVALUE 结构体 参考 结构体定义 

枚举类型值 更多 ... 

# 成员变量 

unsigned int nCurValue 

[OUT] 当前值 更多 ... 

unsigned int nSupportedNum 

[OUT] 数据的有效数据个数 更多 ... 

unsigned int nSupportValue [MV_MAX_XML_SYMBOLIC_NUM ]

[OUT] 支持的枚举值 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

枚举类型值 

示例 

ConfigLightController.cpp , DynamicallyLoadDLL.cpp , InterfaceDemo.cpp , 以及 

Recording.cpp .

# 结构体成员变量说明 

◆ nCurValue 

unsigned int nCurValue 

[OUT] 当前值 

示例 

ConfigLightController.cpp , InterfaceDemo.cpp , 以及 Recording.cpp .◆ nSupportedNum 

unsigned int nSupportedNum 

[OUT] 数据的有效数据个数 

◆ nSupportValue 

unsigned int nSupportValue[ MV_MAX_XML_SYMBOLIC_NUM ]

[OUT] 支持的枚举值 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_ENUMVALUE_EX 结构体 参考 结构体定义 

枚举类型值 更多 ... 

# 成员变量 

unsigned int nCurValue 

[OUT] 当前值 更多 ... 

unsigned int nSupportedNum 

[OUT] 数据的有效数据个数 更多 ... 

unsigned int nSupportValue [MV_MAX_ENUM_SYMBOLIC_NUM ]

[OUT] 支持的枚举值 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

枚举类型值 

# 结构体成员变量说明 

◆ nCurValue 

unsigned int nCurValue 

[OUT] 当前值 

◆ nSupportedNum 

unsigned int nSupportedNum 

[OUT] 数据的有效数据个数 ◆ nSupportValue 

unsigned int nSupportValue[ MV_MAX_ENUM_SYMBOLIC_NUM ]

[OUT] 支持的枚举值 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_ENUMENTRY 结构体 参考 

> 结构体定义

枚举类型条目 更多 ... 

# 成员变量 unsigned int nValue 

[IN] 指定值 更多 ... 

char chSymbolic [MV_MAX_SYMBOLIC_LEN ]

[OUT] 指定值对应的符号 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

枚举类型条目 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

# 结构体成员变量说明 

◆ nValue 

unsigned int nValue 

[IN] 指定值 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ chSymbolic 

char chSymbolic[ MV_MAX_SYMBOLIC_LEN ]

[OUT] 指定值对应的符号 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_INTVALUE 结构体 参考 

> 结构体定义

Int 类型值 更多 ... 

# 成员变量 

unsigned int nCurValue 

[OUT] 当前值 更多 ... 

unsigned int nMax 

[OUT] 最大值 更多 ... 

unsigned int nMin [OUT] 最小值 更多 ... 

unsigned int nInc 

[OUT] Inc 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

Int 类型值 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 Recording.cpp .

# 结构体成员变量说明 

◆ nCurValue 

unsigned int nCurValue 

[OUT] 当前值 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 Recording.cpp .

◆ nMax 

unsigned int nMax 

[OUT] 最大值 

◆ nMin 

unsigned int nMin [OUT] 最小值 

◆ nInc 

unsigned int nInc 

[OUT] Inc 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_INTVALUE_EX 结构体 参考 

> 结构体定义

Int 类型值 Ex 更多 ... 成员变量 

int64_t nCurValue 

[OUT] 当前值 更多 ... 

int64_t nMax 

[OUT] 最大值 更多 ... 

int64_t nMin 

[OUT] 最小值 更多 ... 

int64_t nInc 

[OUT] Inc 更多 ... 

unsigned int nReserved [16] 

预留 更多 ... 

# 详细描述 

Int 类型值 Ex 

示例 

ConfigLightController.cpp , DynamicallyLoadDLL.cpp , Grab_Asynchronous.cpp ,

InterfaceDemo.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

# 结构体成员变量说明 

◆ nCurValue 

int64_t nCurValue 

[OUT] 当前值 

示例 ConfigLightController.cpp , Grab_Asynchronous.cpp , InterfaceDemo.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nMax 

int64_t nMax 

[OUT] 最大值 

◆ nMin 

int64_t nMin 

[OUT] 最小值 

◆ nInc 

int64_t nInc 

[OUT] Inc 

◆ nReserved 

unsigned int nReserved[16] 

预留 

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_FLOATVALUE 结构体 参考 

> 结构体定义

Float 类型值 更多 ... 

# 成员变量 

float fCurValue 

[OUT] 当前值 更多 ... 

float fMax 

[OUT] 最大值 更多 ... 

float fMin 

[OUT] 最小值 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

Float 类型值 

示例 

ConfigLightController.cpp , DynamicallyLoadDLL.cpp , InterfaceDemo.cpp , 以及 

Recording.cpp .结构体成员变量说明 

◆ fCurValue 

float fCurValue 

[OUT] 当前值 

示例 

ConfigLightController.cpp , InterfaceDemo.cpp , 以及 Recording.cpp .

◆ fMax 

float fMax 

[OUT] 最大值 

◆ fMin 

float fMin 

[OUT] 最小值 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_STRINGVALUE 结构体 参考 

> 结构体定义

String 类型值 更多 ... 

# 成员变量 

char chCurValue [256] 

[OUT] 当前值 更多 ... 

int64_t nMaxLength 

[OUT] 最大长度 更多 ... 

unsigned int nReserved [2] 

预留 更多 ... 

# 详细描述 

String 类型值 

示例 

ConfigLightController.cpp , DynamicallyLoadDLL.cpp , 以及 InterfaceDemo.cpp .

# 结构体成员变量说明 ◆ chCurValue 

char chCurValue[256] 

[OUT] 当前值 

示例 

ConfigLightController.cpp , 以及 InterfaceDemo.cpp .

◆ nMaxLength 

int64_t nMaxLength 

[OUT] 最大长度 

◆ nReserved 

unsigned int nReserved[2] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 成员变量 

# MVCC_COLORF 结构体 参考 

> 结构体定义

辅助线颜色 更多 ... 

# 成员变量 

float fR 

[IN] 红色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

更多 ... 

float fG 

[IN] 绿色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

更多 ... 

float fB 

[IN] 蓝色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

更多 ... 

float fAlpha 

[IN] 透明度，根据像素颜色的相对透明度，范围为 [0.0 , 1.0] 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

辅助线颜色 

# 结构体成员变量说明 

◆ fR float fR 

[IN] 红色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

◆ fG 

float fG 

[IN] 绿色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

◆ fB 

float fB 

[IN] 蓝色，根据像素颜色的相对深度，范围为 [0.0 , 1.0] ，代表着 [0, 255] 的颜色深度 

◆ fAlpha 

float fAlpha 

[IN] 透明度，根据像素颜色的相对透明度，范围为 [0.0 , 1.0] 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_POINTF 结构体 参考 

> 结构体定义

自定义点 更多 ... 

# 成员变量 

float fX 

[IN] 该点距离图像左边缘距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

float fY 

[IN] 该点距离图像上边缘距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

自定义点 

# 结构体成员变量说明 

◆ fX 

float fX [IN] 该点距离图像左边缘距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ fY 

float fY 

[IN] 该点距离图像上边缘距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_RECT_INFO 结构体 参考 

> 结构体定义

矩形框区域信息 更多 ... 成员变量 

float fTop 

[IN] 矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

float fBottom 

[IN] 矩形下边缘距离图像上边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

float fLeft 

[IN] 矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

float fRight 

[IN] 矩形右边缘距离图像左边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 更多 ... 

MVCC_COLORF stColor 

[IN] 辅助线颜色 更多 ... 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

矩形框区域信息 

# 结构体成员变量说明 

◆ fTop float fTop 

[IN] 矩形上边缘距离图像上边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ fBottom 

float fBottom 

[IN] 矩形下边缘距离图像上边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ fLeft 

float fLeft 

[IN] 矩形左边缘距离图像左边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ fRight 

float fRight 

[IN] 矩形右边缘距离图像左边缘的距离，根据图像的相对位置，范围为 [0.0 , 1.0] 

◆ stColor 

MVCC_COLORF stColor 

[IN] 辅助线颜色 

◆ nLineWidth 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2

◆ nReserved 

unsigned int nReserved[4] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_CIRCLE_INFO 结构体 参考 

> 结构体定义

圆形框区域信息 更多 ... 

# 成员变量 

MVCC_POINTF stCenterPoint 

[IN] 圆心信息 更多 ... 

float fR1 

[IN] 宽向半径，根据图像的相对位置 [0, 1.0] ，半径与圆心的位置有关，需保证 画出的圆在显示框范围之内，否则报错 更多 ... 

float fR2 

[IN] 高向半径，根据图像的相对位置 [0, 1.0] ，半径与圆心的位置有关，需保证 画出的圆在显示框范围之内，否则报错 更多 ... MVCC_COLORF stColor 

[IN] 辅助线颜色信息 更多 ... 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

圆形框区域信息 

# 结构体成员变量说明 

◆ stCenterPoint 

MVCC_POINTF stCenterPoint 

[IN] 圆心信息 

◆ fR1 

float fR1 

[IN] 宽向半径，根据图像的相对位置 [0, 1.0] ，半径与圆心的位置有关，需保证画出的圆在显示 框范围之内，否则报错 

◆ fR2 

float fR2 

[IN] 高向半径，根据图像的相对位置 [0, 1.0] ，半径与圆心的位置有关，需保证画出的圆在显示 框范围之内，否则报错 ◆ stColor 

MVCC_COLORF stColor 

[IN] 辅助线颜色信息 

◆ nLineWidth 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MVCC_LINES_INFO 结构体 参考 结构体定义 

线条辅助线信息 更多 ... 

# 成员变量 

MVCC_POINTF stStartPoint 

[IN] 线条辅助线的起始点坐标 更多 ... 

MVCC_POINTF stEndPoint 

[IN] 线条辅助线的终点坐标 更多 ... 

MVCC_COLORF stColor 

[IN] 辅助线颜色信息 更多 ... 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2 更多 ... 

unsigned int nReserved [4] 

预留 更多 ... 

# 详细描述 

线条辅助线信息 

# 结构体成员变量说明 

◆ stStartPoint 

MVCC_POINTF stStartPoint 

[IN] 线条辅助线的起始点坐标 

◆ stEndPoint MVCC_POINTF stEndPoint 

[IN] 线条辅助线的终点坐标 

◆ stColor 

MVCC_COLORF stColor 

[IN] 辅助线颜色信息 

◆ nLineWidth 

unsigned int nLineWidth 

[IN] 辅助线宽度，宽度只能是 1或2

◆ nReserved 

unsigned int nReserved[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> 成员变量

# MV_OUTPUT_IMAGE_INFO 结构体 参考 

> 结构体定义

图像重构后的图像列表 更多 ... 

# 成员变量 

unsigned int nWidth 

[OUT] 源图像宽 更多 ... 

unsigned int nHeight 

[OUT] 源图像高 更多 ... 

enum MvGvspPixelType enPixelType 

[OUT] 像素格式 更多 ... 

unsigned char * pBuf 

[IN][OUT] 输出数据缓存 更多 ... 

unsigned int nBufLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nBufSize 

[IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nRes [8] 

预留 更多 ... 

# 详细描述 

图像重构后的图像列表 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[OUT] 源图像宽 

◆ nHeight 

unsigned int nHeight 

[OUT] 源图像高 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[OUT] 像素格式 

◆ pBuf 

unsigned char* pBuf 

[IN][OUT] 输出数据缓存 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nBufLen 

unsigned int nBufLen 

[OUT] 输出数据长度 示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nBufSize 

unsigned int nBufSize 

[IN] 提供的输出缓冲区大小 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nRes 

unsigned int nRes[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_RECONSTRUCT_IMAGE_PARAM 结构体 参考 

> 结构体定义

重构图像参数信息 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 源图像宽 更多 ... 

unsigned int nHeight 

[IN] 源图像高 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned char * pSrcData 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcDataLen 

[IN] 输入数据长度 更多 ... 

unsigned int nExposureNum 

[IN] 曝光个数 (1-8] 更多 ... 

MV_IMAGE_RECONSTRUCTION_METHOD enReconstructMethod 

[IN] 图像重构方式 更多 ... 

MV_OUTPUT_IMAGE_INFO stDstBufList [MV_MAX_SPLIT_NUM ]

[OUT] 输出数据缓存信息 更多 ... 

unsigned int nRes [4] 

预留 更多 ... 

# 详细描述 

重构图像参数信息 

示例 

MultiLightCtrl_ImageStitching.cpp .结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 源图像宽 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nHeight 

unsigned int nHeight 

[IN] 源图像高 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ pSrcData 

unsigned char* pSrcData 

[IN] 输入数据缓存 

示例 

MultiLightCtrl_ImageStitching.cpp .◆ nSrcDataLen 

unsigned int nSrcDataLen 

[IN] 输入数据长度 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nExposureNum 

unsigned int nExposureNum 

[IN] 曝光个数 (1-8] 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ enReconstructMethod 

MV_IMAGE_RECONSTRUCTION_METHOD enReconstructMethod 

[IN] 图像重构方式 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ stDstBufList 

MV_OUTPUT_IMAGE_INFO stDstBufList[ MV_MAX_SPLIT_NUM ]

[OUT] 输出数据缓存信息 

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ nRes 

unsigned int nRes[4] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CAML_SERIAL_PORT 结构体 参考 

> 结构体定义

串口信息 更多 ... 

# 成员变量 

unsigned char chSerialPort [INFO_MAX_BUFFER_SIZE ]

[OUT] 串口号 更多 ... 

unsigned int nRes [4] 

预留 更多 ... 

# 详细描述 串口信息 

# 结构体成员变量说明 

◆ chSerialPort 

unsigned char chSerialPort[ INFO_MAX_BUFFER_SIZE ]

[OUT] 串口号 

◆ nRes 

unsigned int nRes[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CAML_SERIAL_PORT_LIST 结构体 参考 

> 结构体定义

串口信息列表 更多 ... 

# 成员变量 

unsigned int nSerialPortNum 

[OUT] 串口数量 更多 ... 

MV_CAML_SERIAL_PORT stSerialPort [MV_MAX_SERIAL_PORT_NUM ]

[IN][OUT] 串口信息 更多 ... 

unsigned int nRes [4] 

预留 更多 ... 

# 详细描述 

串口信息列表 

# 结构体成员变量说明 

◆ nSerialPortNum 

unsigned int nSerialPortNum 

[OUT] 串口数量 

◆ stSerialPort 

MV_CAML_SERIAL_PORT stSerialPort[ MV_MAX_SERIAL_PORT_NUM ]

[IN][OUT] 串口信息 

◆ nRes 

unsigned int nRes[4] 预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_SAVE_IMAGE_PARAM_EX3 结构体 参考 

> 结构体定义

图片保存参数 更多 ... 

# 成员变量 

unsigned char * pData 

[IN] 输入数据缓存 更多 ... 

unsigned int nDataLen 

[IN] 输入数据长度 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 更多 ... 

unsigned int nWidth [IN] 图像宽 更多 ... 

unsigned int nHeight 

[IN] 图像高 更多 ... 

unsigned char * pImageBuffer 

[OUT] 输出图片缓存 更多 ... 

unsigned int nImageLen 

[OUT] 输出图片长度 更多 ... 

unsigned int nBufferSize 

[IN] 提供的输出缓冲区大小 更多 ... 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输出图片格式 更多 ... 

unsigned int nJpgQuality 

[IN] JPG 编码质量 (50-99] ，其它格式无效 更多 ... 

unsigned int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-

最优 + ，RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和

3 更多 ... 

unsigned int nReserved [3] 

预留 更多 ... 

# 详细描述 

图片保存参数 

# 结构体成员变量说明 ◆ pData 

unsigned char* pData 

[IN] 输入数据缓存 

◆ nDataLen 

unsigned int nDataLen 

[IN] 输入数据长度 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽 

◆ nHeight 

unsigned int nHeight 

[IN] 图像高 

◆ pImageBuffer 

unsigned char* pImageBuffer 

[OUT] 输出图片缓存 ◆ nImageLen 

unsigned int nImageLen 

[OUT] 输出图片长度 

◆ nBufferSize 

unsigned int nBufferSize 

[IN] 提供的输出缓冲区大小 

◆ enImageType 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输出图片格式 

◆ nJpgQuality 

unsigned int nJpgQuality 

[IN] JPG 编码质量 (50-99] ，其它格式无效 

◆ iMethodValue 

unsigned int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-最优 + ，

RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和3

◆ nReserved 

unsigned int nReserved[3] 

预留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_SAVE_IMAGE_TO_FILE_PARAM_EX 结构体 参考 

> 结构体定义

保存图片到文件参数 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽 更多 ... 

unsigned int nHeight 

[IN] 图像高 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 更多 ... 

unsigned char * pData 

[IN] 输入数据缓存 更多 ... 

unsigned int nDataLen [IN] 输入数据大小 更多 ... 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输入图片格式 更多 ... 

char * pcImagePath 

[IN] 输入文件路径 更多 ... 

unsigned int nQuality 

[IN] JPG 编码质量 (50-99] ，其他格式无效 更多 ... 

int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-

最优 +，RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和3

更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 

# 详细描述 

保存图片到文件参数 

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽 

◆ nHeight 

unsigned int nHeight [IN] 图像高 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 输入数据的像素格式 

◆ pData 

unsigned char* pData 

[IN] 输入数据缓存 

◆ nDataLen 

unsigned int nDataLen 

[IN] 输入数据大小 

◆ enImageType 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输入图片格式 

◆ pcImagePath 

char* pcImagePath 

[IN] 输入文件路径 

◆ nQuality 

unsigned int nQuality 

[IN] JPG 编码质量 (50-99] ，其他格式无效 ◆ iMethodValue 

int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-最优 +，

RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和3

◆ nReserved 

unsigned int nReserved[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_SAVE_IMAGE_PARAM 结构体 参考 

> 结构体定义

保存图片所需参数 更多 ... 成员变量 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输入图片格式 更多 ... 

unsigned int nQuality 

[IN] JPG 编码质量 (50-99] ，其它格式无效 更多 ... 

int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-

最优 +, RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和3

更多 ... 

unsigned int nReserved [8] 

预留 更多 ... 

# 详细描述 

保存图片所需参数 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

# 结构体成员变量说明 

◆ enImageType 

enum MV_SAVE_IAMGE_TYPE enImageType 

[IN] 输入图片格式 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .◆ nQuality 

unsigned int nQuality 

[IN] JPG 编码质量 (50-99] ，其它格式无效 

示例 

ImageSave.cpp , 以及 LensShadingCorrection.cpp .

◆ iMethodValue 

int iMethodValue 

[IN] 插值方法 0-快速 1-均衡（其它值默认为均衡） 2-最优 3-最优 +, RBGG/BRGG/GGRB/GGBR 相关像素格式不支持 0和3

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , LensShadingCorrection.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ nReserved 

unsigned int nReserved[8] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_CC_PIXEL_CONVERT_PARAM_EX 结构体 参考 

> 结构体定义

像素转换结构体 更多 ... 

# 成员变量 

unsigned int nWidth 

[IN] 图像宽 更多 ... 

unsigned int nHeight 

[IN] 图像高 更多 ... 

enum MvGvspPixelType enSrcPixelType 

[IN] 源像素格式 更多 ... 

unsigned char * pSrcData 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcDataLen 

[IN] 输入数据长度 更多 ... 

enum MvGvspPixelType enDstPixelType 

[IN] 目标像素格式 更多 ... 

unsigned char * pDstBuffer 

[OUT] 输出数据缓存 更多 ... 

unsigned int nDstLen 

[OUT] 输出数据长度 更多 ... 

unsigned int nDstBufferSize [IN] 提供的输出缓冲区大小 更多 ... 

unsigned int nRes [4] 

预留 更多 ... 

# 详细描述 

像素转换结构体 

示例 

ConvertPixelType.cpp .

# 结构体成员变量说明 

◆ nWidth 

unsigned int nWidth 

[IN] 图像宽 

示例 

ConvertPixelType.cpp .

◆ nHeight 

unsigned int nHeight 

[IN] 图像高 

示例 

ConvertPixelType.cpp .

◆ enSrcPixelType 

enum MvGvspPixelType enSrcPixelType [IN] 源像素格式 

示例 

ConvertPixelType.cpp .

◆ pSrcData 

unsigned char* pSrcData 

[IN] 输入数据缓存 

示例 

ConvertPixelType.cpp .

◆ nSrcDataLen 

unsigned int nSrcDataLen 

[IN] 输入数据长度 

示例 

ConvertPixelType.cpp .

◆ enDstPixelType 

enum MvGvspPixelType enDstPixelType 

[IN] 目标像素格式 

示例 

ConvertPixelType.cpp .

◆ pDstBuffer 

unsigned char* pDstBuffer 

[OUT] 输出数据缓存 

示例 ConvertPixelType.cpp .

◆ nDstLen 

unsigned int nDstLen 

[OUT] 输出数据长度 

示例 

ConvertPixelType.cpp .

◆ nDstBufferSize 

unsigned int nDstBufferSize 

[IN] 提供的输出缓冲区大小 

示例 

ConvertPixelType.cpp .

◆ nRes 

unsigned int nRes[4] 

预留 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_SAVE_POINT_CLOUD_PARAM 结构体 参考 

> 结构体定义

保存 3D 数据到缓存（自 4.4.1 版本废弃） 更多 ... 

# 成员变量 

unsigned int nLinePntNum 

[IN] 行点数，即图像宽 更多 ... 

unsigned int nLineNum 

[IN] 行数，即图像高 更多 ... 

enum MvGvspPixelType enSrcPixelType 

[IN] 输入数据的像素格式 更多 ... 

unsigned char * pSrcData 

[IN] 输入数据缓存 更多 ... 

unsigned int nSrcDataLen 

[IN] 输入数据长度 更多 ... 

unsigned char * pDstBuf 

[OUT] 输出像素数据缓存 更多 ... 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 (nLinePntNum * nLineNum * (16*3 + 4) + 2048) 更多 ... 

unsigned int nDstBufLen 

[OUT] 输出像素数据缓存长度 更多 ... MV_SAVE_POINT_CLOUD_FILE_TYPE enPointCloudFileType 

[IN] 提供输出的点云文件类型 更多 ... 

unsigned int nReserved [8] 

保留字段 更多 ... 

# 详细描述 

保存 3D 数据到缓存（自 4.4.1 版本废弃） 

# 结构体成员变量说明 

◆ nLinePntNum 

unsigned int nLinePntNum 

[IN] 行点数，即图像宽 

◆ nLineNum 

unsigned int nLineNum 

[IN] 行数，即图像高 

◆ enSrcPixelType 

enum MvGvspPixelType enSrcPixelType 

[IN] 输入数据的像素格式 

◆ pSrcData 

unsigned char* pSrcData [IN] 输入数据缓存 

◆ nSrcDataLen 

unsigned int nSrcDataLen 

[IN] 输入数据长度 

◆ pDstBuf 

unsigned char* pDstBuf 

[OUT] 输出像素数据缓存 

◆ nDstBufSize 

unsigned int nDstBufSize 

[IN] 提供的输出缓冲区大小 (nLinePntNum * nLineNum * (16*3 + 4) + 2048) 

◆ nDstBufLen 

unsigned int nDstBufLen 

[OUT] 输出像素数据缓存长度 

◆ enPointCloudFileType 

MV_SAVE_POINT_CLOUD_FILE_TYPE enPointCloudFileType 

[IN] 提供输出的点云文件类型 

◆ nReserved 

unsigned int nReserved[8] 

保留字段 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 成员变量

# MV_DISPLAY_FRAME_INFO 结构体 参考 

> 结构体定义

显示帧信息（自 4.4.1 版本废弃） 更多 ... 

# 成员变量 

void * hWnd 

[IN] 窗口句柄 更多 ... 

unsigned char * pData 

[IN] 显示的数据 更多 ... 

unsigned int nDataLen 

[IN] 数据长度 更多 ... 

unsigned short nWidth 

[IN] 图像宽 更多 ... 

unsigned short nHeight [IN] 图像高 更多 ... 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 更多 ... 

unsigned int enRenderMode 

[IN] 图像渲染方式 0-GDI （默认） , 1-D3D, 2-OpenGL 更多 ... 

unsigned int nRes [3] 

保留 更多 ... 

# 详细描述 

显示帧信息（自 4.4.1 版本废弃） 

示例 

DynamicallyLoadDLL.cpp .

# 结构体成员变量说明 

◆ hWnd 

void* hWnd 

[IN] 窗口句柄 

◆ pData 

unsigned char* pData 

[IN] 显示的数据 

◆ nDataLen 

unsigned int nDataLen [IN] 数据长度 

◆ nWidth 

unsigned short nWidth 

[IN] 图像宽 

◆ nHeight 

unsigned short nHeight 

[IN] 图像高 

◆ enPixelType 

enum MvGvspPixelType enPixelType 

[IN] 像素格式 

◆ enRenderMode 

unsigned int enRenderMode 

[IN] 图像渲染方式 0-GDI （默认） , 1-D3D, 2-OpenGL 

◆ nRes 

unsigned int nRes[3] 

保留 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 枚举

# 枚举类型定义 

包含不同类型的枚举信息 更多 ... 

# 枚举 

enum MV_GRAB_STRATEGY {

MV_GrabStrategy_OneByOne = 0, 

MV_GrabStrategy_LatestImagesOnly = 1, 

MV_GrabStrategy_LatestImages = 2, 

MV_GrabStrategy_UpcomingImage = 3 }

取流策略 更多 ... 

enum MV_SAVE_IAMGE_TYPE {

MV_Image_Undefined = 0, 

MV_Image_Bmp = 1, 

MV_Image_Jpeg = 2, 

MV_Image_Png = 3, 

MV_Image_Tif = 4 }保存图片格式 更多 ... 

enum MV_IMG_ROTATION_ANGLE {

MV_IMAGE_ROTATE_90 = 1, 

MV_IMAGE_ROTATE_180 = 2, 

MV_IMAGE_ROTATE_270 = 3 }

旋转角度 更多 ... 

enum MV_IMG_FLIP_TYPE {

MV_FLIP_VERTICAL = 1, 

MV_FLIP_HORIZONTAL = 2 }

翻转类型 更多 ... 

enum MV_CC_GAMMA_TYPE {

MV_CC_GAMMA_TYPE_NONE = 0, 

MV_CC_GAMMA_TYPE_VALUE = 1, 

MV_CC_GAMMA_TYPE_USER_CURVE = 2, 

MV_CC_GAMMA_TYPE_LRGB2SRGB = 3, 

MV_CC_GAMMA_TYPE_SRGB2LRGB = 4 }

Gamma 类型 更多 ... 

enum MV_RECORD_FORMAT_TYPE {

MV_FormatType_Undefined = 0, 

MV_FormatType_AVI = 1 }

录像格式定义 更多 ... 

enum MV_CAM_ACQUISITION_MODE {

MV_ACQ_MODE_SINGLE = 0, 

MV_ACQ_MODE_MUTLI = 1, 

MV_ACQ_MODE_CONTINUOUS = 2 }

采集模式 更多 ... 

enum MV_CAM_GAIN_MODE {

MV_GAIN_MODE_OFF = 0, MV_GAIN_MODE_ONCE = 1, 

MV_GAIN_MODE_CONTINUOUS = 2 }

增益模式 更多 ... 

enum MV_CAM_EXPOSURE_MODE {

MV_EXPOSURE_MODE_TIMED = 0, 

MV_EXPOSURE_MODE_TRIGGER_WIDTH = 1 }

曝光模式 更多 ... 

enum MV_CAM_EXPOSURE_AUTO_MODE {

MV_EXPOSURE_AUTO_MODE_OFF = 0, 

MV_EXPOSURE_AUTO_MODE_ONCE = 1, 

MV_EXPOSURE_AUTO_MODE_CONTINUOUS = 2 }

自动曝光模式 更多 ... 

enum MV_CAM_TRIGGER_MODE {

MV_TRIGGER_MODE_OFF = 0, 

MV_TRIGGER_MODE_ON = 1 }

触发模式 更多 ... 

enum MV_CAM_GAMMA_SELECTOR {

MV_GAMMA_SELECTOR_USER = 1, 

MV_GAMMA_SELECTOR_SRGB = 2 }

Gamma 选择器 更多 ... 

enum MV_CAM_BALANCEWHITE_AUTO {

MV_BALANCEWHITE_AUTO_OFF = 0, 

MV_BALANCEWHITE_AUTO_ONCE = 2, 

MV_BALANCEWHITE_AUTO_CONTINUOUS = 1 }

白平衡 更多 ... 

enum MV_CAM_TRIGGER_SOURCE {

MV_TRIGGER_SOURCE_LINE0 = 0, MV_TRIGGER_SOURCE_LINE1 = 1, 

MV_TRIGGER_SOURCE_LINE2 = 2, 

MV_TRIGGER_SOURCE_LINE3 = 3, 

MV_TRIGGER_SOURCE_COUNTER0 = 4, 

MV_TRIGGER_SOURCE_SOFTWARE = 7, 

MV_TRIGGER_SOURCE_FrequencyConverter = 8 }

触发源 更多 ... 

enum MV_CC_STREAM_EXCEPTION_TYPE {

MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE = 0x4001, 

MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW = 0x4002, 

MV_CC_STREAM_EXCEPTION_LIST_EMPTY = 0x4003, 

MV_CC_STREAM_EXCEPTION_RECONNECTION = 0x4004, 

MV_CC_STREAM_EXCEPTION_DISCONNECTED = 0x4005, 

MV_CC_STREAM_EXCEPTION_DEVICE = 0x4006, 

MV_CC_STREAM_EXCEPTION_PARTIAL_IMAGE = 0x4007 }

流异常类型 更多 ... 

enum MV_GIGE_TRANSMISSION_TYPE {

MV_GIGE_TRANSTYPE_UNICAST = 0x0, 

MV_GIGE_TRANSTYPE_MULTICAST = 0x1, 

MV_GIGE_TRANSTYPE_LIMITEDBROADCAST = 0x2, 

MV_GIGE_TRANSTYPE_SUBNETBROADCAST = 0x3, 

MV_GIGE_TRANSTYPE_CAMERADEFINED = 0x4, 

MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT = 0x5, 

MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV = 0x00010000, 

MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV = 0x00010001 }

Gige 的传输类型 更多 ... 

enum MV_SORT_METHOD {

SortMethod_SerialNumber = 0, 

SortMethod_UserID = 1, 

SortMethod_CurrentIP_ASC = 2, 

SortMethod_CurrentIP_DESC = 3 }

排序方式 更多 ... enum MV_XML_InterfaceType {

IFT_IValue ,

IFT_IBase ,

IFT_IInteger ,

IFT_IBoolean ,

IFT_ICommand ,

IFT_IFloat ,

IFT_IString ,

IFT_IRegister ,

IFT_ICategory ,

IFT_IEnumeration ,

IFT_IEnumEntry ,

IFT_IPort 

}

每个节点对应的接口类型 更多 ... 

enum MV_XML_AccessMode {

AM_NI ,

AM_NA ,

AM_WO ,

AM_RO ,

AM_RW ,

AM_Undefined ,

AM_CycleDetect 

}

节点的访问模式 更多 ... 

enum MVCC_NODE_ERR_TYPE {

MVCC_NODE_ERR_NODE_INVALID = 1, 

MVCC_NODE_ERR_ACCESS = 2, 

MVCC_NODE_ERR_OUT_RANGE = 3, 

MVCC_NODE_ERR_VERIFY_FAILD = 4, 

MVCC_NODE_ERR_OTHER = 100 }

导入参数报错时的原因 更多 ... 

enum MV_IMAGE_RECONSTRUCTION_METHOD { MV_SPLIT_BY_LINE = 1 } 

图像重构方式 更多 ... enum MvGvspPixelType {

PixelType_Gvsp_Undefined = 0xFFFFFFFF, 

PixelType_Gvsp_Mono1p = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(1) | 0x0037), 

PixelType_Gvsp_Mono2p = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(2) | 0x0038), 

PixelType_Gvsp_Mono4p = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(4) | 0x0039), 

PixelType_Gvsp_Mono8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0001), 

PixelType_Gvsp_Mono8_Signed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0002), 

PixelType_Gvsp_Mono10 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0003), 

PixelType_Gvsp_Mono10_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0004), 

PixelType_Gvsp_Mono12 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0005), 

PixelType_Gvsp_Mono12_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0006), 

PixelType_Gvsp_Mono14 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0025), 

PixelType_Gvsp_Mono16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0007), 

PixelType_Gvsp_BayerGR8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0008), 

PixelType_Gvsp_BayerRG8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0009), 

PixelType_Gvsp_BayerGB8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x000A), 

PixelType_Gvsp_BayerBG8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x000B), 

PixelType_Gvsp_BayerRBGG8 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0046), 

PixelType_Gvsp_BayerGR10 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000C), 

PixelType_Gvsp_BayerRG10 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000D), PixelType_Gvsp_BayerGB10 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000E), 

PixelType_Gvsp_BayerBG10 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000F), 

PixelType_Gvsp_BayerGR12 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0010), 

PixelType_Gvsp_BayerRG12 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0011), 

PixelType_Gvsp_BayerGB12 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0012), 

PixelType_Gvsp_BayerBG12 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0013), 

PixelType_Gvsp_BayerGR10_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0026), 

PixelType_Gvsp_BayerRG10_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0027), 

PixelType_Gvsp_BayerGB10_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0028), 

PixelType_Gvsp_BayerBG10_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0029), 

PixelType_Gvsp_BayerGR12_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002A), 

PixelType_Gvsp_BayerRG12_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002B), 

PixelType_Gvsp_BayerGB12_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002C), 

PixelType_Gvsp_BayerBG12_Packed = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002D), 

PixelType_Gvsp_BayerGR16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x002E), 

PixelType_Gvsp_BayerRG16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x002F), 

PixelType_Gvsp_BayerGB16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0030), 

PixelType_Gvsp_BayerBG16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0031), 

PixelType_Gvsp_RGB8_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0014), 

PixelType_Gvsp_BGR8_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0015), 

PixelType_Gvsp_RGBA8_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x0016), 

PixelType_Gvsp_BGRA8_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x0017), 

PixelType_Gvsp_RGB10_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0018), 

PixelType_Gvsp_BGR10_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0019), 

PixelType_Gvsp_RGB12_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x001A), 

PixelType_Gvsp_BGR12_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x001B), 

PixelType_Gvsp_RGB16_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0033), 

PixelType_Gvsp_BGR16_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x004B), 

PixelType_Gvsp_RGBA16_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x0064), 

PixelType_Gvsp_BGRA16_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x0051), 

PixelType_Gvsp_RGB10V1_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x001C), 

PixelType_Gvsp_RGB10V2_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x001D), 

PixelType_Gvsp_RGB12V1_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(36) | 0X0034), 

PixelType_Gvsp_RGB565_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0035), 

PixelType_Gvsp_BGR565_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0X0036), 

PixelType_Gvsp_YUV411_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x001E), 

PixelType_Gvsp_YUV422_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x001F), 

PixelType_Gvsp_YUV422_YUYV_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0032), 

PixelType_Gvsp_YUV444_Packed = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0020), PixelType_Gvsp_YCBCR8_CBYCR = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x003A), 

PixelType_Gvsp_YCBCR422_8 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x003B), 

PixelType_Gvsp_YCBCR422_8_CBYCRY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0043), 

PixelType_Gvsp_YCBCR411_8_CBYYCRYY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x003C), 

PixelType_Gvsp_YCBCR601_8_CBYCR = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x003D), 

PixelType_Gvsp_YCBCR601_422_8 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x003E), 

PixelType_Gvsp_YCBCR601_422_8_CBYCRY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0044), 

PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x003F), 

PixelType_Gvsp_YCBCR709_8_CBYCR = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0040), 

PixelType_Gvsp_YCBCR709_422_8 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0041), 

PixelType_Gvsp_YCBCR709_422_8_CBYCRY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0045), 

PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x0042), 

PixelType_Gvsp_YUV420SP_NV12 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x8001), 

PixelType_Gvsp_YUV420SP_NV21 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(12) | 0x8002), 

PixelType_Gvsp_RGB8_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0021), 

PixelType_Gvsp_RGB10_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0022), 

PixelType_Gvsp_RGB12_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0023), 

PixelType_Gvsp_RGB16_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0024), 

PixelType_Gvsp_Jpeg = (MV_GVSP_PIX_CUSTOM | MV_PIXEL_BIT_COUNT(24) | 0x0001), 

PixelType_Gvsp_Coord3D_ABC32f = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(96) | 0x00C0), 

PixelType_Gvsp_Coord3D_ABC32f_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(96) | 0x00C1), 

PixelType_Gvsp_Coord3D_ABC32 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(96) | 0x3001), 

PixelType_Gvsp_Coord3D_AB32f = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x3002), 

PixelType_Gvsp_Coord3D_AB32 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x3003), 

PixelType_Gvsp_Coord3D_AC32f_64 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x00C2), 

PixelType_Gvsp_Coord3D_AC32f_Planar = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x00C3), 

PixelType_Gvsp_Coord3D_AC32 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x3004), 

PixelType_Gvsp_Coord3D_A32f = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(32) | 0x00BD), 

PixelType_Gvsp_Coord3D_A32 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(32) | 0x3005), 

PixelType_Gvsp_Coord3D_C32f = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(32) | 0x00BF), 

PixelType_Gvsp_Coord3D_C32 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(32) | 0x3006), 

PixelType_Gvsp_Coord3D_ABC16 = (MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x00B9), 

PixelType_Gvsp_Coord3D_C16 = (MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x00B8), 

PixelType_Gvsp_HB_Mono8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0001), 

PixelType_Gvsp_HB_Mono10 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0003), 

PixelType_Gvsp_HB_Mono10_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0004), 

PixelType_Gvsp_HB_Mono12 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0005), 

PixelType_Gvsp_HB_Mono12_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0006), 

PixelType_Gvsp_HB_Mono16 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0007), PixelType_Gvsp_HB_BayerGR8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0008), 

PixelType_Gvsp_HB_BayerRG8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0009), 

PixelType_Gvsp_HB_BayerGB8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x000A), 

PixelType_Gvsp_HB_BayerBG8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x000B), 

PixelType_Gvsp_HB_BayerRBGG8 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(8) | 0x0046), 

PixelType_Gvsp_HB_BayerGR10 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000C), 

PixelType_Gvsp_HB_BayerRG10 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000D), 

PixelType_Gvsp_HB_BayerGB10 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000E), 

PixelType_Gvsp_HB_BayerBG10 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x000F), 

PixelType_Gvsp_HB_BayerGR12 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0010), 

PixelType_Gvsp_HB_BayerRG12 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0011), 

PixelType_Gvsp_HB_BayerGB12 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0012), 

PixelType_Gvsp_HB_BayerBG12 = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(16) | 0x0013), 

PixelType_Gvsp_HB_BayerGR10_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0026), 

PixelType_Gvsp_HB_BayerRG10_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0027), 

PixelType_Gvsp_HB_BayerGB10_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0028), 

PixelType_Gvsp_HB_BayerBG10_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x0029), 

PixelType_Gvsp_HB_BayerGR12_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002A), 

PixelType_Gvsp_HB_BayerRG12_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002B), 

PixelType_Gvsp_HB_BayerGB12_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002C), 

PixelType_Gvsp_HB_BayerBG12_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_MONO | MV_PIXEL_BIT_COUNT(12) | 0x002D), 

PixelType_Gvsp_HB_YUV422_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x001F), 

PixelType_Gvsp_HB_YUV422_YUYV_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(16) | 0x0032), 

PixelType_Gvsp_HB_RGB8_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0014), 

PixelType_Gvsp_HB_BGR8_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(24) | 0x0015), 

PixelType_Gvsp_HB_RGBA8_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x0016), 

PixelType_Gvsp_HB_BGRA8_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(32) | 0x0017), 

PixelType_Gvsp_HB_RGB16_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x0033), 

PixelType_Gvsp_HB_BGR16_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(48) | 0x004B), 

PixelType_Gvsp_HB_RGBA16_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x0064), 

PixelType_Gvsp_HB_BGRA16_Packed = (MV_GVSP_PIX_CUSTOM | MV_GVSP_PIX_COLOR | MV_PIXEL_BIT_COUNT(64) | 0x0051) }

图片格式定义 更多 ... 

enum MV_SAVE_POINT_CLOUD_FILE_TYPE {

MV_PointCloudFile_Undefined = 0, 

MV_PointCloudFile_PLY = 1, 

MV_PointCloudFile_CSV = 2, 

MV_PointCloudFile_OBJ = 3 }

保存的 3D 数据格式（自 4.4.1 版本废弃） 更多 ... 

# 详细描述 

包含不同类型的枚举信息 枚举类型说明 

◆ MV_GRAB_STRATEGY 

enum MV_GRAB_STRATEGY 

取流策略 

枚举值 

MV_GrabStrategy_OneByOne 从旧到新一帧一帧的获取图像（默认为该策略） 

MV_GrabStrategy_LatestImagesOnly 获取列表中最新的一帧图像（同时清除列表中的其余 图像） 

MV_GrabStrategy_LatestImages 获取列表中最新的图像，个数由 OutputQueueSize 决定 ，范围为 1-ImageNodeNum ，设置成 1等同于 

LatestImagesOnly, 设置成 ImageNodeNum 等同于 

OneByOne 

MV_GrabStrategy_UpcomingImage 等待下一帧图像 

◆ MV_SAVE_IAMGE_TYPE 

enum MV_SAVE_IAMGE_TYPE 

保存图片格式 

枚举值 

MV_Image_Undefined 未定义的图像格式 

MV_Image_Bmp BMP 图像格式 

MV_Image_Jpeg JPEG 图像格式 

MV_Image_Png PNG 图像格式 

MV_Image_Tif TIFF 图像格式 

◆ MV_IMG_ROTATION_ANGLE 

enum MV_IMG_ROTATION_ANGLE 旋转角度 

枚举值 

MV_IMAGE_ROTATE_90 90° 

MV_IMAGE_ROTATE_180 180° 

MV_IMAGE_ROTATE_270 270° 

◆ MV_IMG_FLIP_TYPE 

enum MV_IMG_FLIP_TYPE 

翻转类型 

枚举值 

MV_FLIP_VERTICAL 垂直翻转 

MV_FLIP_HORIZONTAL 水平翻转 

◆ MV_CC_GAMMA_TYPE 

enum MV_CC_GAMMA_TYPE 

Gamma 类型 

枚举值 

MV_CC_GAMMA_TYPE_NONE 不启用 

MV_CC_GAMMA_TYPE_VALUE Gamma 值

MV_CC_GAMMA_TYPE_USER_CURVE Gamma 曲线 

8位，长度： 256*sizeof(unsigned char) 10 位，长度： 1024*sizeof(unsigned short) 12 位，长度： 4096*sizeof(unsigned short) 16 位，长度： 65536*sizeof(unsigned short) 

MV_CC_GAMMA_TYPE_LRGB2SRGB linear RGB to sRGB 

MV_CC_GAMMA_TYPE_SRGB2LRGB sRGB to linear RGB （仅色彩插值时支持，色彩校 正时无效） ◆ MV_RECORD_FORMAT_TYPE 

enum MV_RECORD_FORMAT_TYPE 

录像格式定义 

枚举值 

MV_FormatType_Undefined 未定义的录像格式 

MV_FormatType_AVI AVI 录像格式 

◆ MV_CAM_ACQUISITION_MODE 

enum MV_CAM_ACQUISITION_MODE 

采集模式 

枚举值 

MV_ACQ_MODE_SINGLE 单帧模式 

MV_ACQ_MODE_MUTLI 多帧模式 

MV_ACQ_MODE_CONTINUOUS 持续采集模式 

◆ MV_CAM_GAIN_MODE 

enum MV_CAM_GAIN_MODE 

增益模式 

枚举值 

MV_GAIN_MODE_OFF 关闭 

MV_GAIN_MODE_ONCE 一次 

MV_GAIN_MODE_CONTINUOUS 连续 

◆ MV_CAM_EXPOSURE_MODE 

enum MV_CAM_EXPOSURE_MODE 曝光模式 

枚举值 

MV_EXPOSURE_MODE_TIMED 时间 

MV_EXPOSURE_MODE_TRIGGER_WIDTH 触发脉冲宽度 

◆ MV_CAM_EXPOSURE_AUTO_MODE 

enum MV_CAM_EXPOSURE_AUTO_MODE 

自动曝光模式 

枚举值 

MV_EXPOSURE_AUTO_MODE_OFF 关闭 

MV_EXPOSURE_AUTO_MODE_ONCE 一次 

MV_EXPOSURE_AUTO_MODE_CONTINUOUS 连续 

◆ MV_CAM_TRIGGER_MODE 

enum MV_CAM_TRIGGER_MODE 

触发模式 

枚举值 

MV_TRIGGER_MODE_OFF 关闭 

MV_TRIGGER_MODE_ON 打开 

◆ MV_CAM_GAMMA_SELECTOR 

enum MV_CAM_GAMMA_SELECTOR 

Gamma 选择器 

枚举值 

MV_GAMMA_SELECTOR_USER 用户 

MV_GAMMA_SELECTOR_SRGB sRGB ◆ MV_CAM_BALANCEWHITE_AUTO 

enum MV_CAM_BALANCEWHITE_AUTO 

白平衡 

枚举值 

MV_BALANCEWHITE_AUTO_OFF 关闭 

MV_BALANCEWHITE_AUTO_ONCE 一次 

MV_BALANCEWHITE_AUTO_CONTINUOUS 连续 

◆ MV_CAM_TRIGGER_SOURCE 

enum MV_CAM_TRIGGER_SOURCE 

触发源 

枚举值 

MV_TRIGGER_SOURCE_LINE0 Line0 

MV_TRIGGER_SOURCE_LINE1 Line1 

MV_TRIGGER_SOURCE_LINE2 Line2 

MV_TRIGGER_SOURCE_LINE3 Line3 

MV_TRIGGER_SOURCE_COUNTER0 Conuter0 

MV_TRIGGER_SOURCE_SOFTWARE 软触发 

MV_TRIGGER_SOURCE_FrequencyConverter 变频器 

◆ MV_CC_STREAM_EXCEPTION_TYPE 

enum MV_CC_STREAM_EXCEPTION_TYPE 

流异常类型 

枚举值 

MV_CC_STREAM_EXCEPTION_ABNORMAL_IMAGE 图像异常（图像长度不正确、数据包 内容解析异常和校验失败等），丢弃 该帧（可能原因：链路传输异常和设 备发包异常等） 

MV_CC_STREAM_EXCEPTION_LIST_OVERFLOW 缓存列表已满（没有及时取走图像） 

MV_CC_STREAM_EXCEPTION_LIST_EMPTY 缓存列表为空（取走图像后未及时将 图像缓存归还） 

MV_CC_STREAM_EXCEPTION_RECONNECTION 触发一次断流恢复（仅 U3V 支持） 

MV_CC_STREAM_EXCEPTION_DISCONNECTED 断流恢复失败 ,取流被中止（仅 U3V 

支持） 

MV_CC_STREAM_EXCEPTION_DEVICE 设备异常 ,取流被中止（仅 U3V 支持 ）

MV_CC_STREAM_EXCEPTION_PARTIAL_IMAGE 行高不足 ,丢弃残帧（线阵相机或者 采集卡配置了残帧丢弃模式，出图行 高不足时被 SDK 丢弃） 

◆ MV_GIGE_TRANSMISSION_TYPE 

enum MV_GIGE_TRANSMISSION_TYPE 

Gige 的传输类型 

> 枚举值

MV_GIGE_TRANSTYPE_UNICAST 表示单播（默认） 

MV_GIGE_TRANSTYPE_MULTICAST 表示组播 

MV_GIGE_TRANSTYPE_LIMITEDBROADCAST 表示局域网内广播，暂不支持 

MV_GIGE_TRANSTYPE_SUBNETBROADCAST 表示子网内广播，暂不支持 

MV_GIGE_TRANSTYPE_CAMERADEFINED 表示从设备获取，暂不支持 

MV_GIGE_TRANSTYPE_UNICAST_DEFINED_PORT 表示用户自定义应用端接收图像 数据 Port 号

MV_GIGE_TRANSTYPE_UNICAST_WITHOUT_RECV 表示设置了单播，但本实例不接 收图像数据 

MV_GIGE_TRANSTYPE_MULTICAST_WITHOUT_RECV 表示组播模式，但本实例不接收 图像数据 ◆ MV_SORT_METHOD 

enum MV_SORT_METHOD 

排序方式 

枚举值 

SortMethod_SerialNumber 按序列号排序 

SortMethod_UserID 按用户自定义名字排序 

SortMethod_CurrentIP_ASC 按当前 IP 地址排序（升序） 

SortMethod_CurrentIP_DESC 按当前 IP 地址排序（降序） 

◆ MV_XML_InterfaceType 

enum MV_XML_InterfaceType 

每个节点对应的接口类型 

枚举值 

IFT_IValue Value 

IFT_IBase Base 

IFT_IInteger Integer 

IFT_IBoolean Boolean 

IFT_ICommand Command 

IFT_IFloat Float 

IFT_IString String 

IFT_IRegister Register 

IFT_ICategory Category 

IFT_IEnumeration Enumeration 

IFT_IEnumEntry EnumEntry 

IFT_IPort Port ◆ MV_XML_AccessMode 

enum MV_XML_AccessMode 

节点的访问模式 

枚举值 

AM_NI 不可实现 

AM_NA 不可用 

AM_WO 只写 

AM_RO 只读 

AM_RW 读写 

AM_Undefined 未定义 

AM_CycleDetect 内部用于 AccessMode 循环检测 

◆ MVCC_NODE_ERR_TYPE 

enum MVCC_NODE_ERR_TYPE 

导入参数报错时的原因 

枚举值 

MVCC_NODE_ERR_NODE_INVALID 节点不存在 

MVCC_NODE_ERR_ACCESS 访问条件错误 ,通常是节点不可读写 

MVCC_NODE_ERR_OUT_RANGE 写入越界 ,超出该节点支持的范围 

MVCC_NODE_ERR_VERIFY_FAILD 校验失败 ,通常是写入的值与文件中的值不匹配 

MVCC_NODE_ERR_OTHER 其它错误 ,可查阅日志 

◆ MV_IMAGE_RECONSTRUCTION_METHOD 

enum MV_IMAGE_RECONSTRUCTION_METHOD 

图像重构方式 

枚举值 MV_SPLIT_BY_LINE 源图像按行拆分成多张图像 

◆ MvGvspPixelType 

enum MvGvspPixelType 

图片格式定义 

> 枚举值

PixelType_Gvsp_Undefined 未定义的像素类型 

PixelType_Gvsp_Mono1p Mono1p 

PixelType_Gvsp_Mono2p Mono2p 

PixelType_Gvsp_Mono4p Mono4p 

PixelType_Gvsp_Mono8 Mono8 

PixelType_Gvsp_Mono8_Signed Mono8_Signed 

PixelType_Gvsp_Mono10 Mono10 

PixelType_Gvsp_Mono10_Packed Mono10_Packed 

PixelType_Gvsp_Mono12 Mono12 

PixelType_Gvsp_Mono12_Packed Mono12_Packed 

PixelType_Gvsp_Mono14 Mono14 

PixelType_Gvsp_Mono16 Mono16 

PixelType_Gvsp_BayerGR8 BayerGR8 

PixelType_Gvsp_BayerRG8 BayerRG8 

PixelType_Gvsp_BayerGB8 BayerGB8 

PixelType_Gvsp_BayerBG8 BayerBG8 

PixelType_Gvsp_BayerRBGG8 BayerRBGG8 

PixelType_Gvsp_BayerGR10 BayerGR10 

PixelType_Gvsp_BayerRG10 BayerRG10 

PixelType_Gvsp_BayerGB10 BayerGB10 

PixelType_Gvsp_BayerBG10 BayerBG10 

PixelType_Gvsp_BayerGR12 BayerGR12 PixelType_Gvsp_BayerRG12 BayerRG12 

PixelType_Gvsp_BayerGB12 BayerGB12 

PixelType_Gvsp_BayerBG12 BayerBG12 

PixelType_Gvsp_BayerGR10_Packed BayerGR10_Packed 

PixelType_Gvsp_BayerRG10_Packed BayerRG10_Packed 

PixelType_Gvsp_BayerGB10_Packed BayerGB10_Packed 

PixelType_Gvsp_BayerBG10_Packed BayerBG10_Packed 

PixelType_Gvsp_BayerGR12_Packed BayerGR12_Packed 

PixelType_Gvsp_BayerRG12_Packed BayerRG12_Packed 

PixelType_Gvsp_BayerGB12_Packed BayerGB12_Packed 

PixelType_Gvsp_BayerBG12_Packed BayerBG12_Packed 

PixelType_Gvsp_BayerGR16 BayerGR16 

PixelType_Gvsp_BayerRG16 BayerRG16 

PixelType_Gvsp_BayerGB16 BayerGB16 

PixelType_Gvsp_BayerBG16 BayerBG16 

PixelType_Gvsp_RGB8_Packed RGB8_Packed 

PixelType_Gvsp_BGR8_Packed BGR8_Packed 

PixelType_Gvsp_RGBA8_Packed RGBA8_Packed 

PixelType_Gvsp_BGRA8_Packed BGRA8_Packed 

PixelType_Gvsp_RGB10_Packed RGB10_Packed 

PixelType_Gvsp_BGR10_Packed BGR10_Packed 

PixelType_Gvsp_RGB12_Packed RGB12_Packed 

PixelType_Gvsp_BGR12_Packed BGR12_Packed 

PixelType_Gvsp_RGB16_Packed RGB16_Packed 

PixelType_Gvsp_BGR16_Packed BGR16_Packed 

PixelType_Gvsp_RGBA16_Packed RGBA16_Packed 

PixelType_Gvsp_BGRA16_Packed BGRA16_Packed 

PixelType_Gvsp_RGB10V1_Packed RGB10V1_Packed PixelType_Gvsp_RGB10V2_Packed RGB10V2_Packed 

PixelType_Gvsp_RGB12V1_Packed RGB12V1_Packed 

PixelType_Gvsp_RGB565_Packed RGB565_Packed 

PixelType_Gvsp_BGR565_Packed BGR565_Packed 

PixelType_Gvsp_YUV411_Packed YUV411_Packed 

PixelType_Gvsp_YUV422_Packed YUV422_Packed 

PixelType_Gvsp_YUV422_YUYV_Packed YUV422_YUYV_Packed 

PixelType_Gvsp_YUV444_Packed YUV444_Packed 

PixelType_Gvsp_YCBCR8_CBYCR YCBCR8_CBYCR 

PixelType_Gvsp_YCBCR422_8 YCBCR422_8 

PixelType_Gvsp_YCBCR422_8_CBYCRY YCBCR422_8_CBYCRY 

PixelType_Gvsp_YCBCR411_8_CBYYCRYY YCBCR411_8_CBYYCRYY 

PixelType_Gvsp_YCBCR601_8_CBYCR YCBCR601_8_CBYCR 

PixelType_Gvsp_YCBCR601_422_8 YCBCR601_422_8 

PixelType_Gvsp_YCBCR601_422_8_CBYCRY YCBCR601_422_8_CBYCRY 

PixelType_Gvsp_YCBCR601_411_8_CBYYCRYY YCBCR601_411_8_CBYYCRYY 

PixelType_Gvsp_YCBCR709_8_CBYCR YCBCR709_8_CBYCR 

PixelType_Gvsp_YCBCR709_422_8 YCBCR709_422_8 

PixelType_Gvsp_YCBCR709_422_8_CBYCRY YCBCR709_422_8_CBYCRY 

PixelType_Gvsp_YCBCR709_411_8_CBYYCRYY YCBCR709_411_8_CBYYCRYY 

PixelType_Gvsp_YUV420SP_NV12 YUV420SP_NV12 

PixelType_Gvsp_YUV420SP_NV21 YUV420SP_NV21 

PixelType_Gvsp_RGB8_Planar RGB8_Planar 

PixelType_Gvsp_RGB10_Planar RGB10_Planar 

PixelType_Gvsp_RGB12_Planar RGB12_Planar 

PixelType_Gvsp_RGB16_Planar RGB16_Planar 

PixelType_Gvsp_Jpeg Jpeg 

PixelType_Gvsp_Coord3D_ABC32f Coord3D_ABC32f PixelType_Gvsp_Coord3D_ABC32f_Planar Coord3D_ABC32f_Planar 

PixelType_Gvsp_Coord3D_ABC32 Coord3D_ABC32 

PixelType_Gvsp_Coord3D_AB32f Coord3D_AB32f 

PixelType_Gvsp_Coord3D_AB32 Coord3D_AB32 

PixelType_Gvsp_Coord3D_AC32f_64 Coord3D_AC32f_64 

PixelType_Gvsp_Coord3D_AC32f_Planar Coord3D_AC32f_Planar 

PixelType_Gvsp_Coord3D_AC32 Coord3D_AC32 

PixelType_Gvsp_Coord3D_A32f Coord3D_A32f 

PixelType_Gvsp_Coord3D_A32 Coord3D_A32 

PixelType_Gvsp_Coord3D_C32f Coord3D_C32f 

PixelType_Gvsp_Coord3D_C32 Coord3D_C32 

PixelType_Gvsp_Coord3D_ABC16 Coord3D_ABC16 

PixelType_Gvsp_Coord3D_C16 Coord3D_C16 

PixelType_Gvsp_HB_Mono8 HB_Mono8 

PixelType_Gvsp_HB_Mono10 HB_Mono10 

PixelType_Gvsp_HB_Mono10_Packed HB_Mono10_Packed 

PixelType_Gvsp_HB_Mono12 HB_Mono12 

PixelType_Gvsp_HB_Mono12_Packed HB_Mono12_Packed 

PixelType_Gvsp_HB_Mono16 HB_Mono16 

PixelType_Gvsp_HB_BayerGR8 HB_BayerGR8 

PixelType_Gvsp_HB_BayerRG8 HB_BayerRG8 

PixelType_Gvsp_HB_BayerGB8 HB_BayerGB8 

PixelType_Gvsp_HB_BayerBG8 HB_BayerBG8 

PixelType_Gvsp_HB_BayerRBGG8 HB_BayerRBGG8 

PixelType_Gvsp_HB_BayerGR10 HB_BayerGR10 

PixelType_Gvsp_HB_BayerRG10 HB_BayerRG10 

PixelType_Gvsp_HB_BayerGB10 HB_BayerGB10 

PixelType_Gvsp_HB_BayerBG10 HB_BayerBG10 PixelType_Gvsp_HB_BayerGR12 HB_BayerGR12 

PixelType_Gvsp_HB_BayerRG12 HB_BayerRG12 

PixelType_Gvsp_HB_BayerGB12 HB_BayerGB12 

PixelType_Gvsp_HB_BayerBG12 HB_BayerBG12 

PixelType_Gvsp_HB_BayerGR10_Packed HB_BayerGR10_Packed 

PixelType_Gvsp_HB_BayerRG10_Packed HB_BayerRG10_Packed 

PixelType_Gvsp_HB_BayerGB10_Packed HB_BayerGB10_Packed 

PixelType_Gvsp_HB_BayerBG10_Packed HB_BayerBG10_Packed 

PixelType_Gvsp_HB_BayerGR12_Packed HB_BayerGR12_Packed 

PixelType_Gvsp_HB_BayerRG12_Packed HB_BayerRG12_Packed 

PixelType_Gvsp_HB_BayerGB12_Packed HB_BayerGB12_Packed 

PixelType_Gvsp_HB_BayerBG12_Packed HB_BayerBG12_Packed 

PixelType_Gvsp_HB_YUV422_Packed HB_YUV422_Packed 

PixelType_Gvsp_HB_YUV422_YUYV_Packed HB_YUV422_YUYV_Packed 

PixelType_Gvsp_HB_RGB8_Packed HB_RGB8_Packed 

PixelType_Gvsp_HB_BGR8_Packed HB_BGR8_Packed 

PixelType_Gvsp_HB_RGBA8_Packed HB_RGBA8_Packed 

PixelType_Gvsp_HB_BGRA8_Packed HB_BGRA8_Packed 

PixelType_Gvsp_HB_RGB16_Packed HB_RGB16_Packed 

PixelType_Gvsp_HB_BGR16_Packed HB_BGR16_Packed 

PixelType_Gvsp_HB_RGBA16_Packed HB_RGBA16_Packed 

PixelType_Gvsp_HB_BGRA16_Packed HB_BGRA16_Packed 

示例 

Recording.cpp .

◆ MV_SAVE_POINT_CLOUD_FILE_TYPE 

enum MV_SAVE_POINT_CLOUD_FILE_TYPE 

保存的 3D 数据格式（自 4.4.1 版本废弃） 枚举值 

MV_PointCloudFile_Undefined 未定义的点云格式 

MV_PointCloudFile_PLY PLY 点云格式 

MV_PointCloudFile_CSV CSV 点云格式 

MV_PointCloudFile_OBJ OBJ 点云格式 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 宏定义

# 宏定义 

包含一些常量定义 更多 ... 

# 宏定义 

#define MV_UNKNOW_DEVICE 0x00000000 

未知设备类型，保留意义 更多 ... 

#define MV_GIGE_DEVICE 0x00000001 

GigE 设备 更多 ... 

#define MV_1394_DEVICE 0x00000002 1394-a/b 设备 更多 ... 

#define MV_USB_DEVICE 0x00000004 

USB 设备 更多 ... 

#define MV_CAMERALINK_DEVICE 0x00000008 

CameraLink 设备（串口） 更多 ... 

#define MV_VIR_GIGE_DEVICE 0x00000010 

虚拟 GigE 设备 ,包含虚拟 GEV 采集卡下的设备 更多 ... 

#define MV_VIR_USB_DEVICE 0x00000020 

虚拟 USB 设备 ,不支持虚拟采集卡下的设备 更多 ... 

#define MV_GENTL_GIGE_DEVICE 0x00000040 

自研网卡下 GigE 设备 ,某些卡不支持此协议，如 GE1104 更多 ... 

#define MV_GENTL_CAMERALINK_DEVICE 0x00000080 

CameraLink 设备 更多 ... 

#define MV_GENTL_CXP_DEVICE 0x00000100 

CoaXPress 设备 更多 ... 

#define MV_GENTL_XOF_DEVICE 0x00000200 

XoF 设备 更多 ... 

#define MV_GENTL_VIR_DEVICE 0x00000800 

虚拟采集卡下的设备，不支持虚拟 GEV 采集卡下的设备。 更多 ... 

#define INFO_MAX_BUFFER_SIZE 64 

最大的数据信息大小 更多 ... 

#define MV_MAX_TLS_NUM 8

最多支持的传输层实例个数 更多 ... 

#define MV_MAX_DEVICE_NUM 256 

最大支持的设备个数 更多 ... 

#define MV_MAX_INTERFACE_NUM 64 最大支持的采集卡数量 更多 ... 

#define MV_MAX_GENTL_IF_NUM 256 

最大支持的 GenTL 接口数量 更多 ... 

#define MV_MAX_GENTL_DEV_NUM 256 

最大支持的 GenTL 设备数量 更多 ... 

#define MV_MAX_SERIAL_PORT_NUM 64 

最大支持的串口数量 更多 ... 

#define MV_MAX_NODE_NUM 256 

最大节点个数 更多 ... 

#define MV_MAX_NODE_NAME_LEN 64 

节点名称的最大长度 更多 ... 

#define MV_MAX_NODE_ERROR_NUM 64 

最大节点错误个数 更多 ... 

#define MV_GIGE_INTERFACE 0x00000001 

GigE Vision 采集卡 更多 ... 

#define MV_CAMERALINK_INTERFACE 0x00000004 

Camera Link 采集卡 更多 ... 

#define MV_CXP_INTERFACE 0x00000008 

CoaXPress 采集卡 更多 ... 

#define MV_XOF_INTERFACE 0x00000010 

XoFLink 采集卡 更多 ... 

#define MV_VIR_INTERFACE 0x00000020 

虚拟采集卡 更多 ... 

#define MV_LC_INTERFACE 0x00000040 

光源控制卡 更多 ... 

#define MV_ACCESS_Exclusive 1独占权限，其他 APP 只允许读 CCP 寄存器 更多 ... 

#define MV_ACCESS_ExclusiveWithSwitch 2

可以从 5模式下抢占权限，然后以独占权限打开 更多 ... 

#define MV_ACCESS_Control 3

控制权限，其他 APP 允许读所有寄存器 更多 ... 

#define MV_ACCESS_ControlWithSwitch 4

可以从 5模式下抢占权限，然后以控制权限打开 更多 ... 

#define MV_ACCESS_ControlSwitchEnable 5

以可被抢占的控制权限打开 更多 ... 

#define MV_ACCESS_ControlSwitchEnableWithKey 6

可以从 5模式下抢占权限，然后以可被抢占的控制权限打开 更多 ... 

#define MV_ACCESS_Monitor 7

读模式打开设备，适用于控制权限下 更多 ... 

#define MV_MATCH_TYPE_NET_DETECT 0x00000001 

网络流量和丢包信息 更多 ... 

#define MV_MATCH_TYPE_USB_DETECT 0x00000002 

host 接收到来自 U3V 设备的字节总数 更多 ... 

#define MV_IP_CFG_STATIC 0x05000000 

静态 更多 ... 

#define MV_IP_CFG_DHCP 0x06000000 

DHCP 更多 ... 

#define MV_IP_CFG_LLA 0x04000000 

LLA 更多 ... 

#define MV_NET_TRANS_DRIVER 0x00000001 

驱动 更多 ... 

#define MV_NET_TRANS_SOCKET 0x00000002 Socket 更多 ... 

#define MV_CAML_BAUDRATE_9600 0x00000001 

9600 更多 ... 

#define MV_CAML_BAUDRATE_19200 0x00000002 

19200 更多 ... 

#define MV_CAML_BAUDRATE_38400 0x00000004 

38400 更多 ... 

#define MV_CAML_BAUDRATE_57600 0x00000008 

57600 更多 ... 

#define MV_CAML_BAUDRATE_115200 0x00000010 

115200 更多 ... 

#define MV_CAML_BAUDRATE_230400 0x00000020 

230400 更多 ... 

#define MV_CAML_BAUDRATE_460800 0x00000040 

460800 更多 ... 

#define MV_CAML_BAUDRATE_921600 0x00000080 

921600 更多 ... 

#define MV_CAML_BAUDRATE_AUTOMAX 0x40000000 

最大值 更多 ... 

#define MV_EXCEPTION_DEV_DISCONNECT 0x00008001 

设备断开连接 更多 ... 

#define MV_EXCEPTION_VERSION_CHECK 0x00008002 

SDK 与驱动版本不匹配 更多 ... 

#define MAX_EVENT_NAME_SIZE 128 

设备 Event 事件名称最大长度 更多 ... 

#define MV_MAX_XML_SYMBOLIC_NUM 64 最大 XML 符号数 更多 ... 

#define MV_MAX_SYMBOLIC_LEN 64 

最大枚举条目对应的符号长度 更多 ... 

#define MV_MAX_SPLIT_NUM 8

分时曝光时最多将源图像拆分的个数 更多 ... 

#define MV_MAX_ENUM_SYMBOLIC_NUM 256 

最大枚举条目对应的符号数量 更多 ... 

#define MV_GVSP_PIX_MONO 0x01000000 

Mono 格式 更多 ... 

#define MV_GVSP_PIX_RGB 0x02000000 

RGB 格式 更多 ... 

#define MV_GVSP_PIX_COLOR 0x02000000 

COLOR 格式 更多 ... 

#define MV_GVSP_PIX_CUSTOM 0x80000000 

CUSTOM 格式 更多 ... 

#define MV_GVSP_PIX_COLOR_MASK 0xFF000000 

COLOR_MASK 格式 更多 ... 

#define MV_PIXEL_BIT_COUNT (n) ((n) << 16) 

像素占用的有效位数，可用来计算存储图像所需的内存量 更多 ... 

# 详细描述 

包含一些常量定义 

# 宏定义说明 ◆ MV_UNKNOW_DEVICE 

#define MV_UNKNOW_DEVICE 0x00000000 

未知设备类型，保留意义 

◆ MV_GIGE_DEVICE 

#define MV_GIGE_DEVICE 0x00000001 

GigE 设备 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , Events_Interface.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ MV_1394_DEVICE 

#define MV_1394_DEVICE 0x00000002 

1394-a/b 设备 

◆ MV_USB_DEVICE 

#define MV_USB_DEVICE 0x00000004 

USB 设备 

示例 ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_Asynchronous.cpp ,

Grab_Callback.cpp , GrabImage.cpp , GrabImage_Display.cpp ,

GrabStrategies.cpp , HighBandwidthDecode.cpp , ImageContrast.cpp ,

ImageSave.cpp , InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

◆ MV_CAMERALINK_DEVICE 

#define MV_CAMERALINK_DEVICE 0x00000008 

CameraLink 设备（串口） 

◆ MV_VIR_GIGE_DEVICE 

#define MV_VIR_GIGE_DEVICE 0x00000010 

虚拟 GigE 设备 ,包含虚拟 GEV 采集卡下的设备 

◆ MV_VIR_USB_DEVICE 

#define MV_VIR_USB_DEVICE 0x00000020 

虚拟 USB 设备 ,不支持虚拟采集卡下的设备 

◆ MV_GENTL_GIGE_DEVICE 

#define MV_GENTL_GIGE_DEVICE 0x00000040 

自研网卡下 GigE 设备 ,某些卡不支持此协议，如 GE1104 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ MV_GENTL_CAMERALINK_DEVICE 

#define MV_GENTL_CAMERALINK_DEVICE 0x00000080 

CameraLink 设备 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , 以及 Recording.cpp .

◆ MV_GENTL_CXP_DEVICE 

#define MV_GENTL_CXP_DEVICE 0x00000100 

CoaXPress 设备 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .◆ MV_GENTL_XOF_DEVICE 

#define MV_GENTL_XOF_DEVICE 0x00000200 

XoF 设备 

示例 

ChunkData.cpp , ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

InterfaceAndDeviceDemo.cpp , LensShadingCorrection.cpp ,

LineScanSoftwareTrigger.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_GENTL_VIR_DEVICE 

#define MV_GENTL_VIR_DEVICE 0x00000800 

虚拟采集卡下的设备，不支持虚拟 GEV 采集卡下的设备。 

◆ INFO_MAX_BUFFER_SIZE 

#define INFO_MAX_BUFFER_SIZE 64 

最大的数据信息大小 

◆ MV_MAX_TLS_NUM 

#define MV_MAX_TLS_NUM 8

最多支持的传输层实例个数 

◆ MV_MAX_DEVICE_NUM 

#define MV_MAX_DEVICE_NUM 256 最大支持的设备个数 

示例 

QuickSoftwareTrigger.cpp .

◆ MV_MAX_INTERFACE_NUM 

#define MV_MAX_INTERFACE_NUM 64 

最大支持的采集卡数量 

◆ MV_MAX_GENTL_IF_NUM 

#define MV_MAX_GENTL_IF_NUM 256 

最大支持的 GenTL 接口数量 

◆ MV_MAX_GENTL_DEV_NUM 

#define MV_MAX_GENTL_DEV_NUM 256 

最大支持的 GenTL 设备数量 

◆ MV_MAX_SERIAL_PORT_NUM 

#define MV_MAX_SERIAL_PORT_NUM 64 

最大支持的串口数量 

◆ MV_MAX_NODE_NUM 

#define MV_MAX_NODE_NUM 256 

最大节点个数 

◆ MV_MAX_NODE_NAME_LEN #define MV_MAX_NODE_NAME_LEN 64 

节点名称的最大长度 

◆ MV_MAX_NODE_ERROR_NUM 

#define MV_MAX_NODE_ERROR_NUM 64 

最大节点错误个数 

◆ MV_GIGE_INTERFACE 

#define MV_GIGE_INTERFACE 0x00000001 

GigE Vision 采集卡 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CAMERALINK_INTERFACE 

#define MV_CAMERALINK_INTERFACE 0x00000004 

Camera Link 采集卡 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , 以及 InterfaceDemo.cpp .

◆ MV_CXP_INTERFACE 

#define MV_CXP_INTERFACE 0x00000008 

CoaXPress 采集卡 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp , 以及 

QuickSoftwareTrigger.cpp .◆ MV_XOF_INTERFACE 

#define MV_XOF_INTERFACE 0x00000010 

XoFLink 采集卡 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , InterfaceDemo.cpp , 以及 

QuickSoftwareTrigger.cpp .

◆ MV_VIR_INTERFACE 

#define MV_VIR_INTERFACE 0x00000020 

虚拟采集卡 

◆ MV_LC_INTERFACE 

#define MV_LC_INTERFACE 0x00000040 

光源控制卡 

示例 

ConfigLightController.cpp .

◆ MV_ACCESS_Exclusive 

#define MV_ACCESS_Exclusive 1

独占权限，其他 APP 只允许读 CCP 寄存器 

示例 

DynamicallyLoadDLL.cpp , 以及 ForceIPEx.cpp .

◆ MV_ACCESS_ExclusiveWithSwitch 

#define MV_ACCESS_ExclusiveWithSwitch 2

可以从 5模式下抢占权限，然后以独占权限打开 ◆ MV_ACCESS_Control 

#define MV_ACCESS_Control 3

控制权限，其他 APP 允许读所有寄存器 

示例 

MultiCast.cpp .

◆ MV_ACCESS_ControlWithSwitch 

#define MV_ACCESS_ControlWithSwitch 4

可以从 5模式下抢占权限，然后以控制权限打开 

◆ MV_ACCESS_ControlSwitchEnable 

#define MV_ACCESS_ControlSwitchEnable 5

以可被抢占的控制权限打开 

◆ MV_ACCESS_ControlSwitchEnableWithKey 

#define MV_ACCESS_ControlSwitchEnableWithKey 6

可以从 5模式下抢占权限，然后以可被抢占的控制权限打开 

◆ MV_ACCESS_Monitor 

#define MV_ACCESS_Monitor 7

读模式打开设备，适用于控制权限下 

示例 

MultiCast.cpp .

◆ MV_MATCH_TYPE_NET_DETECT #define MV_MATCH_TYPE_NET_DETECT 0x00000001 

网络流量和丢包信息 

◆ MV_MATCH_TYPE_USB_DETECT 

#define MV_MATCH_TYPE_USB_DETECT 0x00000002 

host 接收到来自 U3V 设备的字节总数 

◆ MV_IP_CFG_STATIC 

#define MV_IP_CFG_STATIC 0x05000000 

静态 

示例 

ForceIPEx.cpp .

◆ MV_IP_CFG_DHCP 

#define MV_IP_CFG_DHCP 0x06000000 

DHCP 

◆ MV_IP_CFG_LLA 

#define MV_IP_CFG_LLA 0x04000000 

LLA 

◆ MV_NET_TRANS_DRIVER 

#define MV_NET_TRANS_DRIVER 0x00000001 

驱动 ◆ MV_NET_TRANS_SOCKET 

#define MV_NET_TRANS_SOCKET 0x00000002 

Socket 

◆ MV_CAML_BAUDRATE_9600 

#define MV_CAML_BAUDRATE_9600 0x00000001 

9600 

◆ MV_CAML_BAUDRATE_19200 

#define MV_CAML_BAUDRATE_19200 0x00000002 

19200 

◆ MV_CAML_BAUDRATE_38400 

#define MV_CAML_BAUDRATE_38400 0x00000004 

38400 

◆ MV_CAML_BAUDRATE_57600 

#define MV_CAML_BAUDRATE_57600 0x00000008 

57600 

◆ MV_CAML_BAUDRATE_115200 

#define MV_CAML_BAUDRATE_115200 0x00000010 

115200 ◆ MV_CAML_BAUDRATE_230400 

#define MV_CAML_BAUDRATE_230400 0x00000020 

230400 

◆ MV_CAML_BAUDRATE_460800 

#define MV_CAML_BAUDRATE_460800 0x00000040 

460800 

◆ MV_CAML_BAUDRATE_921600 

#define MV_CAML_BAUDRATE_921600 0x00000080 

921600 

◆ MV_CAML_BAUDRATE_AUTOMAX 

#define MV_CAML_BAUDRATE_AUTOMAX 0x40000000 

最大值 

◆ MV_EXCEPTION_DEV_DISCONNECT 

#define MV_EXCEPTION_DEV_DISCONNECT 0x00008001 

设备断开连接 

◆ MV_EXCEPTION_VERSION_CHECK 

#define MV_EXCEPTION_VERSION_CHECK 0x00008002 

SDK 与驱动版本不匹配 ◆ MAX_EVENT_NAME_SIZE 

#define MAX_EVENT_NAME_SIZE 128 

设备 Event 事件名称最大长度 

◆ MV_MAX_XML_SYMBOLIC_NUM 

#define MV_MAX_XML_SYMBOLIC_NUM 64 

最大 XML 符号数 

◆ MV_MAX_SYMBOLIC_LEN 

#define MV_MAX_SYMBOLIC_LEN 64 

最大枚举条目对应的符号长度 

◆ MV_MAX_SPLIT_NUM 

#define MV_MAX_SPLIT_NUM 8

分时曝光时最多将源图像拆分的个数 

◆ MV_MAX_ENUM_SYMBOLIC_NUM 

#define MV_MAX_ENUM_SYMBOLIC_NUM 256 

最大枚举条目对应的符号数量 

◆ MV_GVSP_PIX_MONO 

#define MV_GVSP_PIX_MONO 0x01000000 

Mono 格式 ◆ MV_GVSP_PIX_RGB 

#define MV_GVSP_PIX_RGB 0x02000000 

RGB 格式 

◆ MV_GVSP_PIX_COLOR 

#define MV_GVSP_PIX_COLOR 0x02000000 

COLOR 格式 

◆ MV_GVSP_PIX_CUSTOM 

#define MV_GVSP_PIX_CUSTOM 0x80000000 

CUSTOM 格式 

◆ MV_GVSP_PIX_COLOR_MASK 

#define MV_GVSP_PIX_COLOR_MASK 0xFF000000 

COLOR_MASK 格式 

◆ MV_PIXEL_BIT_COUNT 

#define MV_PIXEL_BIT_COUNT ( n ) ((n) << 16) 

像素占用的有效位数，可用来计算存储图像所需的内存量 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 函数

# 废弃接口 

废弃原因：新开发的万能接口代替了具体节点的设置、获取参数功能；效率低的接口由新的接口替 代；实际开发中部分接口使用频率较低。 更多 ... 

# 函数 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageInfo (IN void * handle , IN OUT MV_IMAGE_BASIC_INFO *pstInfo) 

获取图像基本信息 更多 ... 

MV_CAMCTRL_API void *__stdcall MV_CC_GetTlProxy (IN void * handle )

获取 GenICam 代理 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_GetRootNode (IN void * handle , IN OUT MV_XML_NODE_FEATURE *pstNode) 

获取根节点 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_GetChildren (IN void * handle , IN MV_XML_NODE_FEATURE *pstNode, IN OUT MV_XML_NODES_LIST *pstNodesList) 

从xml 中获取指定节点的所有子节点，根节点为 Root 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_GetNodeFeature (IN void * handle , IN MV_XML_NODE_FEATURE *pstNode, IN OUT void *pstFeature) 

获得当前节点的属性 更多 ... MV_CAMCTRL_API int __stdcall MV_XML_UpdateNodeFeature (IN void * handle , IN enum 

MV_XML_InterfaceType enType, IN void *pstFeature) 

更新节点 更多 ... 

MV_CAMCTRL_API int __stdcall MV_XML_RegisterUpdateCallBack (IN void * handle , IN void(__stdcall *cbUpdate)(enum MV_XML_InterfaceType 

enType, void *pstFeature, MV_XML_NODES_LIST *pstNodesList, void *pUser), IN void *pUser) 

注册更新回调 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrame (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO *pFrameInfo) 

获取一帧图像（该接口已弃用，建议改用 

MV_CC_GetOneFrameTimeout() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameEx (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pFrameInfo) 

获取一帧 trunck 数据（该接口已弃用，建议改用 

MV_CC_GetOneFrameTimeout() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBack (void * handle ,void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO *pFrameInfo, void *pUser), void *pUser) 

注册图像数据回调（该接口已弃用，建议改用 

MV_CC_RegisterImageCallBackEx() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx (IN OUT MV_SAVE_IMAGE_PARAM_EX *pSaveParam) 

保存图片，支持 Bmp 和Jpeg ，编码质量在 50-99 之前 （该接 口已弃用，建议改用 MV_CC_SaveImageEx3() 接口） 更多... 

MV_CAMCTRL_API int __stdcall MV_CC_BayerNoiseEstimate (IN void * handle , IN OUT MV_CC_BAYER_NOISE_ESTIMATE_PARAM *pstNoiseEstimateParam) Bayer 噪声估计 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_BayerSpatialDenoise (IN void * handle , IN OUT MV_CC_BAYER_SPATIAL_DENOISE_PARAM *pstSpatialDenoiseParam) 

Bayer 空域降噪 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCLUTParam (IN void * handle , IN MV_CC_CLUT_PARAM *pstCLUTParam) 

设置 Bayer 格式的 CLUT 使能和信息 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ImageSharpen (IN void * handle , IN OUT 

MV_CC_SHARPEN_PARAM *pstSharpenParam) 

图像锐化 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ColorCorrect (IN void * handle , IN OUT MV_CC_COLOR_CORRECT_PARAM *pstColorCorrectParam) 

色彩校正（包括 CCM 和CLUT ） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_NoiseEstimate (IN void * handle , IN OUT 

MV_CC_NOISE_ESTIMATE_PARAM 

*pstNoiseEstimateParam) 

噪声估计 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SpatialDenoise (IN void * handle , IN OUT MV_CC_SPATIAL_DENOISE_PARAM *pstSpatialDenoiseParam) 

空域降噪 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_LSCCalib (IN void * handle , IN OUT 

MV_CC_LSC_CALIB_PARAM *pstLSCCalibParam) 

LSC 标定 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_LSCCorrect (IN void * handle , IN OUT 

MV_CC_LSC_CORRECT_PARAM *pstLSCCorrectParam) 

LSC 校正 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_ForceIp (IN void * handle , unsigned int nIP) 强制 IP （该接口已弃用，建议改用 MV_GIGE_ForceIpEx() 

接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterEventCallBack (void * handle ,void(__stdcall *cbEvent)(unsigned int nExternalEventId, void *pUser), void *pUser) 

注册事件回调（该接口已弃用，建议改用 

MV_CC_RegisterEventCallBackEx() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_Display (IN void * handle , void *hWnd) 

显示图像，注册显示窗口，内部自动显示（该接口已弃用， 建议改用 MV_CC_DisplayOneFrameEx() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetIntValue (IN void * handle , IN const char *strKey, OUT MVCC_INTVALUE *pIntValue) 

获取 Integer 属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetIntValue (IN void * handle , IN const char *strKey, IN unsigned int nValue) 

设置 Integer 型属性值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetWidth (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取图像宽度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetWidth (IN void * handle , IN const unsigned int nValue) 

设置图像宽度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetHeight (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取图像高度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetHeight (IN void * handle , IN const unsigned int nValue) 

设置图像高度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetX (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 获取图像 X偏移 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetX (IN void * handle , IN const unsigned int nValue) 

设置图像 AOI 偏移 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetY (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取图像 Y偏移 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetY (IN void * handle , IN const unsigned int nValue) 

设置图像 AOI 偏移 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeLower (IN void * handle ,IN OUT MVCC_INTVALUE *pstValue) 

获取曝光下限 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeLower (IN void * handle ,IN const unsigned int nValue) 

设置曝光值下限 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeUpper (IN void * handle ,IN OUT MVCC_INTVALUE *pstValue) 

获取曝光上限 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeUpper (IN void * handle ,IN const unsigned int nValue) 

设置曝光值上限 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBrightness (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取亮度值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBrightness (IN void * handle , IN const unsigned int nValue) 

设置亮度值 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_GetFrameRate (IN void * handle , IN OUT 

MVCC_FLOATVALUE *pstValue) 

获取帧率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetFrameRate (IN void * handle , IN const float fValue) 

设置帧率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetGain (IN void * handle , IN OUT 

MVCC_FLOATVALUE *pstValue) 

获取增益 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGain (IN void * handle , IN const float fValue) 

设置增益 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetExposureTime (IN void * handle , IN OUT 

MVCC_FLOATVALUE *pstValue) 

获取曝光时间 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetExposureTime (IN void * handle , IN const float fValue) 

设置曝光时间 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetPixelFormat (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取像素格式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetPixelFormat (IN void * handle , IN const unsigned int nValue) 

设置像素格式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionMode (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取采集模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionMode (IN void * handle , IN const unsigned int nValue) 

设置像素格式 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_GetGainMode (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取增益模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGainMode (IN void * handle , IN const unsigned int nValue) 

设置增益模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetExposureAutoMode (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取自动曝光模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetExposureAutoMode (IN void * handle , IN const unsigned int nValue) 

设置自动曝光模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerMode (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取触发模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerMode (IN void * handle , IN const unsigned int nValue) 

设置触发模式 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerDelay (IN void * handle , IN OUT 

MVCC_FLOATVALUE *pstValue) 

获取触发延时 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerDelay (IN void * handle , IN const float fValue) 

设置触发延时 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerSource (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取触发源 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerSource (IN void * handle , IN const unsigned int nValue) 

设置触发源 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_TriggerSoftwareExecute (IN void * handle )

软触发一次（接口仅在已选择的触发源为软件触发时有效） 

更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetGammaSelector (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取 Gamma 类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGammaSelector (IN void * handle , IN const unsigned int nValue) 

设置 Gamma 类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetGamma (IN void * handle , IN OUT 

MVCC_FLOATVALUE *pstValue) 

获取 Gamma 值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetGamma (IN void * handle , IN const float fValue) 

设置 Gamma 值 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetSharpness (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取锐度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetSharpness (IN void * handle , IN const unsigned int nValue) 

设置锐度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetHue (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取灰度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetHue (IN void * handle , IN const unsigned int nValue) 

设置灰度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetSaturation (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 获取饱和度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetSaturation (IN void * handle , IN const unsigned int nValue) 

设置饱和度 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceWhiteAuto (IN void * handle , IN OUT 

MVCC_ENUMVALUE *pstValue) 

获取自动白平衡 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceWhiteAuto (IN void * handle , IN const unsigned int nValue) 

设置自动白平衡 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioRed (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取白平衡 红 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioRed (IN void * handle , IN const unsigned int nValue) 

设置白平衡 红 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioGreen (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取白平衡 绿 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioGreen (IN void * handle , IN const unsigned int nValue) 

设置白平衡 绿 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioBlue (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取白平衡 蓝 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioBlue (IN void * handle , IN const unsigned int nValue) 

设置白平衡 蓝 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_GetFrameSpecInfoAbility (IN void * handle , IN OUT MVCC_INTVALUE *pstValue) 

获取水印信息内包含的信息类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetFrameSpecInfoAbility (IN void * handle , IN const unsigned int nValue) 

设置水印信息内包含的信息类型 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceUserID (IN void * handle , IN OUT 

MVCC_STRINGVALUE *pstValue) 

获取设备自定义名字 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetDeviceUserID (IN void * handle , IN const char *chValue) 

设置设备自定义名字 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetBurstFrameCount (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取一次触发的帧数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetBurstFrameCount (IN void * handle , IN const unsigned int nValue) 

设置一次触发的帧数 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionLineRate (IN void * handle , IN OUT MVCC_INTVALUE *pstValue) 

获取行频 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionLineRate (IN void * handle , IN const unsigned int nValue) 

设置行频 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetHeartBeatTimeout (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取心跳信息 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetHeartBeatTimeout (IN void * handle , IN const unsigned int nValue) 

设置心跳信息 更多 ... MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPSPacketSize (IN void * handle , IN OUT MVCC_INTVALUE *pstValue) 

获取网络包大小 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPSPacketSize (IN void * handle , IN const unsigned int nValue) 

设置网络包大小 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPD (IN void * handle , IN OUT 

MVCC_INTVALUE *pstValue) 

获取网络包发送间隔 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPD (IN void * handle , IN const unsigned int nValue) 

设置网络包发送间隔 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCDA (IN void * handle , unsigned int *pnIP) 

获取接收端 IP 地址， 0xa9fe0102 表示 169.254.1.2 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCDA (IN void * handle , unsigned int nIP) 

设置接收端 IP 地址 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCSP (IN void * handle , unsigned int *pnPort) 

获取发送端的端口号 更多 ... 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCSP (IN void * handle , unsigned int nPort) 

设置发送端的端口号 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_SetDeviceBauderate (IN void * handle ,unsigned int nBaudrate) 

设置设备波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_GetDeviceBauderate (IN void * handle ,unsigned int *pnCurrentBaudrate) 获取设备波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSupportBauderates (IN void * handle ,unsigned int *pnBaudrateAblity) 

获取设备与主机间连接支持的波特率 更多 ... 

MV_CAMCTRL_API int __stdcall MV_USB_RegisterStreamExceptionCallBack (IN void *handle , IN void(__stdcall *cbException)( MV_CC_STREAM_EXCEPTION_TYPE 

enExceptionType, void *pUser), IN void *pUser) 

注册流异常消息回调，在打开设备之后调用（只支持 U3V 相机，不支持 GenTL 设备） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx2 (IN void * handle ,MV_SAVE_IMAGE_PARAM_EX *pstSaveParam) 

保存图片，支持 Bmp 和Jpeg ，编码质量在 50-99 之前（该接 口已弃用，建议改用 MV_CC_SaveImageEx3() 接口） 更多... 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFile (IN void * handle ,MV_SAVE_IMG_TO_FILE_PARAM *pstSaveFileParam) 

保存图像到文件（该接口已弃用，建议改用 

MV_CC_SaveImageToFileEx() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_ConvertPixelType (IN void * handle , IN OUT MV_CC_PIXEL_CONVERT_PARAM *pstCvtParam) 

像素格式转换（该接口已弃用，建议改用 

MV_CC_ConvertPixelTypeEx() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SetSDKLogPath (IN const char *strSDKLogPath) 

设置 SDK 日志路径 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrame (IN void * handle , IN 

MV_DISPLAY_FRAME_INFO *pstDisplayInfo) 

显示一帧图像（该接口已启用，建议改用 

MV_CC_DisplayOneFrameEx2() 接口） 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_EnumerateTls () 

获取支持的传输层 更多 ... MV_CAMCTRL_API int __stdcall MV_CC_CreateHandleWithoutLog (IN OUT void ** handle ,IN const MV_CC_DEVICE_INFO *pstDevInfo) 

创建设备句柄，不生成日志 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackForRGB (IN void *handle , IN void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), IN void *pUser) 

注册图像数据回调， RGB 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImageCallBackForBGR (IN void *handle , IN void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), IN void *pUser) 

注册图像数据回调， BGR 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageForRGB (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pstFrameInfo, IN int nMsec) 

获取一帧 RGB 数据，此函数为查询式获取，每次调用查询 内部 缓存有无数据，有数据则获取数据，无数据返回错误 码 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageForBGR (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pstFrameInfo, IN int nMsec) 

获取一帧 BGR 数据，此函数为查询式获取，每次调用查询 内部 缓存有无数据，有数据则获取数据，无数据返回错误 码 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_OpenParamsGUI (IN void * handle )

打开获取或设置相机参数的 GUI 界面 更多 ... 

MV_CAMCTRL_API int __stdcall MV_CC_SavePointCloudData (IN void * handle , IN OUT 

MV_SAVE_POINT_CLOUD_PARAM *pstPointDataParam) 

保存 3D 点云数据，支持 PLY 、CSV 和OBJ 三种格式 更多 ... 详细描述 

废弃原因：新开发的万能接口代替了具体节点的设置、获取参数功能；效率低的接口由新的接口替 代；实际开发中部分接口使用频率较低。 

# 函数说明 

◆ MV_CC_GetImageInfo() 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageInfo ( IN void * handle, 

IN OUT MV_IMAGE_BASIC_INFO * pstInfo 

)

获取图像基本信息 

参数 

handle [IN] 相机句柄 

pstInfo [IN][OUT] 返回给调用者有关相机图像基本信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_GetTlProxy() 

MV_CAMCTRL_API void* __stdcall MV_CC_GetTlProxy ( IN void * handle )

获取 GenICam 代理 

参数 

handle [IN] 句柄地址 

返回 

GenICam 代理类指针 ，正常返回值非 NULL ；异常返回 NULL 

◆ MV_XML_GetRootNode() MV_CAMCTRL_API int __stdcall MV_XML_GetRootNode ( IN void * handle, 

IN OUT MV_XML_NODE_FEATURE * pstNode 

)

获取根节点 

参数 

handle [IN] 句柄 

pstNode [OUT] 根节点信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_XML_GetChildren() 

MV_CAMCTRL_API int __stdcall MV_XML_GetChildren ( IN void * handle, 

IN MV_XML_NODE_FEATURE * pstNode, 

IN OUT MV_XML_NODES_LIST * pstNodesList 

)

从xml 中获取指定节点的所有子节点，根节点为 Root 

参数 

handle [IN] 句柄 

pstNode [IN] 根节点信息结构体 

pstNodesList [OUT] 节点列表结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_XML_GetNodeFeature() 

MV_CAMCTRL_API int __stdcall MV_XML_GetNodeFeature ( IN void * handle, 

IN MV_XML_NODE_FEATURE * pstNode, 

IN OUT void * pstFeature )

获得当前节点的属性 

参数 

handle [IN] 句柄 

pstNode [IN] 根节点信息结构体 

pstFeature [OUT] 当前节点属性结构体， pstFeature 具体结构体内容参考 

MV_XML_FEATURE_x 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_XML_UpdateNodeFeature() 

MV_CAMCTRL_API int __stdcall MV_XML_UpdateNodeFeature ( IN void * handle, 

IN enum MV_XML_InterfaceType enType, 

IN void * pstFeature 

)

更新节点 

参数 

handle [IN] 句柄 

enType [IN] 节点类型 

pstFeature [OUT] 当前节点属性结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_XML_RegisterUpdateCallBack() 

MV_CAMCTRL_A PI int __stdcall MV_XML_Registe rUpdateCallBack (

IN void * handle, 

IN 

void__stdcall *cbUpdate)(enum MV_XML_InterfaceType enType, void *pstFeature, MV_XML_NODES_LIST *pstNodesList, void *pUser, IN void * pUser 

)

注册更新回调 

参数 

handle [IN] 句柄 

cbUpdate [IN] 回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_GetOneFrame() 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrame ( IN void * handle, 

IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT MV_FRAME_OUT_INFO * pFrameInfo 

)

获取一帧图像（该接口已弃用，建议改用 MV_CC_GetOneFrameTimeout() 接口） 

参数 

handle [IN] 句柄 

pData [OUT] 图像数据接收指针 

nDataSize [IN] 接收缓存大小 

pFrameInfo [OUT] 图像信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则范围数据，无数据返 回状态码 ◆ MV_CC_GetOneFrameEx() 

MV_CAMCTRL_API int __stdcall MV_CC_GetOneFrameEx ( IN void * handle, 

IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT MV_FRAME_OUT_INFO_EX * pFrameInfo 

)

获取一帧 trunck 数据（该接口已弃用，建议改用 MV_CC_GetOneFrameTimeout() 接口） 

参数 

handle [IN] 句柄 

pData [OUT] 图像数据接收指针 

nDataSize [IN] 接收缓存大小 

pFrameInfo [OUT] 图像信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

此函数为查询式获取，每次调用查询内部缓存有无数据，有数据则范围数据，无数据返 回状态码 

◆ MV_CC_RegisterImageCallBack() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterIma geCallBack ( void * 

han dle, 

void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO *pFrameInfo, void *pUser) ,

void * 

pUs er 

)

注册图像数据回调（该接口已弃用，建议改用 MV_CC_RegisterImageCallBackEx() 接口） 参数 

handle [IN] 句柄 

cbOutput [IN] 回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_SaveImageEx() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx ( IN OUT MV_SAVE_IMAGE_PARAM_EX * pSaveParam )

保存图片，支持 Bmp 和Jpeg ，编码质量在 50-99 之前 （该接口已弃用，建议改用 

MV_CC_SaveImageEx3() 接口） 

参数 

pSaveParam [IN][OUT] 保存图片参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_BayerNoiseEstimate() 

MV_CAMCTRL_API int __stdcall MV_CC_BayerNoiseEsti mate ( IN void * handle, 

IN OUT MV_CC_BAYER_NOISE_ESTIMATE_PARAM *

pstNoiseEstimatePa ram 

)

Bayer 噪声估计 

参数 

handle [IN] 设备句柄 

pstNoiseEstimateParam [IN][OUT] Bayer 噪声估计参数结构体 

返回 成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口只支持 Bayer 格式，不支持 Bayerxx_Packed ；以相机实际支持为准。 

◆ MV_CC_BayerSpatialDenoise() 

MV_CAMCTRL_API int __stdcall MV_CC_BayerSpatialDe noise ( IN void * handle, 

IN OUT MV_CC_BAYER_SPATIAL_DENOISE_PARAM *

pstSpatialDenoisePa ram 

)

Bayer 空域降噪 

参数 

handle [IN] 设备句柄 

pstSpatialDenoiseParam [IN][OUT] Bayer 空域降噪参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口只支持 Bayer 格式，不支持 Bayerxx_Packed ；以相机实际支持为准。 

◆ MV_CC_SetBayerCLUTParam() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBayerCLUTParam ( IN void * handle, 

IN MV_CC_CLUT_PARAM * pstCLUTParam 

)

设置 Bayer 格式的 CLUT 使能和信息 

参数 

handle [IN] 设备句柄 pstCLUTParam [IN] CLUT 参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

• 开启 CLUT 并设置 CLUT 信息后，在调用 MV_CC_ConvertPixelType() 、

MV_CC_SaveImageEx2() 接口将 Bayer8/10/12/16 格式转成 RGB24/48 ， RGBA32/64 

，BGR24/48 ，BGRA32/64 时起效。 

• 以相机实际支持为准。 

◆ MV_CC_ImageSharpen() 

MV_CAMCTRL_API int __stdcall MV_CC_ImageSharpen ( IN void * handle, 

IN OUT MV_CC_SHARPEN_PARAM * pstSharpenParam 

)

图像锐化 

参数 

handle [IN] 设备句柄 

pstSharpenParam [IN] 锐化参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

以相机实际支持为准。 

◆ MV_CC_ColorCorrect() 

MV_CAMCTRL_API int __stdcall MV_CC_ColorCorrect ( IN void * handle, 

IN OUT MV_CC_COLOR_CORRECT_PARAM * pstColorCorrectParam 

)

色彩校正（包括 CCM 和CLUT ）参数 

handle [IN] 设备句柄 

pstColorCorrectParam [IN] 色彩校正参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

• 该接口支持单独 CCM 或者 CLUT ，也支持同时进行 CCM 和CLUT ，用户可以通过 CCM 

和CLUT 信息中的使能开关进行选择。 

• 以相机实际支持为准。 

◆ MV_CC_NoiseEstimate() 

MV_CAMCTRL_API int __stdcall MV_CC_NoiseEstimat e ( IN void * handle, 

IN OUT MV_CC_NOISE_ESTIMATE_PARAM 

*

pstNoiseEstimatePara m

)

噪声估计 

参数 

handle [IN] 设备句柄 

pstNoiseEstimateParam [IN] 噪声估计参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

• 如果用户选择全图做噪声估计， nROINum 可输入 0，pstROIRect 可置空。 

• 以相机实际支持为准。 

◆ MV_CC_SpatialDenoise() 

MV_CAMCTRL_API int __stdcall ( IN void * handle, MV_CC_SpatialDenois e

IN OUT MV_CC_SPATIAL_DENOISE_PARAM * 

pstSpatialDenoisePara m

)

空域降噪 

参数 

handle [IN] 设备句柄 

pstSpatialDenoiseParam [IN] 空域降噪参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

以相机实际支持为准。 

◆ MV_CC_LSCCalib() 

MV_CAMCTRL_API int __stdcall MV_CC_LSCCalib ( IN void * handle, 

IN OUT MV_CC_LSC_CALIB_PARAM * pstLSCCalibParam 

)

LSC 标定 

参数 

handle [IN] 设备句柄 

pstLSCCalibParam [IN] 标定参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

以相机实际支持为准。 

示例 

LensShadingCorrection.cpp .◆ MV_CC_LSCCorrect() 

MV_CAMCTRL_API int __stdcall MV_CC_LSCCorrect ( IN void * handle, 

IN OUT MV_CC_LSC_CORRECT_PARAM * pstLSCCorrectParam 

)

LSC 校正 

参数 

handle [IN] 设备句柄 

pstLSCCorrectParam [IN] 校正参数 

返回 

成功，返回 MV_OK ；错误，返回 状态码 

注解 

以相机实际支持为准。 

示例 

LensShadingCorrection.cpp .

◆ MV_GIGE_ForceIp() 

MV_CAMCTRL_API int __stdcall MV_GIGE_ForceIp ( IN void * handle, 

unsigned int nIP 

)

强制 IP （该接口已弃用，建议改用 MV_GIGE_ForceIpEx() 接口） 

参数 

handle [IN] 设备句柄 

nIP [IN] 设置的 IP 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_RegisterEventCallBack() MV_CAMCTRL_API int __stdcall MV_CC_RegisterEventCall Back ( void * 

handl e, 

void(__stdcall *cbEvent)(unsigned int nExternalEventId, void *pUser) ,

void * 

pUser 

)

注册事件回调（该接口已弃用，建议改用 MV_CC_RegisterEventCallBackEx() 接口） 

参数 

handle [IN] 设备句柄 

cbEvent [IN] 事件回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_Display() 

MV_CAMCTRL_API int __stdcall MV_CC_Display ( IN void * handle, 

void * hWnd 

)

显示图像，注册显示窗口，内部自动显示（该接口已弃用，建议改用 

MV_CC_DisplayOneFrameEx() 接口） 

参数 

handle [IN] 句柄 

hWnd [IN] 显示窗口句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_CC_GetIntValue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetIntValue ( IN void * handle, IN const char * strKey, 

OUT MVCC_INTVALUE * pIntValue 

)

获取 Integer 属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如获取宽度信息则为 "Width" 

pIntValue [IN][OUT] 返回给调用者有关相机属性结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以获取 int 类型的指定节点的值，具体可以查看客户端属性描 述，如下图所示： 

示例 

HighBandwidthDecode.cpp , ImageSave.cpp , 以及 Recording.cpp .

◆ MV_CC_SetIntValue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetIntValue ( IN void * handle, 

IN const char * strKey, 

IN unsigned int nValue 

)设置 Integer 型属性值 

参数 

handle [IN] 设备句柄 

strKey [IN] 属性键值，如获取宽度信息则为 "Width" 

nValue [IN] 想要设置的相机的属性值 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

连接设备之后调用该接口可以设置 int 类型的指定节点的值，具体可以查看客户端属性描 述，如下图所示： 

示例 

ImageSave.cpp , 以及 MultiLightCtrl_ImageStitching.cpp .

◆ MV_CC_GetWidth() 

MV_CAMCTRL_API int __stdcall MV_CC_GetWidth ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取图像宽度 

参数 

handle [IN] 相机句柄 pstValue [IN][OUT] 返回给调用者有关相机宽度的信息结构体指针 

返回的 pstValue 结构体的意义： 

变量 意义 

- unsigned int nCurValue 代表相机当前的宽度值 

- unsigned int nMax 表示相机允许的最大可设置的宽度值 

- unsigned int nMin 表示相机允许的最小可设置的宽度值 

- unsigned int nInc 表示相机设置的宽度增量必须是 nInc 的倍数，否 则无效 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

其他整型结构体参数的接口可参照此接口 

◆ MV_CC_SetWidth() 

MV_CAMCTRL_API int __stdcall MV_CC_SetWidth ( IN void * handle, 

IN const unsigned int nValue 

)

设置图像宽度 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的相机宽度的值 ,注意此宽度值必须是 MV_CC_GetWidth() 接口返回 的pstValue 中的 nInc 的倍数才能设置成功 

返回 

成功，返回 MV_OK ，并且相机宽度将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetHeight() 

MV_CAMCTRL_API int __stdcall MV_CC_GetHeight ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)获取图像高度 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机高度的信息结构体指针 

返回 

成功，返回 MV_OK ,并将高度信息返回到结构体中；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetHeight() 

MV_CAMCTRL_API int __stdcall MV_CC_SetHeight ( IN void * handle, 

IN const unsigned int nValue 

)

设置图像高度 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的相机宽度的值 ,注意此宽度值必须是 MV_CC_GetWidth() 接口返回 的pstValue 中的 nInc 的倍数才能设置成功 

返回 

成功，返回 MV_OK ，并且相机高度将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetAOIoffsetX() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetX ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取图像 X偏移 

参数 

handle [IN] 相机句柄 pstValue [IN][OUT] 返回给调用者有关相机 X偏移的信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetAOIoffsetX() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetX ( IN void * handle, 

IN const unsigned int nValue 

)

设置图像 AOI 偏移 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的相机 AOI 的值 

返回 

成功，返回 MV_OK ，并且相机 AOI 偏移将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetAOIoffsetY() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAOIoffsetY ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取图像 Y偏移 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机 Y偏移的信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() ◆ MV_CC_SetAOIoffsetY() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAOIoffsetY ( IN void * handle, 

IN const unsigned int nValue 

)

设置图像 AOI 偏移 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的相机 AOI 的值 

返回 

成功，返回 MV_OK ，并且相机 AOI 偏移将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetAutoExposureTimeLower() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeLower ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取曝光下限 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机曝光值下限结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetAutoExposureTimeLower() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeLower ( IN void * handle, 

IN const unsigned int nValue )

设置曝光值下限 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的曝光值下限 

返回 

成功，返回 MV_OK ，并且相机曝光下限将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetAutoExposureTimeUpper() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAutoExposureTimeUpper ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取曝光上限 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机曝光值上限结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetAutoExposureTimeUpper() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAutoExposureTimeUpper ( IN void * handle, 

IN const unsigned int nValue 

)

设置曝光值上限 

参数 handle [IN] 相机句柄 

nValue [IN] 想要设置的曝光值上限 

返回 

成功，返回 MV_OK ，并且相机曝光上限将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetBrightness() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBrightness ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取亮度值 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机亮度结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetBrightness() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBrightness ( IN void * handle, 

IN const unsigned int nValue 

)

设置亮度值 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的亮度值 

返回 

成功，返回 MV_OK ，并且相机亮度将会更改为相应值；失败，返回 状态码 ◆ MV_CC_GetFrameRate() 

MV_CAMCTRL_API int __stdcall MV_CC_GetFrameRate ( IN void * handle, 

IN OUT MVCC_FLOATVALUE * pstValue 

)

获取帧率 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机帧率的信息结构体指针 返回的 pstValue 结构体的意义： 

变量 意义 

- float fCurValue 表示相机当前的帧率 

- float fMax 表示相机允许设置的最大帧率 

float fMin 表示相机允许设置的最小帧率 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

其他浮点型结构体参数的接口可参照此接口 

◆ MV_CC_SetFrameRate() 

MV_CAMCTRL_API int __stdcall MV_CC_SetFrameRate ( IN void * handle, 

IN const float fValue 

)

设置帧率 

参数 

handle [IN] 相机句柄 

fValue [IN] 想要设置的相机帧率 

返回 

成功，返回 MV_OK ，并且相机帧率将会更改为相应值；失败，返回 状态码 ◆ MV_CC_GetGain() 

MV_CAMCTRL_API int __stdcall MV_CC_GetGain ( IN void * handle, 

IN OUT MVCC_FLOATVALUE * pstValue 

)

获取增益 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机增益的信息结构体指针 

返回的 pstValue 结构体的意义： 

变量 意义 

- float fCurValue 表示相机当前的增益 

- float fMax 表示相机允许设置的最大增益 

- float &nbsp 表示相机允许设置的最小增益 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

其他浮点型结构体参数的接口可参照此接口 

◆ MV_CC_SetGain() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGain ( IN void * handle, 

IN const float fValue 

)

设置增益 

参数 

handle [IN] 相机句柄 

fValue [IN] 想要设置的相机增益 

返回 

成功，返回 MV_OK ，并且相机帧率将会更改为相应值；失败，返回 状态码 ◆ MV_CC_GetExposureTime() 

MV_CAMCTRL_API int __stdcall MV_CC_GetExposureTime ( IN void * handle, 

IN OUT MVCC_FLOATVALUE * pstValue 

)

获取曝光时间 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机曝光时间的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

◆ MV_CC_SetExposureTime() 

MV_CAMCTRL_API int __stdcall MV_CC_SetExposureTime ( IN void * handle, 

IN const float fValue 

)

设置曝光时间 

参数 

handle [IN] 相机句柄 

fValue [IN] 想要设置的曝光时间 

返回 

成功，返回 MV_OK ，并且相机帧率将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetPixelFormat() 

MV_CAMCTRL_API int __stdcall MV_CC_GetPixelFormat ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取像素格式 参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关像素格式的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

◆ MV_CC_SetPixelFormat() 

MV_CAMCTRL_API int __stdcall MV_CC_SetPixelFormat ( IN void * handle, 

IN const unsigned int nValue 

)

设置像素格式 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的像素格式对应的整型值，调用此接口时可以直接填写枚举值，如 

MV_CC_SetPixelFormat() ;

返回 

成功，返回 MV_OK ，并且相机像素格式将会更改为相应值；失败，返回 状态码 

注解 

要设置的枚举类型必须是 Get 接口返回的 

nSupportValue[MV_MAX_XML_SYMBOLIC_NUM] 中的一种，否则会失败 

◆ MV_CC_GetAcquisitionMode() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionMode ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取采集模式 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关采集模式的信息结构体指针 返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_ACQUISITION_MODE 定义 

◆ MV_CC_SetAcquisitionMode() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionMode ( IN void * handle, 

IN const unsigned int nValue 

)

设置像素格式 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的采集模式对应的整型值 

返回 

成功，返回 MV_OK ，并且相机采集模式将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetGainMode() 

MV_CAMCTRL_API int __stdcall MV_CC_GetGainMode ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取增益模式 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关增益模式的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_GAIN_MODE 定义 

◆ MV_CC_SetGainMode() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGainMode ( IN void * handle, 

IN const unsigned int nValue 

)

设置增益模式 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的增益模式对应的整型值 

返回 

成功，返回 MV_OK ，并且相机增益模式将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetExposureAutoMode() 

MV_CAMCTRL_API int __stdcall MV_CC_GetExposureAutoMode ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取自动曝光模式 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关自动曝光模式的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

::MV_CAM_EXPOSURE_AUTO_MODE 定义 

◆ MV_CC_SetExposureAutoMode() MV_CAMCTRL_API int __stdcall MV_CC_SetExposureAutoMode ( IN void * handle, 

IN const unsigned int nValue 

)

设置自动曝光模式 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的自动曝光模式对应的整型值 

返回 

成功，返回 MV_OK ，并且相机自动曝光模式将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetTriggerMode() 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerMode ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取触发模式 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关触发模式的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_TRIGGER_MODE 定义 

◆ MV_CC_SetTriggerMode() 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerMode ( IN void * handle, 

IN const unsigned int nValue 

)设置触发模式 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的触发模式对应的整型值 

返回 

成功，返回 MV_OK ，并且相机触发模式将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetTriggerDelay() 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerDelay ( IN void * handle, 

IN OUT MVCC_FLOATVALUE * pstValue 

)

获取触发延时 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机触发延时的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetFrameRate() 

◆ MV_CC_SetTriggerDelay() 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerDelay ( IN void * handle, 

IN const float fValue 

)

设置触发延时 

参数 

handle [IN] 相机句柄 

fValue [IN] 想要设置的相机触发延时 返回 

成功，返回 MV_OK ，并且相机触发延时将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetTriggerSource() 

MV_CAMCTRL_API int __stdcall MV_CC_GetTriggerSource ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取触发源 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关触发源的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_TRIGGER_SOURCE 定义 

◆ MV_CC_SetTriggerSource() 

MV_CAMCTRL_API int __stdcall MV_CC_SetTriggerSource ( IN void * handle, 

IN const unsigned int nValue 

)

设置触发源 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的触发源对应的整型值 

返回 

成功，返回 MV_OK ，并且相机触发源将会更改为相应值；失败，返回 状态码 

◆ MV_CC_TriggerSoftwareExecute() MV_CAMCTRL_API int __stdcall MV_CC_TriggerSoftwareExecute ( IN void * handle )

软触发一次（接口仅在已选择的触发源为软件触发时有效） 

参数 

handle [IN] 相机句柄 

返回 

成功，返回 MV_OK , 失败 ,返回错误码 

◆ MV_CC_GetGammaSelector() 

MV_CAMCTRL_API int __stdcall MV_CC_GetGammaSelector ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取 Gamma 类型 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关 Gamma 类型的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_GAMMA_SELECTOR 定义 

◆ MV_CC_SetGammaSelector() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGammaSelector ( IN void * handle, 

IN const unsigned int nValue 

)

设置 Gamma 类型 

参数 

handle [IN] 相机句柄 nValue [IN] 要设置的 Gamma 类型对应的整型值 

返回 

成功，返回 MV_OK ，并且相机 Gamma 类型将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetGamma() 

MV_CAMCTRL_API int __stdcall MV_CC_GetGamma ( IN void * handle, 

IN OUT MVCC_FLOATVALUE * pstValue 

)

获取 Gamma 值

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机 Gamma 值的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetExposureTime() 

◆ MV_CC_SetGamma() 

MV_CAMCTRL_API int __stdcall MV_CC_SetGamma ( IN void * handle, 

IN const float fValue 

)

设置 Gamma 值

参数 

handle [IN] 相机句柄 

fValue [IN] 想要设置的相机 Gamma 值

返回 

成功，返回 MV_OK ，并且相机 Gamma 值将会更改为相应值；失败，返回 状态码 ◆ MV_CC_GetSharpness() 

MV_CAMCTRL_API int __stdcall MV_CC_GetSharpness ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取锐度 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机锐度结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetSharpness() 

MV_CAMCTRL_API int __stdcall MV_CC_SetSharpness ( IN void * handle, 

IN const unsigned int nValue 

)

设置锐度 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的锐度 

返回 

成功，返回 MV_OK ，并且相机锐度将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetHue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetHue ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)获取灰度 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机灰度结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetHue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetHue ( IN void * handle, 

IN const unsigned int nValue 

)

设置灰度 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的灰度 

返回 

成功，返回 MV_OK ，并且相机灰度将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetSaturation() 

MV_CAMCTRL_API int __stdcall MV_CC_GetSaturation ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取饱和度 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机饱和度结构体指针 返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetSaturation() 

MV_CAMCTRL_API int __stdcall MV_CC_SetSaturation ( IN void * handle, 

IN const unsigned int nValue 

)

设置饱和度 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的饱和度 

返回 

成功，返回 MV_OK ，并且相机饱和度将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetBalanceWhiteAuto() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceWhiteAuto ( IN void * handle, 

IN OUT MVCC_ENUMVALUE * pstValue 

)

获取自动白平衡 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者的有关自动白平衡的信息结构体指针 

返回 

成功，返回 MV_OK ，并获得相应参数信息的结构体；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetPixelFormat() ，参考 CameraParams.h 中的 

MV_CAM_BALANCEWHITE_AUTO 定义 ◆ MV_CC_SetBalanceWhiteAuto() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceWhiteAuto ( IN void * handle, 

IN const unsigned int nValue 

)

设置自动白平衡 

参数 

handle [IN] 相机句柄 

nValue [IN] 要设置的自动白平衡对应的整型值 

返回 

成功，返回 MV_OK ，并且相机自动白平衡将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetBalanceRatioRed() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioRed ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取白平衡 红

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机白平衡 红结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetBalanceRatioRed() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioRed ( IN void * handle, 

IN const unsigned int nValue 

)设置白平衡 红

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的白平衡 红

返回 

成功，返回 MV_OK ，并且相机白平衡 红将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetBalanceRatioGreen() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioGreen ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取白平衡 绿

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机白平衡 绿结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetBalanceRatioGreen() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioGreen ( IN void * handle, 

IN const unsigned int nValue 

)

设置白平衡 绿

参数 

handle [IN] 相机句柄 nValue [IN] 想要设置的白平衡 绿

返回 

成功，返回 MV_OK ，并且相机白平衡 绿将会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetBalanceRatioBlue() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBalanceRatioBlue ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取白平衡 蓝

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机白平衡 蓝结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetBalanceRatioBlue() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBalanceRatioBlue ( IN void * handle, 

IN const unsigned int nValue 

)

设置白平衡 蓝

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的白平衡 蓝

返回 

成功，返回 MV_OK ，并且相机白平衡 蓝将会更改为相应值；失败，返回 状态码 ◆ MV_CC_GetFrameSpecInfoAbility() 

MV_CAMCTRL_API int __stdcall MV_CC_GetFrameSpecInfoAbility ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取水印信息内包含的信息类型 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机水印信息内包含的信息类型结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetFrameSpecInfoAbility() 

MV_CAMCTRL_API int __stdcall MV_CC_SetFrameSpecInfoAbility ( IN void * handle, 

IN const unsigned int nValue 

)

设置水印信息内包含的信息类型 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的水印信息内包含的信息类型 

返回 

成功，返回 MV_OK ，并且相机水印信息内包含的信息类型会更改为相应值；失败，返 回状态码 

◆ MV_CC_GetDeviceUserID() 

MV_CAMCTRL_API int __stdcall MV_CC_GetDeviceUserID ( IN void * handle, IN OUT MVCC_STRINGVALUE * pstValue 

)

获取设备自定义名字 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机名字结构体指针 

返回 

成功，返回 MV_OK ，并且获取到相机的自定义名字；失败，返回 状态码 

◆ MV_CC_SetDeviceUserID() 

MV_CAMCTRL_API int __stdcall MV_CC_SetDeviceUserID ( IN void * handle, 

IN const char * chValue 

)

设置设备自定义名字 

参数 

handle [IN] 相机句柄 

chValue [IN] 设备名字 

返回 

成功，返回 MV_OK ，并且设置设备自定义名字；失败，返回 状态码 

◆ MV_CC_GetBurstFrameCount() 

MV_CAMCTRL_API int __stdcall MV_CC_GetBurstFrameCount ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取一次触发的帧数 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机一次触发的帧数结构体指针 返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetBurstFrameCount() 

MV_CAMCTRL_API int __stdcall MV_CC_SetBurstFrameCount ( IN void * handle, 

IN const unsigned int nValue 

)

设置一次触发的帧数 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的一次触发的帧数 

返回 

成功，返回 MV_OK ，并且相机一次触发的帧数会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetAcquisitionLineRate() 

MV_CAMCTRL_API int __stdcall MV_CC_GetAcquisitionLineRate ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取行频 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机行频结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() ◆ MV_CC_SetAcquisitionLineRate() 

MV_CAMCTRL_API int __stdcall MV_CC_SetAcquisitionLineRate ( IN void * handle, 

IN const unsigned int nValue 

)

设置行频 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的行频 

返回 

成功，返回 MV_OK ，并且相机行频会更改为相应值；失败，返回 状态码 

◆ MV_CC_GetHeartBeatTimeout() 

MV_CAMCTRL_API int __stdcall MV_CC_GetHeartBeatTimeout ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取心跳信息 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机心跳信息结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_CC_SetHeartBeatTimeout() 

MV_CAMCTRL_API int __stdcall MV_CC_SetHeartBeatTimeout ( IN void * handle, 

IN const unsigned int nValue )

设置心跳信息 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的心跳信息 

返回 

成功，返回 MV_OK ，并且相机心跳信息会更改为相应值；失败，返回 状态码 

◆ MV_GIGE_GetGevSCPSPacketSize() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPSPacketSize ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取网络包大小 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机网络包大小结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_GIGE_SetGevSCPSPacketSize() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPSPacketSize ( IN void * handle, 

IN const unsigned int nValue 

)

设置网络包大小 

参数 handle [IN] 相机句柄 

nValue [IN] 想要设置的网络包大小 

返回 

成功，返回 MV_OK ，并且相机网络包大小会更改为相应值；失败，返回 状态码 

◆ MV_GIGE_GetGevSCPD() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCPD ( IN void * handle, 

IN OUT MVCC_INTVALUE * pstValue 

)

获取网络包发送间隔 

参数 

handle [IN] 相机句柄 

pstValue [IN][OUT] 返回给调用者有关相机网络包发送间隔结构体指针 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

可参照接口 MV_CC_GetWidth() 

◆ MV_GIGE_SetGevSCPD() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCPD ( IN void * handle, 

IN const unsigned int nValue 

)

设置网络包发送间隔 

参数 

handle [IN] 相机句柄 

nValue [IN] 想要设置的网络包发送间隔 

返回 

成功，返回 MV_OK ，并且相机网络包发送间隔会更改为相应值；失败，返回 状态码 ◆ MV_GIGE_GetGevSCDA() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCDA ( IN void * handle, 

unsigned int * pnIP 

)

获取接收端 IP 地址， 0xa9fe0102 表示 169.254.1.2 

参数 

handle [IN] 相机句柄 

pnIP [IN][OUT] 返回给调用者接收端 IP 地址 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_GIGE_SetGevSCDA() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCDA ( IN void * handle, 

unsigned int nIP 

)

设置接收端 IP 地址 

参数 

handle [IN] 相机句柄 

nIP [IN] 想要设置的接收端 IP 地址 

返回 

成功，返回 MV_OK ，并且相机接收端 IP 地址会更改为相应值；失败，返回 状态码 

◆ MV_GIGE_GetGevSCSP() 

MV_CAMCTRL_API int __stdcall MV_GIGE_GetGevSCSP ( IN void * handle, 

unsigned int * pnPort 

)

获取发送端的端口号 

参数 handle [IN] 相机句柄 

pnPort [IN][OUT] 返回给调用者发送端的端口号 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

◆ MV_GIGE_SetGevSCSP() 

MV_CAMCTRL_API int __stdcall MV_GIGE_SetGevSCSP ( IN void * handle, 

unsigned int nPort 

)

设置发送端的端口号 

参数 

handle [IN] 相机句柄 

nPort [IN] 想要设置的发送端的端口号 

返回 

成功，返回 MV_OK ，并且相机发送端的端口号会更改为相应值；失败，返回 状态码 

◆ MV_CAML_SetDeviceBauderate() 

MV_CAMCTRL_API int __stdcall MV_CAML_SetDeviceBauderate ( IN void * handle, 

unsigned int nBaudrate 

)

设置设备波特率 

参数 

handle [IN] 设备句柄 

nBaudrate [IN] 设置的波特率值，数值参考 CameraParams.h 中宏定义 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

（该接口已弃用，建议改用 MV_CAML_SetDeviceBaudrate() 接口） ◆ MV_CAML_GetDeviceBauderate() 

MV_CAMCTRL_API int __stdcall MV_CAML_GetDeviceBauderate ( IN void * handle, 

unsigned int * pnCurrentBaudrate 

)

获取设备波特率 

参数 

handle [IN] 设备句柄 

pnCurrentBaudrate [OUT] 波特率信息指针，数值参考 CameraParams.h 中宏定义 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

（该接口已弃用，建议改用 MV_CAML_GetDeviceBaudrate() 接口） 

◆ MV_CAML_GetSupportBauderates() 

MV_CAMCTRL_API int __stdcall MV_CAML_GetSupportBauderates ( IN void * handle, 

unsigned int * pnBaudrateAblity 

)

获取设备与主机间连接支持的波特率 

参数 

handle [IN] 设备句柄 

pnBaudrateAblity [OUT] 支持的波特率信息的指针。所支持波特率的或运算结果，单个数 值参考 CameraParams.h 中宏定义，如 MV_CAML_BAUDRATE_9600 0x00000001 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

弃用 :

该接口已弃用，建议改用 MV_CAML_GetSupportBaudrates() 接口 ◆ MV_USB_RegisterStreamExceptionCallBack() 

MV_CAMCTRL_API int __stdcall MV_USB_RegisterStream ExceptionCallBack (

IN void * handle, 

IN 

void__stdcall *cbException)(MV_CC_STREAM_EXCEPTION_TYPE enExceptionType, void *pUser, 

IN void * pUser 

)

注册流异常消息回调，在打开设备之后调用（只支持 U3V 相机，不支持 GenTL 设备） 

参数 

handle [IN] 设备句柄 

cbException [IN] 异常回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

弃用 :

自V4.6.0 废弃。建议改用 MV_CC_RegisterStreamExceptionCallBack() 

◆ MV_CC_SaveImageEx2() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageEx2 ( IN void * handle, 

MV_SAVE_IMAGE_PARAM_EX * pstSaveParam 

)

保存图片，支持 Bmp 和Jpeg ，编码质量在 50-99 之前（该接口已弃用，建议改用 

MV_CC_SaveImageEx3() 接口） 

参数 

handle [IN] 设备句柄 pstSaveParam [IN][OUT] 保存图片参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以将从设备采集到的原始图像数据转换成 JPEG 或者 BMP 等格式并存放 在指定内存中，然后用户可以将转换之后的数据直接保存成图片文件。该接口调用无接 口顺序要求，有图像源数据就可以进行转换，可以先调用 图像采集 接口，获取一帧图像 数据，然后再通过该接口转换格式。 

• MV_CC_SaveImageEx2() 比 MV_CC_SaveImageEx() 增加参数 handle ，为了保证 与其他接口的统一。 

◆ MV_CC_SaveImageToFile() 

MV_CAMCTRL_API int __stdcall MV_CC_SaveImageToFile ( IN void * handle, 

MV_SAVE_IMG_TO_FILE_PARAM * pstSaveFileParam 

)

保存图像到文件（该接口已弃用，建议改用 MV_CC_SaveImageToFileEx() 接口） 

参数 

handle [IN] 设备句柄 

pstSaveFileParam [IN][OUT] 保存图片文件参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

该接口支持 BMP/JPEG/PNG/TIFF 。

◆ MV_CC_ConvertPixelType() 

MV_CAMCTRL_API int __stdcall MV_CC_ConvertPixelType ( IN void * handle, 

IN OUT MV_CC_PIXEL_CONVERT_PARAM * pstCvtParam 

)

像素格式转换（该接口已弃用，建议改用 MV_CC_ConvertPixelTypeEx() 接口） 参数 

handle [IN] 设备句柄 

pstCvtParam [IN][OUT] 像素格式转换参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以将从设备采集到的原始图像数据转换成用户所需的像素格式并存放在 指定内存中。 

• 该接口调用无接口顺序要求，有图像源数据就可以进行转换，可以先调用 

MV_CC_GetOneFrameTimeout() 或者 MV_CC_RegisterImageCallBackEx() 设置回 调函数，获取一帧图像数据，然后再通过该接口转换格式。如果设备当前采集图像是 

JPEG 压缩的格式，则不支持调用该接口进行转换。 

◆ MV_CC_SetSDKLogPath() 

MV_CAMCTRL_API int __stdcall MV_CC_SetSDKLogPath ( IN const char * strSDKLogPath )

设置 SDK 日志路径 

参数 

strSDKLogPath [IN] SDK 日志路径 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

设置路径之后，可以指定路径存放日志， V2.4.1 版本新增日志服务，开启服务之后该接 口无效，默认日志服务为开启状态。 

◆ MV_CC_DisplayOneFrame() 

MV_CAMCTRL_API int __stdcall MV_CC_DisplayOneFrame ( IN void * handle, 

IN MV_DISPLAY_FRAME_INFO * pstDisplayInfo 

)

显示一帧图像（该接口已启用，建议改用 MV_CC_DisplayOneFrameEx2() 接口） 

参数 handle [IN] 设备句柄 

pstDisplayInfo [IN] 图像信息 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

与设备类型无关，渲染模式为 D3D 时，支持的最大分辨率为 16384 * 163840 

◆ MV_CC_EnumerateTls() 

MV_CAMCTRL_API int __stdcall MV_CC_EnumerateTls ( )

获取支持的传输层 

返回 

当前支持的传输层协议类型和数值总和 

注解 

包含 GigE 、U3V 、Camera Link 、CoaXPress 、XoFLink 传输层。 

◆ MV_CC_CreateHandleWithoutLog() 

MV_CAMCTRL_API int __stdcall MV_CC_CreateHandleWithoutLog ( IN OUT void ** handle, 

IN const MV_CC_DEVICE_INFO * pstDevInfo 

)

创建设备句柄，不生成日志 

参数 

handle [IN][OUT] 设备句柄 

pstDevInfo [IN] 设备信息结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 根据输入的设备信息，创建库内部必须的资源和初始化内部模块。 

• 通过该接口创建句柄，调用 SDK 接口，不会默认生成 SDK 日志文件，如果需要生成日 志文件可以通过 MV_CC_CreateHandle() 创建句柄，日志文件自动生成。 ◆ MV_CC_RegisterImageCallBackForRGB() 

MV_CAMCTRL_API int __stdcall MV_CC_RegisterImage CallBackForRGB (

IN void * handle, 

IN 

void__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, 

IN void * pUser 

)

注册图像数据回调， RGB 

参数 

handle [IN] 设备句柄 

cbOutput [IN] 回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以设置图像数据回调函数，在 MV_CC_CreateHandle() 之后即可调用 。

• 图像数据采集有两种方式，两种方式不能复用： 

1. 调用 MV_CC_RegisterImageCallBackEx() 设置图像数据回调函数，然后调用 

MV_CC_StartGrabbing() 开始采集，采集的图像数据在设置的回调函数中返回 。

2. 调用 MV_CC_StartGrabbing() 开始采集，然后在应用层循环调用 

MV_CC_GetImageForRGB() 获取 RGB24 格式的帧数据，获取帧数据时上层应 用程序需要根据帧率控制好调用该接口的频率。 

• 该接口不支持 CameraLink 设备。 

◆ MV_CC_RegisterImageCallBackForBGR() MV_CAMCTRL_API int __stdcall MV_CC_RegisterImage CallBackForBGR (

IN void * handle, 

IN 

void__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser, 

IN void * pUser 

)

注册图像数据回调， BGR 

参数 

handle [IN] 设备句柄 

cbOutput [IN] 回调函数指针 

pUser [IN] 用户自定义变量 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 通过该接口可以设置图像数据回调函数，在 MV_CC_CreateHandle() 之后即可调用 。

• 图像数据采集有两种方式，两种方式不能复用： 

1. 调用 MV_CC_RegisterImageCallBackForBGR() 设置 BGR24 图像数据回调函 数，然后调用 MV_CC_StartGrabbing() 开始采集，采集的图像数据在设置的回 调函数中返回。 

2. 调用 MV_CC_StartGrabbing() 开始采集，然后在应用层循环调用 

MV_CC_GetImageForBGR() 获取 BGR24 格式的帧数据，获取帧数据时上层应 用程序需要根据帧率控制好调用该接口的频率。 

• 该接口不支持 CameraLink 设备。 

◆ MV_CC_GetImageForRGB() 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageForRGB ( IN void * handle, IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT MV_FRAME_OUT_INFO_EX * pstFrameInfo, 

IN int nMsec 

)

获取一帧 RGB 数据，此函数为查询式获取，每次调用查询内部 缓存有无数据，有数据则获取 数据，无数据返回错误码 

参数 

handle [IN] 设备句柄 

pData [IN][OUT] 图像数据接收指针 

nDataSize [IN] 接收缓存大小 

pstFrameInfo [IN][OUT] 图像信息结构体 

nMsec [IN] 等待超时时间 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 每次调用该接口，将查询内部缓存是否有数据，如果有数据则转换成 RGB24 格式返回 ，如果没有数据则返回错误码。因为图像转换成 RGB24 格式有耗时，所以当数据帧率过 高时该接口可能会导致丢帧。 

• 调用该接口获取图像数据帧之前需要先调用 MV_CC_StartGrabbing() 启动图像采集 。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率 。

• 该接口不支持 CameraLink 设备。 

◆ MV_CC_GetImageForBGR() 

MV_CAMCTRL_API int __stdcall MV_CC_GetImageForBGR ( IN void * handle, 

IN OUT unsigned char * pData, 

IN unsigned int nDataSize, 

IN OUT MV_FRAME_OUT_INFO_EX * pstFrameInfo, 

IN int nMsec 

)获取一帧 BGR 数据，此函数为查询式获取，每次调用查询内部 缓存有无数据，有数据则获取 数据，无数据返回错误码 

参数 

handle [IN] 设备句柄 

pData [IN][OUT] 图像数据接收指针 

nDataSize [IN] 接收缓存大小 

pstFrameInfo [IN][OUT] 图像信息结构体 

nMsec [IN] 等待超时时间 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 每次调用该接口，将查询内部缓存是否有数据，如果有数据则转换成 BGR24 格式返回 ，如果没有数据则返回错误码。因为图像转换成 BGR24 格式有耗时，所以当数据帧率过 高时该接口可能会导致丢帧。 

• 调用该接口获取图像数据帧之前需要先调用 MV_CC_StartGrabbing() 启动图像采集 。该接口为主动式获取帧数据，上层应用程序需要根据帧率，控制好调用该接口的频率 。

• 该接口不支持 CameraLink 设备。 

◆ MV_CC_OpenParamsGUI() 

MV_CAMCTRL_API int __stdcall MV_CC_OpenParamsGUI ( IN void * handle )

打开获取或设置相机参数的 GUI 界面 

参数 

handle [IN] 设备句柄 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

通过 MV_CC_OpenDevice() 连接设备后，可以通过该接口获取或设置设备参数。 

◆ MV_CC_SavePointCloudData() MV_CAMCTRL_API int __stdcall MV_CC_SavePointCloudDat a ( IN void * handle, 

IN OUT MV_SAVE_POINT_CLOUD_PARAM 

*

pstPointDataPara m

)

保存 3D 点云数据，支持 PLY 、CSV 和OBJ 三种格式 

参数 

handle [IN] 设备句柄 

pstPointDataParam [IN][OUT] 保存点云数据参数结构体 

返回 

成功，返回 MV_OK ；失败，返回 状态码 

注解 

• 3D 数据格式保存成 3D 文件格式，支持 PLY/CSV/OBJ 。

• 目前支持 PixelType_Gvsp_Coord3D_ABC32 、PixelType_Gvsp_Coord3D_ABC32f 、

PixelType_Gvsp_Coord3D_AB32 、PixelType_Gvsp_Coord3D_AB32f 、

PixelType_Gvsp_Coord3D_AC32 、PixelType_Gvsp_Coord3D_AC32f ，暂不支持其他 

3D 格式。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> 模块

# 状态码 

介绍 SDK 使用过程中不同状态码对应的值和说明 更多 ... 

# 模块 

SDK 内部自定义状态码 

算法库透传状态码 

# 详细描述 

介绍 SDK 使用过程中不同状态码对应的值和说明 

当SDK 接口被调用时，返回一个代表 int 型的状态码。这个状态码用于表示接口的调用状态。状态码 以16 进制形式呈现，格式为 “0x%x” 。

您可在本节中查找各个状态码及其对应解释。例如，状态码 “0x00000000” 表示接口调用成功，没有 遇到错误。 

如下示例代码通过打开相机设备，演示了检查函数异常返回的过程。 

int nRet = MV_OK ;

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

return nRet; 

}

在该例中，若相机设备已连接至第三方软件，则再次连接设备时报错： 

Open Device fail! nRet [0x80000203] 

通过查找本节内容，您可知道 “0x80000203” 代表 “设备无访问权限 ”。首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# SDK 内部自定义状态码 

> 状态码

# 正确码 

正确码为 0x00000000 

#define MV_OK 0x00000000 

成功，无错误 更多 ... 

# 通用错误码 

范围为 0x80000000-0x800000FF 

#define MV_E_HANDLE 0x80000000 

错误或无效的句柄 更多 ... 

#define MV_E_SUPPORT 0x80000001 

不支持的功能 更多 ... #define MV_E_BUFOVER 0x80000002 

缓存已满 更多 ... 

#define MV_E_CALLORDER 0x80000003 

函数调用顺序有误 更多 ... 

#define MV_E_PARAMETER 0x80000004 

错误的参数 更多 ... 

#define MV_E_RESOURCE 0x80000006 

资源申请失败 更多 ... 

#define MV_E_NODATA 0x80000007 

无数据 更多 ... 

#define MV_E_PRECONDITION 0x80000008 

前置条件有误，或运行环境已发生变化 更多 ... 

#define MV_E_VERSION 0x80000009 

版本不匹配 更多 ... 

#define MV_E_NOENOUGH_BUF 0x8000000A 

传入的内存空间不足 更多 ... 

#define MV_E_ABNORMAL_IMAGE 0x8000000B 

异常图像，可能是丢包导致图像不完整 更多 ... 

#define MV_E_LOAD_LIBRARY 0x8000000C 

动态导入 DLL 失败 更多 ... 

#define MV_E_NOOUTBUF 0x8000000D 

没有可输出的缓存 更多 ... 

#define MV_E_ENCRYPT 0x8000000E 

加密错误 更多 ... 

#define MV_E_OPENFILE 0x8000000F 

打开文件出现错误 更多 ... #define MV_E_BUF_IN_USE 0x80000010 

缓存地址已使用 更多 ... 

#define MV_E_BUF_INVALID 0x80000011 

无效的缓存地址 更多 ... 

#define MV_E_NOALIGN_BUF 0x80000012 

缓存对齐异常 更多 ... 

#define MV_E_NOENOUGH_BUF_NUM 0x80000013 

缓存个数不足 更多 ... 

#define MV_E_PORT_IN_USE 0x80000014 

串口被占用 更多 ... 

#define MV_E_IMAGE_DECODEC 0x80000015 

解码错误 (SDK 校验图像异常 ) 更多 ... 

#define MV_E_UINT32_LIMIT 0x80000016 

图像大小超出 unsigned int 数据类型上限值 更多 ... 

#define MV_E_IMAGE_HEIGHT 0x80000017 

图像高度异常（残帧丢弃） 更多 ... 

#define MV_E_NOENOUGH_DDR 0x80000018 

DDR 缓存不足 更多 ... 

#define MV_E_NOENOUGH_STREAM 0x80000019 

流通道不足 更多 ... 

#define MV_E_UNKNOW 0x800000FF 

未知的错误 更多 ... 

# GenICam 错误码 

范围为 0x80000100-0x800001FF 

#define MV_E_GC_GENERIC 0x80000100 通用错误 更多 ... 

#define MV_E_GC_ARGUMENT 0x80000101 

参数非法 更多 ... 

#define MV_E_GC_RANGE 0x80000102 

值超出范围 更多 ... 

#define MV_E_GC_PROPERTY 0x80000103 

属性 更多 ... 

#define MV_E_GC_RUNTIME 0x80000104 

运行环境有问题 更多 ... 

#define MV_E_GC_LOGICAL 0x80000105 

逻辑错误 更多 ... 

#define MV_E_GC_ACCESS 0x80000106 

节点访问条件有误 更多 ... 

#define MV_E_GC_TIMEOUT 0x80000107 

超时 更多 ... 

#define MV_E_GC_DYNAMICCAST 0x80000108 

转换异常 更多 ... 

#define MV_E_GC_UNKNOW 0x800001FF 

GenICam 未知错误 更多 ... 

# GigE_STATUS 错误码 

范围为 0x80000200-0x800002FF 

#define MV_E_NOT_IMPLEMENTED 0x80000200 

命令不被设备支持 更多 ... 

#define MV_E_INVALID_ADDRESS 0x80000201 

访问的目标地址不存在 更多 ... #define MV_E_WRITE_PROTECT 0x80000202 

目标地址不可写 更多 ... 

#define MV_E_ACCESS_DENIED 0x80000203 

设备无访问权限 更多 ... 

#define MV_E_BUSY 0x80000204 

设备忙，或网络断开 更多 ... 

#define MV_E_PACKET 0x80000205 

网络包数据错误 更多 ... 

#define MV_E_NETER 0x80000206 

网络相关错误 更多 ... 

#define MV_E_SUPPORT_MODIFY_DEVICE_IP 0x8000020E 

在固定 IP 模式下不支持修改设备 IP 模式 更多 ... 

#define MV_E_KEY_VERIFICATION 0x8000020F 

秘钥校验错误 更多 ... 

#define MV_E_IP_CONFLICT 0x80000221 

设备 IP 冲突 更多 ... 

# USB_STATUS 错误码 

范围为 0x80000300-0x800003FF 

#define MV_E_USB_READ 0x80000300 

读USB 出错 更多 ... 

#define MV_E_USB_WRITE 0x80000301 

写USB 出错 更多 ... 

#define MV_E_USB_DEVICE 0x80000302 

设备异常 更多 ... #define MV_E_USB_GENICAM 0x80000303 

GenICam 相关错误 更多 ... 

#define MV_E_USB_BANDWIDTH 0x80000304 

带宽不足 更多 ... 

#define MV_E_USB_DRIVER 0x80000305 

驱动不匹配或者未装驱动 更多 ... 

#define MV_E_USB_UNKNOW 0x800003FF 

USB 未知的错误 更多 ... 

# 升级错误码 

范围为 0x80000400-0x800004FF 

#define MV_E_UPG_FILE_MISMATCH 0x80000400 

升级固件不匹配 更多 ... 

#define MV_E_UPG_LANGUSGE_MISMATCH 0x80000401 

升级固件语言不匹配 更多 ... 

#define MV_E_UPG_CONFLICT 0x80000402 

升级冲突（设备已经在升级了再次请求升级即返回此错误） 更多 ... 

#define MV_E_UPG_INNER_ERR 0x80000403 

升级时设备内部出现错误 更多 ... 

#define MV_E_UPG_UNKNOW 0x800004FF 

升级时未知错误 更多 ... 

# 异常错误码 

0x00008001 、0x00008002 

#define MV_EXCEPTION_DEV_DISCONNECT 0x00008001 

设备断开连接 更多 ... #define MV_EXCEPTION_VERSION_CHECK 0x00008002 

SDK 与驱动版本不匹配 更多 ... 

# 详细描述 

# 宏定义说明 

◆ MV_OK 

#define MV_OK 0x00000000 

成功，无错误 

示例 

ChunkData.cpp , ConfigLightController.cpp , ConnectSpecCamera.cpp ,

ConvertPixelType.cpp , DynamicallyLoadDLL.cpp , Events.cpp ,

Events_Interface.cpp , ForceIPEx.cpp , Grab_ActionCommand.cpp ,

Grab_Asynchronous.cpp , Grab_Callback.cpp , GrabImage.cpp ,

GrabImage_Display.cpp , GrabStrategies.cpp , HighBandwidthDecode.cpp ,

ImageContrast.cpp , ImageSave.cpp , InterfaceAndDeviceDemo.cpp ,

InterfaceDemo.cpp , LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp ,

MultiCast.cpp , MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , QuickSoftwareTrigger.cpp , 以及 

Recording.cpp .

◆ MV_E_HANDLE 

#define MV_E_HANDLE 0x80000000 错误或无效的句柄 

◆ MV_E_SUPPORT 

#define MV_E_SUPPORT 0x80000001 

不支持的功能 

◆ MV_E_BUFOVER 

#define MV_E_BUFOVER 0x80000002 

缓存已满 

示例 

Grab_Asynchronous.cpp .

◆ MV_E_CALLORDER 

#define MV_E_CALLORDER 0x80000003 

函数调用顺序有误 

◆ MV_E_PARAMETER 

#define MV_E_PARAMETER 0x80000004 

错误的参数 

◆ MV_E_RESOURCE 

#define MV_E_RESOURCE 0x80000006 

资源申请失败 

示例 

Grab_Asynchronous.cpp , HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .◆ MV_E_NODATA 

#define MV_E_NODATA 0x80000007 

无数据 

示例 

Grab_Asynchronous.cpp .

◆ MV_E_PRECONDITION 

#define MV_E_PRECONDITION 0x80000008 

前置条件有误，或运行环境已发生变化 

◆ MV_E_VERSION 

#define MV_E_VERSION 0x80000009 

版本不匹配 

◆ MV_E_NOENOUGH_BUF 

#define MV_E_NOENOUGH_BUF 0x8000000A 

传入的内存空间不足 

◆ MV_E_ABNORMAL_IMAGE 

#define MV_E_ABNORMAL_IMAGE 0x8000000B 

异常图像，可能是丢包导致图像不完整 

◆ MV_E_LOAD_LIBRARY 

#define MV_E_LOAD_LIBRARY 0x8000000C 动态导入 DLL 失败 

◆ MV_E_NOOUTBUF 

#define MV_E_NOOUTBUF 0x8000000D 

没有可输出的缓存 

◆ MV_E_ENCRYPT 

#define MV_E_ENCRYPT 0x8000000E 

加密错误 

◆ MV_E_OPENFILE 

#define MV_E_OPENFILE 0x8000000F 

打开文件出现错误 

◆ MV_E_BUF_IN_USE 

#define MV_E_BUF_IN_USE 0x80000010 

缓存地址已使用 

◆ MV_E_BUF_INVALID 

#define MV_E_BUF_INVALID 0x80000011 

无效的缓存地址 

◆ MV_E_NOALIGN_BUF 

#define MV_E_NOALIGN_BUF 0x80000012 

缓存对齐异常 ◆ MV_E_NOENOUGH_BUF_NUM 

#define MV_E_NOENOUGH_BUF_NUM 0x80000013 

缓存个数不足 

◆ MV_E_PORT_IN_USE 

#define MV_E_PORT_IN_USE 0x80000014 

串口被占用 

◆ MV_E_IMAGE_DECODEC 

#define MV_E_IMAGE_DECODEC 0x80000015 

解码错误 (SDK 校验图像异常 )

◆ MV_E_UINT32_LIMIT 

#define MV_E_UINT32_LIMIT 0x80000016 

图像大小超出 unsigned int 数据类型上限值 

◆ MV_E_IMAGE_HEIGHT 

#define MV_E_IMAGE_HEIGHT 0x80000017 

图像高度异常（残帧丢弃） 

◆ MV_E_NOENOUGH_DDR 

#define MV_E_NOENOUGH_DDR 0x80000018 

DDR 缓存不足 ◆ MV_E_NOENOUGH_STREAM 

#define MV_E_NOENOUGH_STREAM 0x80000019 

流通道不足 

◆ MV_E_UNKNOW 

#define MV_E_UNKNOW 0x800000FF 

未知的错误 

◆ MV_E_GC_GENERIC 

#define MV_E_GC_GENERIC 0x80000100 

通用错误 

◆ MV_E_GC_ARGUMENT 

#define MV_E_GC_ARGUMENT 0x80000101 

参数非法 

◆ MV_E_GC_RANGE 

#define MV_E_GC_RANGE 0x80000102 

值超出范围 

◆ MV_E_GC_PROPERTY 

#define MV_E_GC_PROPERTY 0x80000103 

属性 ◆ MV_E_GC_RUNTIME 

#define MV_E_GC_RUNTIME 0x80000104 

运行环境有问题 

◆ MV_E_GC_LOGICAL 

#define MV_E_GC_LOGICAL 0x80000105 

逻辑错误 

◆ MV_E_GC_ACCESS 

#define MV_E_GC_ACCESS 0x80000106 

节点访问条件有误 

◆ MV_E_GC_TIMEOUT 

#define MV_E_GC_TIMEOUT 0x80000107 

超时 

◆ MV_E_GC_DYNAMICCAST 

#define MV_E_GC_DYNAMICCAST 0x80000108 

转换异常 

◆ MV_E_GC_UNKNOW 

#define MV_E_GC_UNKNOW 0x800001FF 

GenICam 未知错误 ◆ MV_E_NOT_IMPLEMENTED 

#define MV_E_NOT_IMPLEMENTED 0x80000200 

命令不被设备支持 

◆ MV_E_INVALID_ADDRESS 

#define MV_E_INVALID_ADDRESS 0x80000201 

访问的目标地址不存在 

◆ MV_E_WRITE_PROTECT 

#define MV_E_WRITE_PROTECT 0x80000202 

目标地址不可写 

◆ MV_E_ACCESS_DENIED 

#define MV_E_ACCESS_DENIED 0x80000203 

设备无访问权限 

◆ MV_E_BUSY 

#define MV_E_BUSY 0x80000204 

设备忙，或网络断开 

◆ MV_E_PACKET 

#define MV_E_PACKET 0x80000205 

网络包数据错误 ◆ MV_E_NETER 

#define MV_E_NETER 0x80000206 

网络相关错误 

◆ MV_E_SUPPORT_MODIFY_DEVICE_IP 

#define MV_E_SUPPORT_MODIFY_DEVICE_IP 0x8000020E 

在固定 IP 模式下不支持修改设备 IP 模式 

◆ MV_E_KEY_VERIFICATION 

#define MV_E_KEY_VERIFICATION 0x8000020F 

秘钥校验错误 

◆ MV_E_IP_CONFLICT 

#define MV_E_IP_CONFLICT 0x80000221 

设备 IP 冲突 

◆ MV_E_USB_READ 

#define MV_E_USB_READ 0x80000300 

读USB 出错 

◆ MV_E_USB_WRITE 

#define MV_E_USB_WRITE 0x80000301 

写USB 出错 ◆ MV_E_USB_DEVICE 

#define MV_E_USB_DEVICE 0x80000302 

设备异常 

◆ MV_E_USB_GENICAM 

#define MV_E_USB_GENICAM 0x80000303 

GenICam 相关错误 

◆ MV_E_USB_BANDWIDTH 

#define MV_E_USB_BANDWIDTH 0x80000304 

带宽不足 

◆ MV_E_USB_DRIVER 

#define MV_E_USB_DRIVER 0x80000305 

驱动不匹配或者未装驱动 

◆ MV_E_USB_UNKNOW 

#define MV_E_USB_UNKNOW 0x800003FF 

USB 未知的错误 

◆ MV_E_UPG_FILE_MISMATCH 

#define MV_E_UPG_FILE_MISMATCH 0x80000400 

升级固件不匹配 ◆ MV_E_UPG_LANGUSGE_MISMATCH 

#define MV_E_UPG_LANGUSGE_MISMATCH 0x80000401 

升级固件语言不匹配 

◆ MV_E_UPG_CONFLICT 

#define MV_E_UPG_CONFLICT 0x80000402 

升级冲突（设备已经在升级了再次请求升级即返回此错误） 

◆ MV_E_UPG_INNER_ERR 

#define MV_E_UPG_INNER_ERR 0x80000403 

升级时设备内部出现错误 

◆ MV_E_UPG_UNKNOW 

#define MV_E_UPG_UNKNOW 0x800004FF 

升级时未知错误 

◆ MV_EXCEPTION_DEV_DISCONNECT 

#define MV_EXCEPTION_DEV_DISCONNECT 0x00008001 

设备断开连接 

◆ MV_EXCEPTION_VERSION_CHECK 

#define MV_EXCEPTION_VERSION_CHECK 0x00008002 

SDK 与驱动版本不匹配 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 算法库透传状态码 

> 状态码

# 通用类型错误码 

0x00000000 、0x10000000 

#define MV_ALG_OK 0x00000000 

处理正确 更多 ... 

#define MV_ALG_ERR 0x10000000 

不确定类型错误 更多 ... 

# 能力检查错误码 

0x10000001 

#define MV_ALG_E_ABILITY_ARG 0x10000001 

能力集中存在无效参数 更多 ... 内存检查错误码 

范围为 0x10000002-0x10000006 

#define MV_ALG_E_MEM_NULL 0x10000002 

内存地址为空 更多 ... 

#define MV_ALG_E_MEM_ALIGN 0x10000003 

内存对齐不满足要求 更多 ... 

#define MV_ALG_E_MEM_LACK 0x10000004 

内存空间大小不够 更多 ... 

#define MV_ALG_E_MEM_SIZE_ALIGN 0x10000005 

内存空间大小不满足对齐要求 更多 ... 

#define MV_ALG_E_MEM_ADDR_ALIGN 0x10000006 

内存地址不满足对齐要求 更多 ... 

# 图像检查错误码 

范围为 0x10000007-0x1000000A 

#define MV_ALG_E_IMG_FORMAT 0x10000007 

图像格式不正确或者不支持 更多 ... 

#define MV_ALG_E_IMG_SIZE 0x10000008 

图像宽高不正确或者超出范围 更多 ... 

#define MV_ALG_E_IMG_STEP 0x10000009 

图像宽高与 step 参数不匹配 更多 ... 

#define MV_ALG_E_IMG_DATA_NULL 0x1000000A 

图像数据存储地址为空（某个分量） 更多 ... 输入输出参数检查错误码 

范围为 0x1000000B-0x10000010 

#define MV_ALG_E_CFG_TYPE 0x1000000B 

设置或者获取参数类型不正确 更多 ... 

#define MV_ALG_E_CFG_SIZE 0x1000000C 

设置或者获取参数的输入、输出结构体大小不正确 更多 ... 

#define MV_ALG_E_PRC_TYPE 0x1000000D 

处理类型不正确 更多 ... 

#define MV_ALG_E_PRC_SIZE 0x1000000E 

处理时输入、输出参数大小不正确 更多 ... 

#define MV_ALG_E_FUNC_TYPE 0x1000000F 

子处理类型不正确 更多 ... 

#define MV_ALG_E_FUNC_SIZE 0x10000010 

子处理时输入、输出参数大小不正确 更多 ... 

# 能运行参数检查错误码 

范围为 0x10000011-0x10000013 

#define MV_ALG_E_PARAM_INDEX 0x10000011 

index 参数不正确 更多 ... 

#define MV_ALG_E_PARAM_VALUE 0x10000012 

value 参数不正确或者超出范围 更多 ... 

#define MV_ALG_E_PARAM_NUM 0x10000013 

param_num 参数不正确 更多 ... 接口调用检查错误码 

范围为 0x10000014-0x10000016 

#define MV_ALG_E_NULL_PTR 0x10000014 

函数参数指针为空 更多 ... 

#define MV_ALG_E_OVER_MAX_MEM 0x10000015 

超过限定的最大内存 更多 ... 

#define MV_ALG_E_CALL_BACK 0x10000016 

回调函数出错 更多 ... 

# 算法库加密相关检查错误码 

范围为 0x10000017-0x10000018 

#define MV_ALG_E_ENCRYPT 0x10000017 

加密错误 更多 ... 

#define MV_ALG_E_EXPIRE 0x10000018 

算法库使用期限错误 更多 ... 

# 基本错误类型错误码 

范围为 0x10000019-0x1000001B 

#define MV_ALG_E_BAD_ARG 0x10000019 

参数范围不正确 更多 ... 

#define MV_ALG_E_DATA_SIZE 0x1000001A 

数据大小不正确 更多 ... 

#define MV_ALG_E_STEP 0x1000001B 

数据 step 不正确 更多 ... 降噪特有错误码 

范围为 0x10402001-0x1040200f 

#define MV_ALG_E_DENOISE_NE_IMG_FORMAT 0x10402001 

噪声特性图像格式错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_FEATURE_TYPE 0x10402002 

噪声特性类型错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_PROFILE_NUM 0x10402003 

噪声特性个数错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_GAIN_NUM 0x10402004 

噪声特性增益个数错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_GAIN_VAL 0x10402005 

噪声曲线增益值输入错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_BIN_NUM 0x10402006 

噪声曲线柱数错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_INIT_GAIN 0x10402007 

噪声估计初始化增益设置错误 更多 ... 

#define MV_ALG_E_DENOISE_NE_NOT_INIT 0x10402008 

噪声估计未初始化 更多 ... 

#define MV_ALG_E_DENOISE_COLOR_MODE 0x10402009 

颜色空间模式错误 更多 ... 

#define MV_ALG_E_DENOISE_ROI_NUM 0x1040200a 

图像 ROI 个数错误 更多 ... 

#define MV_ALG_E_DENOISE_ROI_ORI_PT 0x1040200b 

图像 ROI 原点错误 更多 ... 

#define MV_ALG_E_DENOISE_ROI_SIZE 0x1040200c 图像 ROI 大小错误 更多 ... 

#define MV_ALG_E_DENOISE_GAIN_NOT_EXIST 0x1040200d 

输入的相机增益不存在（增益个数已达上限） 更多 ... 

#define MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE 0x1040200e 

输入的相机增益不在范围内 更多 ... 

#define MV_ALG_E_DENOISE_NP_BUF_SIZE 0x1040200f 

输入的噪声特性内存大小错误 更多 ... 

# 去紫边特有错误码 

范围为 0x10405000-0x10405002 

#define MV_ALG_E_PFC_ROI_PT 0x10405000 

去紫边算法 ROI 原点错误 更多 ... 

#define MV_ALG_E_PFC_ROI_SIZE 0x10405001 

去紫边算法 ROI 大小错误 更多 ... 

#define MV_ALG_E_PFC_KERNEL_SIZE 0x10405002 

去紫边算法滤波核尺寸错误 更多 ... 

# 其他错误码 

范围为 0x1000001C-0x1000002C 

#define MV_ALG_E_CPUID 0x1000001C 

cpu 不支持优化代码中的指令集 更多 ... 

#define MV_ALG_WARNING 0x1000001D 

警告 更多 ... 

#define MV_ALG_E_TIME_OUT 0x1000001E 

算法库超时 更多 ... #define MV_ALG_E_LIB_VERSION 0x1000001F 

算法版本号出错 更多 ... 

#define MV_ALG_E_MODEL_VERSION 0x10000020 

模型版本号出错 更多 ... 

#define MV_ALG_E_GPU_MEM_ALLOC 0x10000021 

GPU 内存分配错误 更多 ... 

#define MV_ALG_E_FILE_NON_EXIST 0x10000022 

文件不存在 更多 ... 

#define MV_ALG_E_NONE_STRING 0x10000023 

字符串为空 更多 ... 

#define MV_ALG_E_IMAGE_CODEC 0x10000024 

图像解码器错误 更多 ... 

#define MV_ALG_E_FILE_OPEN 0x10000025 

打开文件错误 更多 ... 

#define MV_ALG_E_FILE_READ 0x10000026 

文件读取错误 更多 ... 

#define MV_ALG_E_FILE_WRITE 0x10000027 

文件写错误 更多 ... 

#define MV_ALG_E_FILE_READ_SIZE 0x10000028 

文件读取大小错误 更多 ... 

#define MV_ALG_E_FILE_TYPE 0x10000029 

文件类型错误 更多 ... 

#define MV_ALG_E_MODEL_TYPE 0x1000002A 

模型类型错误 更多 ... 

#define MV_ALG_E_MALLOC_MEM 0x1000002B 

分配内存错误 更多 ... #define MV_ALG_E_BIND_CORE_FAILED 0x1000002C 

线程绑核失败 更多 ... 

# 详细描述 

# 宏定义说明 

◆ MV_ALG_OK 

#define MV_ALG_OK 0x00000000 

处理正确 

◆ MV_ALG_ERR 

#define MV_ALG_ERR 0x10000000 

不确定类型错误 

◆ MV_ALG_E_ABILITY_ARG 

#define MV_ALG_E_ABILITY_ARG 0x10000001 

能力集中存在无效参数 

◆ MV_ALG_E_MEM_NULL 

#define MV_ALG_E_MEM_NULL 0x10000002 

内存地址为空 ◆ MV_ALG_E_MEM_ALIGN 

#define MV_ALG_E_MEM_ALIGN 0x10000003 

内存对齐不满足要求 

◆ MV_ALG_E_MEM_LACK 

#define MV_ALG_E_MEM_LACK 0x10000004 

内存空间大小不够 

◆ MV_ALG_E_MEM_SIZE_ALIGN 

#define MV_ALG_E_MEM_SIZE_ALIGN 0x10000005 

内存空间大小不满足对齐要求 

◆ MV_ALG_E_MEM_ADDR_ALIGN 

#define MV_ALG_E_MEM_ADDR_ALIGN 0x10000006 

内存地址不满足对齐要求 

◆ MV_ALG_E_IMG_FORMAT 

#define MV_ALG_E_IMG_FORMAT 0x10000007 

图像格式不正确或者不支持 

◆ MV_ALG_E_IMG_SIZE 

#define MV_ALG_E_IMG_SIZE 0x10000008 

图像宽高不正确或者超出范围 ◆ MV_ALG_E_IMG_STEP 

#define MV_ALG_E_IMG_STEP 0x10000009 

图像宽高与 step 参数不匹配 

◆ MV_ALG_E_IMG_DATA_NULL 

#define MV_ALG_E_IMG_DATA_NULL 0x1000000A 

图像数据存储地址为空（某个分量） 

◆ MV_ALG_E_CFG_TYPE 

#define MV_ALG_E_CFG_TYPE 0x1000000B 

设置或者获取参数类型不正确 

◆ MV_ALG_E_CFG_SIZE 

#define MV_ALG_E_CFG_SIZE 0x1000000C 

设置或者获取参数的输入、输出结构体大小不正确 

◆ MV_ALG_E_PRC_TYPE 

#define MV_ALG_E_PRC_TYPE 0x1000000D 

处理类型不正确 

◆ MV_ALG_E_PRC_SIZE 

#define MV_ALG_E_PRC_SIZE 0x1000000E 

处理时输入、输出参数大小不正确 ◆ MV_ALG_E_FUNC_TYPE 

#define MV_ALG_E_FUNC_TYPE 0x1000000F 

子处理类型不正确 

◆ MV_ALG_E_FUNC_SIZE 

#define MV_ALG_E_FUNC_SIZE 0x10000010 

子处理时输入、输出参数大小不正确 

◆ MV_ALG_E_PARAM_INDEX 

#define MV_ALG_E_PARAM_INDEX 0x10000011 

index 参数不正确 

◆ MV_ALG_E_PARAM_VALUE 

#define MV_ALG_E_PARAM_VALUE 0x10000012 

value 参数不正确或者超出范围 

◆ MV_ALG_E_PARAM_NUM 

#define MV_ALG_E_PARAM_NUM 0x10000013 

param_num 参数不正确 

◆ MV_ALG_E_NULL_PTR 

#define MV_ALG_E_NULL_PTR 0x10000014 

函数参数指针为空 ◆ MV_ALG_E_OVER_MAX_MEM 

#define MV_ALG_E_OVER_MAX_MEM 0x10000015 

超过限定的最大内存 

◆ MV_ALG_E_CALL_BACK 

#define MV_ALG_E_CALL_BACK 0x10000016 

回调函数出错 

◆ MV_ALG_E_ENCRYPT 

#define MV_ALG_E_ENCRYPT 0x10000017 

加密错误 

◆ MV_ALG_E_EXPIRE 

#define MV_ALG_E_EXPIRE 0x10000018 

算法库使用期限错误 

◆ MV_ALG_E_BAD_ARG 

#define MV_ALG_E_BAD_ARG 0x10000019 

参数范围不正确 

◆ MV_ALG_E_DATA_SIZE 

#define MV_ALG_E_DATA_SIZE 0x1000001A 

数据大小不正确 ◆ MV_ALG_E_STEP 

#define MV_ALG_E_STEP 0x1000001B 

数据 step 不正确 

◆ MV_ALG_E_DENOISE_NE_IMG_FORMAT 

#define MV_ALG_E_DENOISE_NE_IMG_FORMAT 0x10402001 

噪声特性图像格式错误 

◆ MV_ALG_E_DENOISE_NE_FEATURE_TYPE 

#define MV_ALG_E_DENOISE_NE_FEATURE_TYPE 0x10402002 

噪声特性类型错误 

◆ MV_ALG_E_DENOISE_NE_PROFILE_NUM 

#define MV_ALG_E_DENOISE_NE_PROFILE_NUM 0x10402003 

噪声特性个数错误 

◆ MV_ALG_E_DENOISE_NE_GAIN_NUM 

#define MV_ALG_E_DENOISE_NE_GAIN_NUM 0x10402004 

噪声特性增益个数错误 

◆ MV_ALG_E_DENOISE_NE_GAIN_VAL 

#define MV_ALG_E_DENOISE_NE_GAIN_VAL 0x10402005 

噪声曲线增益值输入错误 ◆ MV_ALG_E_DENOISE_NE_BIN_NUM 

#define MV_ALG_E_DENOISE_NE_BIN_NUM 0x10402006 

噪声曲线柱数错误 

◆ MV_ALG_E_DENOISE_NE_INIT_GAIN 

#define MV_ALG_E_DENOISE_NE_INIT_GAIN 0x10402007 

噪声估计初始化增益设置错误 

◆ MV_ALG_E_DENOISE_NE_NOT_INIT 

#define MV_ALG_E_DENOISE_NE_NOT_INIT 0x10402008 

噪声估计未初始化 

◆ MV_ALG_E_DENOISE_COLOR_MODE 

#define MV_ALG_E_DENOISE_COLOR_MODE 0x10402009 

颜色空间模式错误 

◆ MV_ALG_E_DENOISE_ROI_NUM 

#define MV_ALG_E_DENOISE_ROI_NUM 0x1040200a 

图像 ROI 个数错误 

◆ MV_ALG_E_DENOISE_ROI_ORI_PT 

#define MV_ALG_E_DENOISE_ROI_ORI_PT 0x1040200b 

图像 ROI 原点错误 ◆ MV_ALG_E_DENOISE_ROI_SIZE 

#define MV_ALG_E_DENOISE_ROI_SIZE 0x1040200c 

图像 ROI 大小错误 

◆ MV_ALG_E_DENOISE_GAIN_NOT_EXIST 

#define MV_ALG_E_DENOISE_GAIN_NOT_EXIST 0x1040200d 

输入的相机增益不存在（增益个数已达上限） 

◆ MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE 

#define MV_ALG_E_DENOISE_GAIN_BEYOND_RANGE 0x1040200e 

输入的相机增益不在范围内 

◆ MV_ALG_E_DENOISE_NP_BUF_SIZE 

#define MV_ALG_E_DENOISE_NP_BUF_SIZE 0x1040200f 

输入的噪声特性内存大小错误 

◆ MV_ALG_E_PFC_ROI_PT 

#define MV_ALG_E_PFC_ROI_PT 0x10405000 

去紫边算法 ROI 原点错误 

◆ MV_ALG_E_PFC_ROI_SIZE 

#define MV_ALG_E_PFC_ROI_SIZE 0x10405001 

去紫边算法 ROI 大小错误 ◆ MV_ALG_E_PFC_KERNEL_SIZE 

#define MV_ALG_E_PFC_KERNEL_SIZE 0x10405002 

去紫边算法滤波核尺寸错误 

◆ MV_ALG_E_CPUID 

#define MV_ALG_E_CPUID 0x1000001C 

cpu 不支持优化代码中的指令集 

◆ MV_ALG_WARNING 

#define MV_ALG_WARNING 0x1000001D 

警告 

◆ MV_ALG_E_TIME_OUT 

#define MV_ALG_E_TIME_OUT 0x1000001E 

算法库超时 

◆ MV_ALG_E_LIB_VERSION 

#define MV_ALG_E_LIB_VERSION 0x1000001F 

算法版本号出错 

◆ MV_ALG_E_MODEL_VERSION 

#define MV_ALG_E_MODEL_VERSION 0x10000020 

模型版本号出错 ◆ MV_ALG_E_GPU_MEM_ALLOC 

#define MV_ALG_E_GPU_MEM_ALLOC 0x10000021 

GPU 内存分配错误 

◆ MV_ALG_E_FILE_NON_EXIST 

#define MV_ALG_E_FILE_NON_EXIST 0x10000022 

文件不存在 

◆ MV_ALG_E_NONE_STRING 

#define MV_ALG_E_NONE_STRING 0x10000023 

字符串为空 

◆ MV_ALG_E_IMAGE_CODEC 

#define MV_ALG_E_IMAGE_CODEC 0x10000024 

图像解码器错误 

◆ MV_ALG_E_FILE_OPEN 

#define MV_ALG_E_FILE_OPEN 0x10000025 

打开文件错误 

◆ MV_ALG_E_FILE_READ 

#define MV_ALG_E_FILE_READ 0x10000026 

文件读取错误 ◆ MV_ALG_E_FILE_WRITE 

#define MV_ALG_E_FILE_WRITE 0x10000027 

文件写错误 

◆ MV_ALG_E_FILE_READ_SIZE 

#define MV_ALG_E_FILE_READ_SIZE 0x10000028 

文件读取大小错误 

◆ MV_ALG_E_FILE_TYPE 

#define MV_ALG_E_FILE_TYPE 0x10000029 

文件类型错误 

◆ MV_ALG_E_MODEL_TYPE 

#define MV_ALG_E_MODEL_TYPE 0x1000002A 

模型类型错误 

◆ MV_ALG_E_MALLOC_MEM 

#define MV_ALG_E_MALLOC_MEM 0x1000002B 

分配内存错误 

◆ MV_ALG_E_BIND_CORE_FAILED 

#define MV_ALG_E_BIND_CORE_FAILED 0x1000002C 

线程绑核失败 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 相机参数节点表 

本表格中包含了大部分相机的所有节点以及每个节点的名称、数据类型、访问模式等。相机不是所 有的节点都支持，请以客户端中的参数列表为准。 

相机的参数持续更新中，表中可能不包含相机最新固件的支持的参数。 

功能 名称（ _GetNode: key 

参数） 

数据类 型 数值范围定义 

访问模式

描述 

DeviceType IEnumer ation 

0:Transmitter 1:Receiver 2:Transceiver 3:Peripheral 

R 设备 类型 

Device Control 

DeviceScanType IEnumer ation 

0:Areascan 1:Linescan R

设备 

sens or 的扫描 方式 ，表 明是 线阵 相机 还是 面阵 相机 

DeviceVendorName IString 任意空终止字符串 R

设备 的制 造商 名称 

DeviceModelName IString 任意空终止字符串 R 设备 型号 

DeviceManufacturerInfo IString 任意空终止字符串 R

设备 的制 造商 信息 

DeviceVersion IString 任意空终止字符串 R 设备 版本 

DeviceFirmwareVersion IString 任意空终止字符串 R 固件 版本 

DeviceSerialNumber IString 任意空终止字符串 R

设备 序列 号

DeviceID IString 任意空终止字符串 R 设备 

ID 

DeviceUserID IString 任意空终止字符串 R/ W

用户 自定 义的 名称 

DeviceUptime Iinteger ≥ 0 R

设备 运行 时间 

BoardDeviceType Iinteger ≥ 0 R 设备 类型 

DeviceConnectionSelector Iinteger ≥ 0 R/( W) 

设备 连接 选择 DeviceConnectionSpeed Iinteger ≥ 0 ，单位 Mbps R

设备 连接 速度 

DeviceLinkSelector IInteger ≥ 0 R/( W) 

设备 连接 选择 

DeviceLinkSpeed IInteger ≥ 0 R

传输 链路 速度 

DeviceLinkConnectionCou nt IInteger ≥ 0 R

设备 连接 数量 

DeviceLinkHeartbeatMode IEnumer ation 

0:On 1:Off 

R/ W

是否 需要 心跳 

DeviceStreamChannelCou nt Iinteger ≥ 0 R

流通 道数 量

DeviceStreamChannelSele ctor Iinteger ≥ 0 R/( W) 

流通 道选 择

DeviceStreamChannelTyp e

Ienumer ation 

0:Transmitter 1:Receiver R

流通 道类 型

DeviceStreamChannelLink Iinteger ≥ 0 R

流通 道连 接数 量

DeviceStreamChannelEndi anness 

Ienumer ation 

0: Little 1: Big R

图像 数据 的字 节序 

DeviceStreamChannelPac ketSize IInteger 与相机相关。一般范围 在 220-9156 ，步进为 8

R/( W) 

接收 端流 数据 的包 大小 

DeviceEventChannelCount IInteger ≥ 0 R

设备 支持 的

DeviceCharacterSet IEnumer ation 

1:UTF-8 2: ASCII R

设备 寄存 器中 使用 的字 符集 

DeviceReset IComma nd - W 重启 设备 

DeviceMaxThroughput Iinteger ≥ 0 R

设备 最大 吞吐 量（ 带宽 ）

WidthMax IInteger ＞ 0 R

图像 最大 宽度 ，

binni ng 之后的 数据 

Image Format Control 

HeightMax IInteger ＞ 0 R

图像 最大 高度 ，

binni ng 之后的 数据 RegionSelector IEnumer ation 

0:Region0 1:Region1 2:Region2 8:All 

R/( W) 

ROI 

选择 器

RegionDestination IEnumer ation 

0:Stream0 1:Stream1 2:Stream2 

R/( W) 

该

ROI 

对应 的码 流

Width IInteger ＞ 0 R/( W) 

ROI 

的宽 

Height IInteger ＞ 0 R/( W) 

ROI 

的高 

OffsetX IInteger ≥ 0 R/ W

ROI 

的水 平方 向偏 移量 

OffsetY IInteger ≥ 0 R/ W

ROI 

的竖 直方 向偏 移量 

ReverseScanDirection Iboolean ≥ 0 R/( W) 

转换 扫描 方向 

PixelFormat IEnumer ation 

0x01080001:Mono8 0x01100003:Mono10 0x010C0004:Mono10 Packed 0x01100005:Mono12 0x010C0006:Mono12 Packed 0x01100007:Mono16 0x02180014:RGB8Pa cked 0x02100032:YUV422_ 

R/( W) 

图像 像素 格式 ，不 同型 号的 相机 ，支 持的 像素 格式 80x0210001F:YUV422_ 8_UYVY 0x01080008:BayerGR 80x01080009:BayerRG 80x0108000A:BayerGB 80x0108000B:BayerBG 80x0110000e:BayerGB 10 0x01100012:BayerGB 12 0x010C002C:BayerGB 12Packed 

有差 异， 以实 际的 为准 

PixelSize IEnumer ation 

8:Bpp8 10:Bpp10 12:Bpp12 16:Bpp16 24:Bpp24 32:Bpp32 

R/( W) 

一个 像素 包含 的比 特数 

ImageCompressionMode IEnumer ation 

0:Off 1:JPEG 

R/( W) 

图像 压缩 模式 

ImageCompressionQuality Iinteger ≥ 50 R/( W) 

图像 压缩 质量 

TestPatternGeneratorSele ctor 

IEnumer ation 

8:Sensor 0:Region0 1:Region1 2:Region2 

R/( W) 

测试 图像 生成 器选 择

TestPattern IEnumer ation 

0 :Off 1:Black 2:White 

R/( W) 

测试 图像 选择 3:GreyHorizontalRamp 4:GreyVerticalRamp 5:GreyHorizontalRamp Moving 6:GreyVerticalRampM oving 7:HorizontalLineMovin g8:VerticalLineMoving 9:ColorBar 10:FrameCounter 11:MonoBar 12:TestImage12 13:TestImage13 14:ObliqueMonoBar 15:ObliqueColorBar 16:GradualMonoBar 

FrameSpecInfoSelector IEnumer ation 

0 :Timestamp 1:Gain 2:Exposure 3:BrightnessInfo 4:WhiteBalance 5:Framecounter 6:ExtTriggerCount 7:LineInputOutput 8:ROIPosition 

R/( W) 

水印 信息 选择 

FrameSpecInfo IBoolean True False 

R/ W

是否 使能 该水 印信 息

Acquisi tion Control 

AcquisitionMode IEnumer ation 

0:SingleFrame 1:MultiFrame 2:Continuous 

R/( W) 

采集 模式 ，单 帧、 多帧 、连 续AcquisitionStart IComma nd - W 开始 取流 

AcquisitionStop IComma nd - W 结束 取流 

AcquisitionBurstFrameCou nt IInteger ≥ 0 R/ W

一次 触发 采集 的帧 数

AcquisitionLineRate IInteger ≥ 1 R/ W

行频 设置 

AcquisitionLineRateEnable IBoolean True False 

R/ W

行频 控制 使能 

ResultingLineRate IInteger ≥ 0，单位 hz R 实际 行频 

ResultingFrameRate IFloat ≥ 0.0 ，单位 fps R

相机 的实 际采 集帧 率

TriggerSelector IEnumer ation 

0:AcquisitionStart 1:AcquisitionEnd 2:AcquisitionActive 3:FrameStart 4:FrameEnd 5:FrameActive 6:FrameBurstStart 7:FrameBurstEnd 8:FrameBurstActive 9:LineStart 10:ExposureStart 11:ExposureEnd 12:ExposureActive 

R/ W

触发 事件 选择 

TriggerMode IEnumer ation 

0:Off 1:On 

R/ W

触发 模式 TriggerSource IEnumer ation 

0:Line0 1:Line1 2:Line2 3.Line3 4:Counter0 7:Software 8:FrequencyConverter 

R/ W

触发 源

TriggerActivation IEnumer ation 

0:RisingEdge 1:FallingEdge 2:LevelHigh 3:LevelLow 

R/ W

触发 上升 沿、 下降 沿、 高电 平、 低电 平等 

TriggerDelay IFloat ≥ 0.0 ，单位 us R/ W

触发 延时 

ExposureMode IEnumer ation 

0:Timed 1:TriggerWidth 

R/ W

曝光 模式 选择 

ExposureTime IFloat ≥ 0.0 ，单位 us R/ W

曝光 时间 

ExposureAuto IEnumer ation 

0:Off 1:Once 2:Continuous 

R/ W

自动 曝光 

AutoExposureTimeLowerLi mit IInteger ≥ 0 ，单位 us R/( W) 

自动 曝光 时间 下限 

AutoExposureTimeUpperLi mit IInteger ≥ 0 ，单位 us R/( W) 

自动 曝光 时间 上限 FrameTimeoutEnable IBoolean 0:Off 1:On 

R/ W

帧超 时使 能

FrameTimeoutTime Iinteger ≥ 87 ，单位 ms R/ W

帧超 时时 间

Gain IFloat ≥ 0.0 ，单位 dB R/ W

增益 值

GainAuto IEnumer ation 

0:Off 1:Once 2:Continuous 

R/ W

自动 增益 

AutoGainLowerLimit IFloat ≥ 0.0 ，单位 dB R/ W

自动 增益 值下 限

AutoGainUpperLimit IFloat ≥ 0.0 ，单位 dB R/ W

自动 增益 值上 限

ADCGainEnable IBoolean 0:Off 1:On 

R/ W

ADC 

增益 使能 

DigitalShift IFloat ≥ 0.0 R

数字 偏移 调节 

DigitalShiftEnable IBoolean 0:Off 1:On 

R/ W

数字 偏移 使能 

Brightness Iinteger ≥ 0 R/ W 亮度 

BlackLevel IFloat ≥ 0.0 R/ W

黑电 平调 节

Analog Control 

BlackLevelEnable IBoolean 0:Off 1:On 

R/ W

黑电 平调 节使 能

BalanceWhiteAuto IEnumer ation 

0:Off 1:Continuous 2:Once 

R/ W

自动 白平 衡

BalanceRatioSelector Ienumer ation 

0:Red 1:Green 2:Blue 

R

白平 衡比 例选 择

BalanceRatio Iinteger ≥ 0 R 白平 衡值 

Gamma IFloat ＞ 0.0 R/ W

伽马 调节 

GammaSelector Ienumer ation 

1:User 2:sRGB 

R/ W

Gam ma 

选择 

GammaEnable IBoolean 0:Off 1:On 

R/ W

Gam ma 

使能 

Hue Iinteger ≥ 0 R

色度 值调 节

HueEnable Iboolean 0:Off 1:On 

R/ W

色度 使能 

Saturation Iinteger ≥ 0 R

饱和 度值 调节 

SaturationEnable Iboolean 0:Off 1:On 

R/ W

饱和 度使 能

AutoFunctionAOISelector Ienumer ation 

0:AOI1 1:AOI2 

R/ W

自动 

AOI 

选择 AutoFunctionAOIWidth Iinteger ≥ 0 R/ W

自动 

AOI 

宽

AutoFunctionAOIHeight Iinteger ≥ 0 R/ W

自动 

AOI 

高

AutoFunctionAOIOffsetX Iinteger ≥ 0 R

自动 

AOI 

水平 方向 偏移 

AutoFunctionAOIUsageInt ensity Iboolean 0:Off 1:On 

R/ W

根据 

AOI 

区域 自动 曝光 

AutoFunctionAOIUsageWh iteBalance Iboolean 0:Off 1:On R

根据 

AOI 

区域 自动 白平 衡

LUTSelector IEnumer ation 

0:Luminance 1:Red 2:Green 3:Blue 

R/ W

亮度 、

R/G/ B

LUTEnable IBoolean True False 

R/ W 使能 

LUTIndex IInteger ≥ 0 R/ W

索引 号

LUT Control 

LUTValue IInteger Device-specific R/ W 值

Encode rControl 

EncoderSelector IEnumer ation 

0:Encoder0 1:Encoder1 2:Encoder2 

R/ W

编码 器选 择EncoderSourceA IEnumer ation 

0:Line0 1:Line1 2:Line2 3:Line3 

R/ W

编码 器 A

源选 择

EncoderSourceB IEnumer ation 

0:Line0 1:Line1 2:Line2 3:Line3 

R/ W

编码 器 B

源选 择

EncoderTriggerMode IEnumer ation 

0:AnyDirection 1:ForwardOnly 

R/ W

编码 器触 发模 式

EncoderCounterMode IEnumer ation 

0:IgnoreDirection 1:FollowDirection 

R/ W

编码 器计 数模 式

EncoderCounter Iinteger ≥ 0 R

编码 器计 数器 值调 节

EncoderCounterMax Iinteger ≥ 1 R/ W

编码 器计 数器 最大 值

EncoderCounterReset Icomman d - R/ W

编码 器计 数器 复位 

EncoderMaxReverseCount er Iinteger ≥ 1 R/ W

编码 器最 大反 转计 数器 值EncoderReverseCounterR eset 

Icomman d - R/ W

编码 器反 转计 数器 复位 

InputSource Ienumer ation 

0:Line0 1:Line1 2:Line2 3:Line3 

R/ W

分频 器输 入源 

SignalAlignment Ienumer ation 

0:RisingEdge 1:FallingEdge 

R/ W

分频 器信 号方 向

PreDivider Iinteger ≥ 1 R/ W

前置 分频 器调 节

Multiplier Iinteger ≥ 1 R/ W

倍频 器调 节

Freque ncy Convert er Control 

PostDivider Iinteger ≥ 1 R/ W

后置 分频 器调 节

ShadingSelector IEnumer ation 

0:FPNCCorrection 1:PRNUCCorrection 

R/ W

明暗 场校 正选 择

ActivateShading IComma nd - R/( W) 

主动 校正 

NUCEnable IBoolean 0:Off 1:ON 

R/ W

NUC 

使能 开关 

Shadin gCorrect ion 

PRNUCEnable IBoolean 0:Off 1:ON 

R/ W

PRN UC 状态 开关 

LineSelector IEnumer ation 

0:Line0 1:Line1 2:Line2 3:Line3 4:Line4 

R/ W

I/O 

选择 

LineMode IEnumer ation 

0:Input 1:Output 2:Trigger 8:Strobe 

R/( W) 

I/O 

模式 

LineStatus IBoolean - R/( W) 

I/O 

状态 

LineStatusAll IInteger ≥ 0 R

所有 

I/O 

状态 

Digital IO Control 

LineDebouncerTime IInteger - R/ W

I/O 

去抖 时间 

PayloadSize IInteger ≥ 0 R

一帧 数据 的大 小

GevVersionMajor IInteger GEV 主版本号 R

GEV 

主版 本号 

GevVersionMinor IInteger GEV 副版本号 R

GEV 

子版 本号 

GevDeviceModeIsBigEndi an IBoolean 0:not BigEndian 1:Is BigEndian R 大端 

Transp ort Layer Control 

GevDeviceModeCharacter Set 

IEnumer ation 1:UTF8 R 字符 集GevInterfaceSelector IInteger >=0 R/( W) 

GEV 

接口 选择 

GevMACAddress IInteger Mac 地址 R MAC 

地址 

GevCurrentIPConfiguration LLA IBoolean 0:Off 1:On R

IP 是否为 

LLA 

GevCurrentIPConfiguration DHCP IBoolean 0:Off 1:On 

R/ W

IP 是否为 

DHC P

GevCurrentIPConfiguration PersistentIP IBoolean 0:Off 1:On 

R/ W

IP 是否为 静态 

IP 

GevCurrentIPAddress Iinteger ip 地址 R IP 地址

GevCurrentSubnetMask Iinteger 子网掩码 R 子网 掩码 

GevCurrentDefaultGatewa y Iinteger 默认网关 R 默认 网关 

GevFirstURL IString - R

XML 

第一 选择 路径 

GevSecondURL IString - R

XML 

第二 选择 路径 

GevNumberOfInterfaces Iinteger ≥ 0 R

GEV 

接口 数

GevPersistentIPAddress Iinteger ≥ 0 R/ W

静态 

IP 地址GevPersistentSubnetMask Iinteger ≥ 0 R/ W

静态 子网 掩码 

GevPersistentDefaultGate way Iinteger ≥ 0 R/ W

静态 默认 网关 

GevLinkSpeed IInteger ≥ 0 R 网络 速率 

GevMessageChannelCoun t Iinteger ≥ 0 R

消息 通道 数

GevStreamChannelCount Iinteger ≥ 0 R 流通 道

GevHeartbeatTimeout Iinteger ≥ 0 R/ W

心跳 超时 时间 

GevGVCPHeartbeatDisabl e IBoolean 0:Off 1:On 

R/ W

关闭 心跳 

GevTimestampTickFreque ncy Iinteger ≥ 0 ，单位 hz R

时间 戳频 率

GevTimestampControlLatc h

IComma nd - W

获取 时间 戳

GevTimestampControlRes et 

IComma nd - W

复位 时间 戳

GevTimestampControlLatc hReset 

IComma nd - W

复位 时间 戳同 时获 取时 间戳 

GevTimestampValue Iinteger - R 时间 戳值 GevCCP IEnumer ation 

0:OpenAcess 1:ExclusiveAccess 2:ControlAccess 

R/ W

App 

端的 控制 权限 

GevStreamChannelSelecto r Iinteger >=0 R/ W

流通 道选 择

GevSCPInterfaceIndex Iinteger >=0 R

GEV 

接口 索引 

GevSCPHostPort Iinteger >=0 R/( W) 

主机 端口 

GevSCPDirection Iinteger >=0 R

表明 流通 道方 向

GevSCPSFireTestPacket IBoolean 0:Off 1:On 

R/( W) 

Fire Test Pack et 使能

GevSCPSDoNotFragment IBoolean 0:Off 1:On 

R/ W

GEV SCP 

不分 段

GevSCPSBigEndian IBoolean 0:Off 1:On R

流数 据大 小端 

GevSCPSPacketSize IInteger 

＞ 0，与相机相关。一 般范围在 220-9156 ，步进为 8

R/ W

网络 包大 小

GevSCPD IInteger ≥ 0 R/ W

发包 延时 

GevSCDA IInteger IP 地址 R 流数 据的 目的 地址 

GevSCSP IInteger 端口号 R

流数 据的 源端 口

UserSetCurrent Iinteger >=0 R

当前 用户 参数 

UserSetSelector IEnumer ation 

0:Default 1:UserSet1 2:UserSet2 3:UserSet3 

R/ W

设置 载入 的参 数

UserSetLoad IComma nd - W 加载 

UserSetSave IComma nd - W 保存 

User Set Control 

UserSetDefault IEnumer ation 

0:Default 1:UserSet1 2:UserSet2 3:UserSet3 

R/ W

默认 状态 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

# 示例程序概览 

安装工业相机客户端后，您可从客户端的安装路径获取对应的示例程序文件。您可参照提供的示例 ，在您的程序中实现对应功能。 

注解 

此处仅介绍控制台示例。如需了解更多示例，您可前往安装路径下的 

.\Development\Samples 。

示例文件夹内包含如下类别的示例： 

￿ 基础示例 

￿ 采集卡示例 

￿ 面阵相机示例 

￿ 线阵相机示例 

￿ 光源控制器示例 

# 基础示例 

以下为基础示例，您可从 Samples 文件夹下的 General 文件夹中获取对应的示例。 

相机连接基础示例如下： 

文件 示例 描述 

ConnectSpecCamera.cpp 

通过

IP 

地址连接相机

演示通过相机 IP 

地址和相机对应 的网卡 IP 地址， 实现将相机连接 至您的程序。 

注解 

输入的 IP 

地址格式 为

xx.xx.xx.xx 

。ForceIPEx.cpp 

强制设置相机

IP 

演示强制设置网 口相机 IP ，保证 断电后重新连接 ，重新枚举后依 旧生效。 

图像获取基础示例 

文件 示例 描述 

Grab_Asynchronous.cpp 

异步取图及处理

演示如何进行 异步取图和图 像处理。 

注解 

异步操 作可规 避同步 取图时 可能存 在的耗 时长问 题。 

GrabImage.cpp 

获取相机图像

演示通过主动 取图的方式获 取相机图像。 

GrabStrategies.cpp 取图

演示如何使用 不同的取图策 策略

略获取相机采 集的图像。 

Grab_Callback.cpp 

通过回调获取相机图像

演示通过回调 的方式获取相 机图像。 

Grab_ActionCommand.cpp 

PTP 

时钟协议

演示如何通过 

PTP 时钟协议 设置相机进行 采图。 

DynamicallyLoadDLL.cpp 

动态调用

演示动态调用 相机并进行取 图。 

图像处理基础示例 

文件 示例 描述 

ChunkData.cpp 

获取 

Chunk 

信息 

演示如何开 启

ChunkData 

功能、配置 

ChunkData 

以及获取 

ChunkData 

信息。 ChunkData 

包括 

Timestamp 

、Exposure 

等信息。 

GrabImage_Display.cpp 显示相 机图像 

演示如何调 用显示相机 图像接口， 并实时显示 相机采集到 的图像数据 。

HighBandwithDecode.cpp 高清无 损压缩 

演示通过高 清无损压缩 算法将从相 机取到的无 损压缩码流 解码成裸数 据。 

ConvertPixelType.cpp 图像格 式转换 

演示如何通 过图像格式 转换接口将 设备采集到 的原始图像 数据转换成 所需的像素 格式。 

ImageContrast.cpp 

图像对 比度调 节

演示如何采 集图像并调 节采集图像 的对比度。 

Recording.cpp 视频录 像存储 

演示如何将 相机拍摄到 的画面存储 为视频录像 。

ImageSave.cpp 

保存相 机设备 图像 

演示如何保 存从相机设 备拿到的图 像。可保存 的图像格式 包含裸图 

(.raw) 、jpeg 

、bmp 、tiff 

、png 。

参数设置基础示例 

文件 示例 描述 

MultiCast.cpp 

设置组播模式

演示如何设置 传输模式为组 播模式。通过 询问用户启动 多播控制应用 程序或者多播 监控应用程序 ，并以指定的 访问权限打开 相机并设置组 播模式。 

ParametrizeCamera_FileAccess.cpp 

导入或导出文

演示如何导入 文件到相机、 导出相机文件 、以及获取文 件存取进度。 件到相机

ParametrizeCamera_LoadAndSave.cpp 

导入或导出相机属性

演示如何将相 机属性树的设 置导出到 .ini 文件（例如， 

FeatureFile.ini 

）和从 .ini 文件 导入到相机属 性树中。 

事件基础示例 

文件 示例 描述 

Events.cpp 

获取 相机 事件 

演示配置相机事件功能、注 册事件回调以及在事件回调 函数中处理获取到的事件信 息。 Event 事件例如： 

ExposureEnd 。

# 采集卡示例 

以下为采集卡基础示例，您可从 Samples 文件夹下的 FrameGrabber 文件夹中获取对应的示例。 

文件 示例 描述 Events_Interface.cpp 

打开并接受采集卡事件

演示打开并 接收采集卡 事件。 

InterfaceAndDeviceDemo.cpp 

采集卡下的相机控制

演示通过普 通枚举接口 枚举到自研 采集卡下的 相机，并实 现打开相机 、开始取流 等操作。 

InterfaceDemo.cpp 

采集卡的枚举及控制

演示通过枚 举接口枚举 自研采集卡 ，并实现打 开采集卡、 设置属性等 操作。 

QuickSoftwareTrigger.cpp 

采集卡软触发

演示使用采 集卡实现快 速软触发功 能。快速软 触发仅被部 分采集卡支 持，请以采 集卡实际情 况为准。 

# 面阵相机示例 

以下为面阵相机示例，您可从 Samples 文件夹下的 AreaScanCamera 文件夹中获取对应的示例。 

文件 示例

描述

LensShadingCorrection.cpp LSC 

演示如何进行

LSC 

标定和校正。需要先通过

LSC 

标定功能获取到标定表，然后才能对相机图像进行

LSC 

校正处理。

ParametrizeCamera_AreaScanIOSettings.cpp 

面阵相机

IO 

设置

演示如何配置面阵相机触发相关节点

IO 

。

# 线阵相机示例 

以下为线阵相机示例，您可从 Samples 文件夹下的 LineScanCamera 文件夹中获取对应的示例。 

文件 示例 描述 

LineScanSoftwareTrigger.cpp 

线阵相机软触发取图

演示线阵相机如何通过软 触发命令获取图像。 

MultiLightCtrl_ImageStitching.cpp 

线阵相机分时曝光并拆图拼图

演示设置线阵相机采用 2组分时曝光参数，先拆图再 自上而下拼图，最后将拼 好的 raw 图以 bmp 格式保存 至本地。 ParametrizeCamera_LineScanIOSettings.cpp 

线阵相机

IO 

设置

演示通过 

MV_CC_SetEnumValue() 

配置线阵相机帧触发和行 触发相关节点 IO 。

# 光源控制器示例 

以下为光源控制器示例，您可从 Samples 文件夹下的 LightController 文件夹中获取对应的示例。 

文件 示例 描述 

ConfigLightController.cpp 

光源控制器基础配置

演示光源控制器 的触发参数和 IO 

参数控制，包括 常规参数修改， 事件及快速软触 发等。 

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 常见问题 

￿ 问题排查思路 

￿ 常见问题及解决方法 

o GigE 相机问题 

o U3V 相机问题 

# 一、问题排查思路 

1. 基于 SDK 开发的程序异常，建议先运行客户端，查看相应功能是否正常。 

2. 如果客户端正常，但基于 SDK 开发的程序异常，需要重点排查二次开发的程序问题。 

3. 如果客户端也异常，请参考以下典型问题和解决方法。 

4. 若根据以上排查思路仍不能解决问题，请记录问题现象或图片、客户端版本号、库名称和 库版本号，联系技术支持获取支持。 

注解 

客户端版本号、库名称和库版本号可从 客户端 > 帮助 > 关于 中获取。 

# 二、常见问题及解决方法 

1. GigE 相机问题 

1. 无法发现相机 

问题原因 ：防火墙开启，杀毒软件运行，可能阻断了设备通信数据导致无法发现 相机。 

解决方法： o 在控制面板 中，进入 Windows Defender 防火墙 -> 启用或关闭 

Windows Defender 防火墙 ，关闭域网络、专用网络和公用网络的防火 墙。 

o 关闭杀毒软件。 

2. 打开相机失败 

1. 问题原因 ：相机被其他进程连接。 

解决方法 ：您可检查客户端内相机连接状态。若相机状态为被占用，关闭 其他占用相机的程序，并确保相机处于无连接状态。 

2. 问题原因 ：相机心跳时间过长，而程序上一次没有执行关闭设备或者销毁 设备句柄接口，直接异常退出（在调试模式下常见），导致设备一直是占 用状态。 

解决方法 ：您需断电重启相机，或者等待相机心跳超时，从而释放权限。 

3. 问题原因 ：相机和工控机不在同一个网段，连接失败。 

解决方法 ：您可修改相机 IP ，使相机 IP 和PC 在同一个网段中。在客户端 中，右键单击需修改 IP 的设备，单选 修改 IP ，并修改至同一网段。 

注解 

查看和修改 IP 的详细操作步骤，请参见客户端用户手册。 

3. 开始取流失败 

问题原因 ：工控机内存不足。 

解决方法 ：在工控机中，检查系统内存和使用情况。若内存紧张， 在客户端中， 进入 设置 -> 缓存 ，适当降低 取流缓存节点 的取值。 

4. 相机不出图 

问题原因 ：相机配置异常，可能是配置了触发模式，但是未给相机触发信号。 

解决方法 ：检查相机触发配置，例如是否开启触发模式、触发源配置是否正确。 

5. 相机图像花屏 /丢帧 /多帧 

1. 问题原因 ：带宽不足，丢包。 解决方法 ：检查带宽使用情况，避免多个相机使用 1个网口，多个相机分 别使用不同的网口，避免带宽使用率过高。 

2. 问题原因 ：网卡未开启巨帧，网络传输效率偏低。 

解决方法 ：检查环境的巨帧配置，可用开启巨帧，提高网络使用效率。您 可在工控机上，查看网卡属性，并配置 高级 -> 巨型帧 。

3. 问题原因 ：网络原因导致丢包，且您在客户端 设置 -> 网络 中开启了自适 应丢帧。开启后，当 SDK 检测到当前帧数据不完整时，会丢弃整帧。在网 络存在堵塞等问题时，会导致持续无图。 

解决方法 ：关闭自适应丢帧选项，检查带宽使用情况，优化网络。 

4. 问题原因 ：若您使用的为线阵相机，可能由于 PartialImageOutPutMode 

节点配置为 PartialImageDiscard （残帧丢弃）。设置为 

PartialImageDiscard 后，若触发输出的图像高度不足，图像不完整， 

SDK 将不完整的图像丢弃。 

解决方法 ：检查相机 PartialImageOutPutMode 节点配置， 检查外部触发 。

5. 问题原因 ：相机配置了外部触发，但是外部触发信号数量异常，导致相机 在收到信号后出图偏多或者偏少。 

解决方法 ：检查相机触发配置及触发源。 

6. 问题原因 ：调用取流接口后，未及时释放资源，导致 SDK 缓存空间不足， 引起相机发送图像无法存储，丢帧。 

解决方法 ：

￿ 在调用 MV_CC_GetImageBuffer() 拿到图像后，您需及时调用 

MV_CC_FreeImageBuffer() 释放图像。 

￿ 调用 MV_CC_SetImageNodeNum() 增大 SDK 缓冲区。 

6. MV_CC_GetImageBuffer() 接口报错无数据 

1. 问题原因 ：相机没有出图， SDK 接口无法获取图像。 

解决方法 ：检查相机配置，触发源等，确保相机出图。 

2. 问题原因 ：相机出图时间大于接口超时时间。 解决方法 ：调整超时时间（ nMsec ）的值，确保调整后的超时时间大于相 机出图时间。 

3. 问题原因 ：上层获取的图像数据没有及时释放， SDK 内部无空间可用。 

解决方法 ：调用 MV_CC_GetImageBuffer() 拿到的图像，及时调用 

MV_CC_FreeImageBuffer() 释放。 

7. HB 解码 MV_CC_HB_Decode() 接口报错 

问题原因 ：HB 图像数据不完整（ SDK 收到图像数据不完整），解码库对异常数据 解码进行解码，失败。 

解决方法 ：调用 MV_CC_HB_Decode() 前，对当前帧信息中的丢包进行校验（ 

MV_FRAME_OUT_INFO_EX 中nLostPacket 字段），如果丢包，则优化网络。 

8. 相机异常掉线 

问题原因 ：网络阻塞，网卡休眠或者网口连接处松动。 

解决方法 ：检查网络带宽，设置操作系统的电源选项，使计算机不要进入睡眠状 态；确认下网口是否松动，检查带宽使用情况。 

2. U3V 相机问题 

1. 打开相机失败 

1. 问题原因 ：相机驱动未正确安装，或者被识别成其他厂商驱动。 

解决方法 ：检查驱动是否安装正确，重新安装驱动。在 Windows 系统下， 您可进入设备管理器，查看对应相机设备的属性。 

2. 问题原因 ：设备通过 USB2.0 连接线和（或）端口连接。 

解决方法 ：检查 USB 接线和接口，确保连接至 3.0 接口。 

3. 问题原因 ：相机被其他进程连接。 

解决方法 ：您可检查客户端内相机连接状态。若相机状态为被占用，关闭 其他占用相机的程序，并确保相机处于无连接状态。 

2. 取流异常 /丢帧 /帧号重置 

1. 问题原因 ：USB 接口带宽不足，导致丢数据。 解决方法 ：在客户端中，右键设备，单击 U3V 传输配置 ，调节 传输包大小 

。

2. 问题原因 ：存在 EMC 干扰，导致流链路数据异常，流链路重置，帧号重 置。 

解决方法 ：检查设备环境，减少静电；增加磁环提高抗干扰能力。 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 法律声明 

在法律允许的最大范围内，本文档是 “按照现状 ”提供，可能存在瑕疵或错误。本公司不对本文档提 供任何形式的明示或默示保证，包括但不限于适销性、质量满意度、适合特定目的、不侵犯第三方 权利等保证；亦不对使用或是分发本文档导致的任何特殊、附带、偶然或间接的损害进行赔偿，包 括但不限于商业利润损失、系统故障、数据或文档丢失产生的损失。 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ConfigLightController.cpp 

配置光源控制器 

该示例程序演示光源控制器的触发参数和 IO 参数控制，包括常规参数修改，事件及快速软触发等。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

void* hInterface = NULL; 

//ch: 事件回调函数 | en: Event callback function 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser) 

{

if (pEventInfo) 

{

__int64 nTimestamp = pEventInfo-> nTimestampHigh ;

nTimestamp = (nTimestamp << 32) + pEventInfo-> nTimestampLow ;

printf("EventName[%s], EventID[%u], Timestamp[%lld]\n", 

pEventInfo-> EventName , pEventInfo-> nEventID , nTimestamp); 

}

}

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); }

bool PrintInterfaceInfo (MV_INTERFACE_INFO * pstInterfaceInfo) 

{

if (NULL == pstInterfaceInfo) 

{

printf("The Pointer of pstInterfaceInfo is NULL!\n"); 

return false; 

}

printf("Display name: %s\n",pstInterfaceInfo-> chDisplayName ); 

printf("Serial number: %s\n",pstInterfaceInfo-> chSerialNumber ); 

printf("model name: %s\n",pstInterfaceInfo-> chModelName ); 

printf("\n"); 

return true; 

}

void Set_Get_Enum (const char* str) 

{

MVCC_ENUMVALUE stEnumValue = {0}; 

MVCC_ENUMENTRY stEnumentryInfo = {0}; 

int nRet = MV_CC_GetEnumValue (hInterface ,str, &stEnumValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str, nRet); 

return; 

}

stEnumentryInfo. nValue = stEnumValue. nCurValue ;

nRet = MV_CC_GetEnumEntrySymbolic (hInterface ,str, &stEnumentryInfo); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%s] Success!\n",str,stEnumentryInfo. chSymbolic ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetEnumValue (hInterface ,str,stEnumValue. nCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; }

else 

{

printf("Set %s = [%s] Success!\n",str,stEnumentryInfo. chSymbolic ); 

}

}

}

void Set_Get_Bool (const char* str) 

{

bool bValue = false; 

int nRet = MV_CC_GetBoolValue (hInterface ,str, &bValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%d] Success!\n",str,bValue); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetBoolValue (hInterface ,str, bValue); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%d] Success!\n",str,bValue); 

}

}

}

void Set_Get_Int (const char* str) 

{

MVCC_INTVALUE_EX stIntValue; 

int nRet = MV_CC_GetIntValueEx (hInterface ,str,&stIntValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%d] Success!\n",str,stIntValue. nCurValue ); 

}MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetIntValueEx (hInterface ,str,stIntValue. nCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%d] Success!\n",str,stIntValue. nCurValue ); 

}

}

}

void Set_Get_String (const char* str) 

{

MVCC_STRINGVALUE StringValue; 

int nRet = MV_CC_GetStringValue (hInterface ,str, &StringValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%s] Success!\n",str,StringValue. chCurValue ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetStringValue (hInterface ,str, StringValue. chCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%s] Success!\n",str,StringValue. chCurValue ); 

}

}

}

void Set_Get_Float (const char* str) 

{

MVCC_FLOATVALUE FloatValue; int nRet = MV_CC_GetFloatValue (hInterface ,str, &FloatValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%f] Success!\n",str,FloatValue. fCurValue ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetFloatValue (hInterface ,str, FloatValue. fCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%f] Success!\n",str,FloatValue. fCurValue ); 

}

}

}

int main () 

{

int nRet = MV_OK ;

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

// 枚举光源控制卡 

nRet = MV_CC_EnumInterfaces (MV_LC_INTERFACE ,&stInterfaceInfoList); 

if ( MV_OK != nRet) 

{

printf("Enum LightController Interfaces fail! nRet [0x%x]\n", nRet); break; 

}

if (stInterfaceInfoList. nInterfaceNum > 0) 

{

for (unsigned int i = 0; i < stInterfaceInfoList. nInterfaceNum ; i++) 

{

printf("[Interface %d]:\n", i); 

MV_INTERFACE_INFO * pstInterfaceInfo =stInterfaceInfoList. pInterfaceInfos [i]; 

if (NULL == pstInterfaceInfo) 

{

break; 

}

PrintInterfaceInfo (pstInterfaceInfo); 

}

printf("Enum Interfaces success!\n\n"); 

}

else 

{

printf("Find No Interface!\n"); 

break; 

}

printf("Please Input Interfaces index(0-%d):", stInterfaceInfoList. nInterfaceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stInterfaceInfoList. nInterfaceNum )

{

printf("Input error!\n"); 

break; 

}

// 创建光源控制卡句柄 

nRet = MV_CC_CreateInterface (& hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

if ( MV_OK == nRet) 

{

printf("Create Interface success!\n"); 

}

else 

{

printf("Create Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 打开光源控制卡 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

if ( MV_OK == nRet) {

printf("Open Interface success!\n"); 

}

else 

{

printf("Open Interface fail! nRet [0x%x]\n", nRet); 

break; 

}

// 打开光源控制卡事件通知并注册该事件的回调 

nRet = MV_CC_EventNotificationOn (hInterface ,"CardPacketReceived0"); 

if (nRet != MV_OK )

{

printf("EventNotificationOn fail! nRet [0x%x]\n", nRet); 

break; 

}

nRet = MV_CC_RegisterEventCallBackEx (hInterface ,"CardPacketReceived0", EventCallBack , NULL); 

if ( MV_OK != nRet) 

{

printf("Register Event CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// 光源控制卡常规参数的获取与修改 

Set_Get_Enum ("TimerSelector"); 

Set_Get_Enum ("TimerTriggerSource"); 

Set_Get_Bool ("LineStatus"); 

Set_Get_Int ("TimerDuration"); 

Set_Get_Int ("TimerDelay"); 

// 关闭光源控制卡 

nRet = MV_CC_CloseInterface (hInterface ); 

if ( MV_OK == nRet) 

{

printf("Close Interface success!\n"); 

}

else 

{

printf("Close Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 销毁光源控制卡句柄 

nRet = MV_CC_DestroyInterface (hInterface ); 

if ( MV_OK == nRet) 

{printf("Destroy Interface success!\n"); 

}

else 

{

printf("Destroy Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

hInterface = NULL; 

} while (0); 

if (hInterface != NULL) 

{

MV_CC_CloseInterface (hInterface ); 

MV_CC_DestroyInterface (hInterface ); 

hInterface = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# LineScanSoftwareTrigger.cpp 线阵相机软触发取图 

该示例程序演示配置线阵相机的 IO 参数， SDK 内部开启取流线程，通过回调方式给上层。部分节点 的设置需要搭配采集卡和设备的 ScanMode 。

/* 

* 这个示例演示线阵相机如何通过软触发命令获取图像 

* This simple shows how a line-scan camera acquires images through software trigger commands. 

*

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

char g_chTriggerCmd [128]; 

// ch: 检查属性节点的访问模式 | en: Check the access mode of the feature node 

bool CheckFeatureNodeAccess (void* hHandle, char* pNodeName); 

// ch ：打印相机信息 | en: Print the information of cameras 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo); 

// ch: 取图回调函数 | en: Image callback function 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree); 

// ch: 软触发命令线程 | en: software trigger command thread 

static unsigned int __stdcall SoftwareTriggerCommandThread (void* pUser); 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!\n", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!\n", nPacketSize); 

}

}

nRet = MV_CC_SetEnumValueByString (handle , "ScanMode", "FrameScan"); 

if ( MV_OK == nRet) 

{

printf("Set Frame Scan Mode \n"); 

}

// ch: 判断 FrameTriggerControl 是否可读 | en: Check if FrameTriggerControl is readable 

if ( CheckFeatureNodeAccess (handle , "FrameTriggerControl")) 

{// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetBoolValue (handle , "FrameTriggerMode", true); 

if (MV_OK != nRet) 

{

printf("Set Frame Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为软触发 | en:Set trigger source as Software 

nRet = MV_CC_SetEnumValueByString (handle ,"FrameTriggerSource", "Software"); 

if (MV_OK != nRet) 

{

printf("Set Frame Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

strcpy_s( g_chTriggerCmd , 128, "FrameTriggerSoftware"); 

}

else 

{

// ch: 设置触发选项为 FrameBurstStart | en:Set trigger selector as FrameBurstStart 

nRet = MV_CC_SetEnumValue (handle , "TriggerSelector", 6); 

if (MV_OK != nRet) 

{

printf("Set Trigger Selector fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 1); 

if (MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 Software | en:Set trigger source as Software 

nRet = MV_CC_SetEnumValueByString (handle , "TriggerSource", "Software"); 

if (MV_OK != nRet) 

{

printf("Set Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

strcpy_s( g_chTriggerCmd , 128, "TriggerSoftware"); }

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*)_beginthreadex(NULL, 0, 

SoftwareTriggerCommandThread , handle , 0, &nThreadID); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注销抓图回调 | en:Unregister image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , NULL, NULL, true); 

if ( MV_OK != nRet) 

{

printf("Unregister Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n", nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

pstFrame-> stFrameInfo .nExtendWidth , pstFrame->stFrameInfo .nExtendHeight , pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && 

NULL != pUser) // 非自动释放模式，需要手动释放资源 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

//ch: 检查属性节点的访问模式 | en: Check the access mode of the feature node 

bool CheckFeatureNodeAccess (void* hHandle, char* pNodeName) 

{

if (NULL == pNodeName|| NULL == hHandle) 

{

return false; 

}

MV_XML_AccessMode nMode; 

unsigned int nRet = MV_XML_GetNodeAccessMode (hHandle, pNodeName, &nMode); 

if (nRet != MV_OK )

{

return false; 

}if (nMode == AM_WO || nMode == AM_RO || nMode == AM_RW )

{

return true; 

}

else 

{

return false; 

}

}

// ch: 发送软触发命令 | en: send software trigger command 

static unsigned int __stdcall SoftwareTriggerCommandThread (void* pUser) 

{

int nRet = MV_OK ;

if (pUser == NULL) 

{

return 0; 

}

while (true) 

{

nRet = MV_CC_SetCommandValue (pUser, g_chTriggerCmd ); 

if (nRet != MV_OK )

{

printf("Set software trigger command fail! nRet [0x%x]\n", nRet); 

}

Sleep(1000); 

if ( g_bExit )

{

break; 

}

}

return 0; 

}

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ParametrizeCamera_LineScanIOSettings.cpp 

线阵相机 IO 设置 

该示例程序演示如何通过 MV_CC_SetEnumValue() 配置线阵相机帧触发和行触发相关节点 IO 。

/* 

* 这个示例演示配置线阵相机的 IO 参数， SDK 内部开启取流线程，通过回调方式给上层。部分节点 的设置需要搭配采集卡和设备的 ScanMode 。

* This program shows demonstrate configuring the IO parameters for LineScan camera. The SDK starts a thread to grab images and uses ImageCallBackEx to return the images. 

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

bool CheckFeatureNodeAccess (void* hHandle, char* pNodeName); 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) {

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

pstFrame-> stFrameInfo .nExtendWidth , pstFrame->stFrameInfo .nExtendHeight , pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && 

NULL != pUser) // 非自动释放模式，需要手动释放资源 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!\n", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!\n", nPacketSize); 

}

}

printf("Please Input trigger selector index(0-1): 0-FrameTrigger, 1-LineTrigger\n"); 

unsigned int nTriggerSelector = 0; 

scanf_s("%d", &nTriggerSelector); 

if (nTriggerSelector == 0) 

{

// ch: 设置 ScanMode 为FrameScan| en:Set ScanMode to FrameScan 

nRet = MV_CC_SetEnumValueByString (handle ,"ScanMode", "FrameScan"); 

if (nRet == MV_OK )

{

printf("Set Frame Scan Mode\n"); 

}// ch: 判断 FrameTriggerControl 是否可读 | en: Check if FrameTriggerControl is readable 

if (CheckFeatureNodeAccess (handle , "FrameTriggerControl")) 

{

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetBoolValue (handle , "FrameTriggerMode", true); 

if ( MV_OK != nRet) 

{

printf("Set Frame Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 Line0 | en:Set trigger source as Line0 

nRet = MV_CC_SetEnumValue (handle , "FrameTriggerSource", 0); 

if ( MV_OK != nRet) 

{

printf("Set Frame Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

}

else 

{

// ch: 设置触发选项为 FrameBurstStart | en:Set trigger selector as FrameBurstStart 

nRet = MV_CC_SetEnumValue (handle , "TriggerSelector", 6); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Selector fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 1); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 Line0 | en:Set trigger source as Line0 

nRet = MV_CC_SetEnumValue (handle , "TriggerSource", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}}

}

else if (nTriggerSelector == 1) 

{

// ch: 判断 LineTriggerControl 是否可读 | en: Check if LineTriggerControl is readable 

if (CheckFeatureNodeAccess (handle , "LineTriggerControl")) 

{

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetBoolValue (handle , "LineTriggerMode", true); 

if ( MV_OK != nRet) 

{

printf("Set Line Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 EncoderModuleOut | en:Set trigger source as EncoderModuleOut 

nRet = MV_CC_SetEnumValue (handle , "LineTriggerSource", 6); 

if ( MV_OK != nRet) 

{

printf("Set Line Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置编码器选项为 Encoder0 | en:Set encoder selector as Encoder0 

nRet = MV_CC_SetEnumValue (handle , "EncoderSelector", 0); 

if ( MV_OK != nRet) 

{

printf("Set encoder selector fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置编码器数据源 A为Line1 | en:Set encoder source A as Line1 

nRet = MV_CC_SetEnumValue (handle , "EncoderSourceA", 1); 

if ( MV_OK != nRet) 

{

printf("Set encoder sourceA fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 设置编码器数据源 B为Line3 | en:Set encoder source B as Line3 

nRet = MV_CC_SetEnumValue (handle , "EncoderSourceB", 3); 

if ( MV_OK != nRet) 

{

printf("Set encoder sourceB fail! nRet [0x%x]\n", nRet); 

break; 

}

}

else 

{

// ch: 设置触发选项为 LineStart | en:Set trigger selector as LineStart 

nRet = MV_CC_SetEnumValue (handle , "TriggerSelector", 9); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Selector fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 1); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 EncoderModuleOut | en:Set trigger source as EncoderModuleOut 

nRet = MV_CC_SetEnumValue (handle , "TriggerSource", 6); 

if ( MV_OK != nRet) 

{

printf("Set Trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置编码器选项为 Encoder0 | en:Set encoder selector as Encoder0 

nRet = MV_CC_SetEnumValue (handle , "EncoderSelector", 0); 

if ( MV_OK != nRet) 

{

printf("Set encoder selector fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 设置编码器数据源 A为Line1 | en:Set encoder source A as Line1 

nRet = MV_CC_SetEnumValue (handle , "EncoderSourceA", 1); 

if ( MV_OK != nRet) 

{

printf("Set encoder sourceA fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置编码器数据源 B为Line3 | en:Set encoder source B as Line3 

nRet = MV_CC_SetEnumValue (handle , "EncoderSourceB", 3); 

if ( MV_OK != nRet) 

{

printf("Set encoder sourceB fail! nRet [0x%x]\n", nRet); 

break; 

}

}

}

else 

{

printf("Input error!\n"); 

break; 

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注销抓图回调 | en:Unregister image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , NULL, NULL, true); 

if ( MV_OK != nRet) 

{

printf("Unregister Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}//ch: 检查属性节点的访问模式 | en: Check the access mode of the feature node 

bool CheckFeatureNodeAccess (void* hHandle, char* pNodeName) 

{

if (NULL == pNodeName|| NULL == hHandle) 

{

return false; 

}

MV_XML_AccessMode nMode; 

unsigned int nRet = MV_XML_GetNodeAccessMode (hHandle, pNodeName, &nMode); 

if (nRet != MV_OK )

{

return false; 

}

if (nMode == AM_WO || nMode == AM_RO || nMode == AM_RW )

{

return true; 

}

else 

{

return false; 

}

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ChunkData.cpp 获取 Chunk 信息 

该示例程序说明如何开启 ChunkData 功能、配置 ChunkData 以及获取这些 ChunkData 信息。 

ChunkData 信息包括 Timestamp 和Exposure 等。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

/*Get Image buffer function, you can get the chunk infomation from frame infomation*/ 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{//ch: 打印 ChunkData 信息 | en:Print parse the timestamp information in the frame 

printf("ImageCallbackEx2 ：FrameNum[%d], ExposureTime[%f], SecondCount[%d], CycleCount[%d], CycleOffset[%d]\n", 

pstFrame-> stFrameInfo .nFrameNum , pstFrame->stFrameInfo .fExposureTime , pstFrame-> stFrameInfo .nSecondCount ,pstFrame-> stFrameInfo .nCycleCount , pstFrame->stFrameInfo .nCycleOffset ); 

MV_CHUNK_DATA_CONTENT * pUnparsedChunkContent = pstFrame->stFrameInfo .UnparsedChunkList .pUnparsedChunkContent ;

for (unsigned int i = 0; i < pstFrame->stFrameInfo .nUnparsedChunkNum ; i++) 

{

//ch ：只打印 ID 和长度，内容需要根据说明文档进行解析 

printf("ChunkInfo[%d]: ChunkID[0x%x], ChunkLen[%d]\n", i, pUnparsedChunkContent-> nChunkID , pUnparsedChunkContent->nChunkLen ); 

pUnparsedChunkContent++; 

}

if (false == bAutoFree && 

NULL != pUser) // 手动释放 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

printf("***********************************\n"); 

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开启 Chunk Mode | en:Open Chunk Mode 

nRet = MV_CC_SetBoolValue (handle , "ChunkModeActive", true); 

if ( MV_OK != nRet) 

{

printf("Set Chunk Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch:Chunk Selector 设为 Exposure | en: Chunk Selector set as Exposure 

nRet = MV_CC_SetEnumValueByString (handle , "ChunkSelector", "Exposure"); 

if ( MV_OK != nRet) 

{

printf("Set Exposure Chunk fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开启 Chunk Enable | en:Open Chunk Enable 

nRet = MV_CC_SetBoolValue (handle , "ChunkEnable", true); 

if ( MV_OK != nRet) 

{

printf("Set Chunk Enable fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch:Chunk Selector 设为 Timestamp | en: Chunk Selector set as Timestamp 

nRet = MV_CC_SetEnumValueByString (handle , "ChunkSelector", "Timestamp"); 

if ( MV_OK != nRet) 

{

printf("Set Timestamp Chunk fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 开启 Chunk Enable | en:Open Chunk Enable 

nRet = MV_CC_SetBoolValue (handle , "ChunkEnable", true); 

if ( MV_OK != nRet) 

{

printf("Set Chunk Enable fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Grab_Asynchronous.cpp 

异步取图及处理 该示例程序说明如何异步取图并进行图像处理，规避了同步时可能存在的耗时长问题。 

/* 异步取流示例 demo 

主要逻辑如下： 

1. 调用 SDK 接口获取图像，并将图像数据放入对列中 

2. 开启处理线程，从对列中获取图像，并处理 ;

注意要点： 

1. 对列大小 

2. 对列锁保护，读取 /写入数据 

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include <process.h> 

#include <iostream> 

#include "MvCameraControl.h" 

using namespace std; 

class CMVMutex 

{

public: 

CMVMutex() 

{

InitializeCriticalSection(&m_Mutex); 

}

~CMVMutex() 

{

DeleteCriticalSection(&m_Mutex); 

}

void _Lock() 

{

EnterCriticalSection(&m_Mutex); 

}

void _Unlock() 

{

LeaveCriticalSection(&m_Mutex); 

}

private: 

CRITICAL_SECTION m_Mutex; 

}; bool g_bExit = false; // 线程结束标记 

#define Max_Count 5 // 队列 缓冲区个数； 根据实际情况调节 

uint64_t m_nImageSize = 0; // 图像大小 

CMVMutex * g_mutex = NULL; // 互斥锁 

typedef struct _stImageNode_ 

{

unsigned char* pData; 

uint64_t nFrameLen; 

unsigned int nWidth; 

unsigned int nHeight; 

unsigned int nFrameNum; 

}stImageNode; 

class ArrayQueue 

{

public: 

ArrayQueue() 

{

this->size = 0; 

this->start = 0; 

this->end = 0; 

this->Queue = NULL; 

this->Qlen = 0; 

}

~ArrayQueue() 

{

g_mutex ->_Lock(); 

for (int i = 0; i< Qlen; i++) 

{

Queue[i].nFrameNum = 0; 

Queue[i].nHeight = 0; 

Queue[i].nWidth = 0; 

Queue[i].nFrameLen = 0; 

if (Queue[i].pData) {

free(Queue[i].pData); 

Queue[i].pData = NULL; 

}

printf(" free ArrayQueue [%d] !\r\n",i); 

}

delete []Queue; 

Queue = NULL; 

size = 0; 

start = 0; 

end = 0; 

g_mutex ->_Unlock(); 

}

// 队列初始化 

int Init(int nBufCount, uint64_t DefaultImagelen) 

{

int nRet = 0 ; 

this->Queue = new (std::nothrow)stImageNode[nBufCount]; 

if (this->Queue == NULL) 

{

return MV_E_RESOURCE ;

}

this->Qlen = nBufCount; 

for (int i = 0; i< nBufCount; i++) 

{

Queue[i].nFrameNum = 0; 

Queue[i].nHeight = 0; 

Queue[i].nWidth = 0; 

Queue[i].nFrameLen = 0; 

Queue[i].pData = (unsigned char*)malloc(DefaultImagelen); 

if(NULL == Queue[i].pData) 

{

return MV_E_RESOURCE ;

}

}

return 0; }

// 数据放入队列 

int push(int nFrameNum, int nWidth, int nHeight, unsigned char *pData, uint64_t nFrameLen) 

{

g_mutex ->_Lock(); 

if (size==Qlen) 

{

g_mutex ->_Unlock(); 

return MV_E_BUFOVER ;

}

size++; 

Queue[end].nFrameNum = nFrameNum; 

Queue[end].nHeight = nHeight; 

Queue[end].nWidth = nWidth; 

Queue[end].nFrameLen = nFrameLen; 

if (NULL != Queue[end].pData && NULL != pData) 

{

memcpy(Queue[end].pData, pData, nFrameLen); 

}

end = end == Qlen - 1 ? 0 : end + 1; 

g_mutex ->_Unlock(); 

return 0; 

}

// 数据从队列中取出 

int poll(int &nFrameNum, int &nHeight, int &nWidth, unsigned char *pData, uint64_t &nFrameLen) 

{

g_mutex ->_Lock(); 

if (size == 0) 

{

g_mutex ->_Unlock(); 

return MV_E_NODATA ;

}nFrameNum =Queue[start].nFrameNum; 

nHeight =Queue[start].nHeight; 

nWidth =Queue[start].nWidth; 

nFrameLen =Queue[start].nFrameLen; 

if (NULL != pData && NULL != Queue[start].pData) 

{

memcpy( pData,Queue[start].pData, nFrameLen); 

}

size--; 

start = start == Qlen - 1 ? 0 : start + 1; 

g_mutex ->_Unlock(); 

return 0; 

}

private: 

stImageNode *Queue; 

int size; 

int start; 

int end; 

int Qlen; 

}; 

ArrayQueue * m_queue = NULL; // 线程通信队列 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (NULL == pstFrame || NULL == pstFrame-> pBufAddr )

{

printf("ImageCallbackEx2 Input Param invalid.\n"); 

return; 

}

int nRet = MV_OK ;

nRet = m_queue ->push(pstFrame-> stFrameInfo .nFrameNum , pstFrame->stFrameInfo .nExtendWidth , pstFrame-> stFrameInfo .nExtendHeight ,pstFrame-> pBufAddr , pstFrame-> stFrameInfo .nFrameLenEx );// 固定数组实 现队列故是 10 9 8 7 6 5 4 3 2 1 

if (MV_OK != nRet) 

{

printf("Add Image [%d] to list failed. \r\n", pstFrame->stFrameInfo .nFrameNum ); 

}

else 

{

printf("Add Image [%d] to list success. \r\n", pstFrame->stFrameInfo .nFrameNum ); 

}

if (false == bAutoFree && 

NULL != pUser) // 非自动释放模式，需要手动释放资源 

{MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

return; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

int nWidth = 0; 

int nHeight = 0; 

uint64_t nFrameLen = 0; 

int nFrameNum = 0; 

unsigned char *pOutData = (unsigned char *) malloc( m_nImageSize ); 

if (NULL == pOutData) 

{

printf("WorkThread malloc size [%d] failed. \r\n", m_nImageSize ); 

return MV_E_RESOURCE ;

}

printf("WorkThread Begin . \r\n"); 

while(true != g_bExit )

{

// 变量初始化 

nWidth = 0; 

nHeight = 0; 

nFrameLen = 0; 

nFrameNum = 0; 

nRet = m_queue ->poll(nFrameNum,nHeight,nWidth,pOutData,nFrameLen); 

if ( MV_OK != nRet) 

{

printf("Poll failed, maybe no data. \r\n"); 

Sleep(2); 

continue; 

}

else 

{

printf("Get nWidth [%d] nHeight [%d] nFrameNum [%d] \r\n",nWidth,nHeight,nFrameNum); 

// 根据实际场景需求，对图像进行 处理 

#if 0 

FILE* fp = NULL; 

char szFileName[256] = {0}; sprintf(szFileName, "Image_%d_width_%d_height_%d_Len_%d.raw",nFrameNum,nWidth,nHeight ,nFrameLen); 

fp = fopen(szFileName, "wb+"); 

if (fp == NULL) 

{

return MV_E_RESOURCE ;

}

fwrite(pOutData, 1, nFrameLen, fp); 

fclose(fp); 

fp = NULL; 

#endif 

}

}

printf("WorkThread exit . \r\n"); 

if (pOutData) 

{

free(pOutData); 

pOutData = NULL; 

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

g_mutex = new (std::nothrow)CMVMutex(); // 互斥锁 

if ( g_mutex == NULL) 

{

printf("g_mutex is null! \n"); 

break; 

}

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | Enum device MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | Open device nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

int nWidth = 0; 

int nHeight = 0; 

MVCC_INTVALUE_EX stIntEx = {0}; 

nRet = MV_CC_GetIntValueEx (handle , "Width", &stIntEx); 

if ( MV_OK != nRet) 

{

printf("Get IntValue fail! nRet [0x%x]\n", nRet); 

break; 

}

nWidth = stIntEx. nCurValue ;

memset(&stIntEx, 0, sizeof( MVCC_INTVALUE_EX )); 

nRet = MV_CC_GetIntValueEx (handle , "Height", &stIntEx); 

if ( MV_OK != nRet) 

{

printf("Get IntValue fail! nRet [0x%x]\n", nRet); 

break; 

}

nHeight = stIntEx. nCurValue ;

nRet = MV_CC_GetIntValueEx (handle , "PayloadSize", &stIntEx); 

if ( MV_OK != nRet) 

{

printf("Get IntValue fail! nRet [0x%x], use [%d] replace.\n", nRet, nHeight*nWidth * 3); 

m_nImageSize = nHeight*nWidth*3; 

}

else 

{

m_nImageSize = stIntEx. nCurValue ;

}

// 初始化队列 

m_queue = new (std::nothrow)ArrayQueue(); 

if ( m_queue ==NULL) 

{

printf("m_queue is null! \n"); 

break; 

}

nRet = m_queue ->Init( Max_Count ,m_nImageSize ); if ( MV_OK != nRet) 

{

printf("ArrayQueue init fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | eb:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); if (NULL == hThreadHandle) 

{

printf("Start work thread fail! \n"); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注销抓图回调 | en:Unregister image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , NULL, NULL, true); 

if ( MV_OK != nRet) 

{

printf("Unregister Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (m_queue )

{

delete m_queue ;

m_queue = NULL; 

}

printf("free buffer done\n"); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

if( g_mutex )

{

delete g_mutex ;

g_mutex = NULL; 

}

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 宏定义

# 去紫边特有错误码   

> 状态码 »算法库透传状态码

范围为 0x10405000-0x10405002 更多 ... 

# 宏定义 

#define MV_ALG_E_PFC_ROI_PT 0x10405000 

去紫边算法 ROI 原点错误 更多 ... 

#define MV_ALG_E_PFC_ROI_SIZE 0x10405001 

去紫边算法 ROI 大小错误 更多 ... 

#define MV_ALG_E_PFC_KERNEL_SIZE 0x10405002 

去紫边算法滤波核尺寸错误 更多 ... 

# 详细描述 

范围为 0x10405000-0x10405002 

# 宏定义说明 ◆ MV_ALG_E_PFC_ROI_PT 

#define MV_ALG_E_PFC_ROI_PT 0x10405000 

去紫边算法 ROI 原点错误 

◆ MV_ALG_E_PFC_ROI_SIZE 

#define MV_ALG_E_PFC_ROI_SIZE 0x10405001 

去紫边算法 ROI 大小错误 

◆ MV_ALG_E_PFC_KERNEL_SIZE 

#define MV_ALG_E_PFC_KERNEL_SIZE 0x10405002 

去紫边算法滤波核尺寸错误 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 宏定义

# 通用错误码 状态码 » SDK 内部自定义状态码 

范围为 0x80000000-0x800000FF 更多 ... 

# 宏定义 

#define MV_E_HANDLE 0x80000000 

错误或无效的句柄 更多 ... 

#define MV_E_SUPPORT 0x80000001 

不支持的功能 更多 ... 

#define MV_E_BUFOVER 0x80000002 

缓存已满 更多 ... 

#define MV_E_CALLORDER 0x80000003 

函数调用顺序有误 更多 ... 

#define MV_E_PARAMETER 0x80000004 

错误的参数 更多 ... 

#define MV_E_RESOURCE 0x80000006 

资源申请失败 更多 ... 

#define MV_E_NODATA 0x80000007 

无数据 更多 ... 

#define MV_E_PRECONDITION 0x80000008 

前置条件有误，或运行环境已发生变化 更多 ... 

#define MV_E_VERSION 0x80000009 

版本不匹配 更多 ... 

#define MV_E_NOENOUGH_BUF 0x8000000A 

传入的内存空间不足 更多 ... 

#define MV_E_ABNORMAL_IMAGE 0x8000000B 

异常图像，可能是丢包导致图像不完整 更多 ... #define MV_E_LOAD_LIBRARY 0x8000000C 

动态导入 DLL 失败 更多 ... 

#define MV_E_NOOUTBUF 0x8000000D 

没有可输出的缓存 更多 ... 

#define MV_E_ENCRYPT 0x8000000E 

加密错误 更多 ... 

#define MV_E_OPENFILE 0x8000000F 

打开文件出现错误 更多 ... 

#define MV_E_BUF_IN_USE 0x80000010 

缓存地址已使用 更多 ... 

#define MV_E_BUF_INVALID 0x80000011 

无效的缓存地址 更多 ... 

#define MV_E_NOALIGN_BUF 0x80000012 

缓存对齐异常 更多 ... 

#define MV_E_NOENOUGH_BUF_NUM 0x80000013 

缓存个数不足 更多 ... 

#define MV_E_PORT_IN_USE 0x80000014 

串口被占用 更多 ... 

#define MV_E_IMAGE_DECODEC 0x80000015 

解码错误 (SDK 校验图像异常 ) 更多 ... 

#define MV_E_UINT32_LIMIT 0x80000016 

图像大小超出 unsigned int 数据类型上限值 更多 ... 

#define MV_E_IMAGE_HEIGHT 0x80000017 

图像高度异常（残帧丢弃） 更多 ... 

#define MV_E_NOENOUGH_DDR 0x80000018 

DDR 缓存不足 更多 ... #define MV_E_NOENOUGH_STREAM 0x80000019 

流通道不足 更多 ... 

#define MV_E_UNKNOW 0x800000FF 

未知的错误 更多 ... 

# 详细描述 

范围为 0x80000000-0x800000FF 

# 宏定义说明 

◆ MV_E_HANDLE 

#define MV_E_HANDLE 0x80000000 

错误或无效的句柄 

◆ MV_E_SUPPORT 

#define MV_E_SUPPORT 0x80000001 

不支持的功能 

◆ MV_E_BUFOVER 

#define MV_E_BUFOVER 0x80000002 

缓存已满 

示例 

Grab_Asynchronous.cpp .

◆ MV_E_CALLORDER #define MV_E_CALLORDER 0x80000003 

函数调用顺序有误 

◆ MV_E_PARAMETER 

#define MV_E_PARAMETER 0x80000004 

错误的参数 

◆ MV_E_RESOURCE 

#define MV_E_RESOURCE 0x80000006 

资源申请失败 

示例 

Grab_Asynchronous.cpp , HighBandwidthDecode.cpp , ImageSave.cpp , 以及 

MultiLightCtrl_ImageStitching.cpp .

◆ MV_E_NODATA 

#define MV_E_NODATA 0x80000007 

无数据 

示例 

Grab_Asynchronous.cpp .

◆ MV_E_PRECONDITION 

#define MV_E_PRECONDITION 0x80000008 

前置条件有误，或运行环境已发生变化 

◆ MV_E_VERSION 

#define MV_E_VERSION 0x80000009 版本不匹配 

◆ MV_E_NOENOUGH_BUF 

#define MV_E_NOENOUGH_BUF 0x8000000A 

传入的内存空间不足 

◆ MV_E_ABNORMAL_IMAGE 

#define MV_E_ABNORMAL_IMAGE 0x8000000B 

异常图像，可能是丢包导致图像不完整 

◆ MV_E_LOAD_LIBRARY 

#define MV_E_LOAD_LIBRARY 0x8000000C 

动态导入 DLL 失败 

◆ MV_E_NOOUTBUF 

#define MV_E_NOOUTBUF 0x8000000D 

没有可输出的缓存 

◆ MV_E_ENCRYPT 

#define MV_E_ENCRYPT 0x8000000E 

加密错误 

◆ MV_E_OPENFILE 

#define MV_E_OPENFILE 0x8000000F 

打开文件出现错误 ◆ MV_E_BUF_IN_USE 

#define MV_E_BUF_IN_USE 0x80000010 

缓存地址已使用 

◆ MV_E_BUF_INVALID 

#define MV_E_BUF_INVALID 0x80000011 

无效的缓存地址 

◆ MV_E_NOALIGN_BUF 

#define MV_E_NOALIGN_BUF 0x80000012 

缓存对齐异常 

◆ MV_E_NOENOUGH_BUF_NUM 

#define MV_E_NOENOUGH_BUF_NUM 0x80000013 

缓存个数不足 

◆ MV_E_PORT_IN_USE 

#define MV_E_PORT_IN_USE 0x80000014 

串口被占用 

◆ MV_E_IMAGE_DECODEC 

#define MV_E_IMAGE_DECODEC 0x80000015 

解码错误 (SDK 校验图像异常 )◆ MV_E_UINT32_LIMIT 

#define MV_E_UINT32_LIMIT 0x80000016 

图像大小超出 unsigned int 数据类型上限值 

◆ MV_E_IMAGE_HEIGHT 

#define MV_E_IMAGE_HEIGHT 0x80000017 

图像高度异常（残帧丢弃） 

◆ MV_E_NOENOUGH_DDR 

#define MV_E_NOENOUGH_DDR 0x80000018 

DDR 缓存不足 

◆ MV_E_NOENOUGH_STREAM 

#define MV_E_NOENOUGH_STREAM 0x80000019 

流通道不足 

◆ MV_E_UNKNOW 

#define MV_E_UNKNOW 0x800000FF 

未知的错误 

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ParametrizeCamera_AreaScanIOSettings.cpp 

面阵相机 IO 设置 

该示例程序演示如何设置面阵相机触发相关节点 IO 。

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get one Frame: width[%d], height[%d], nFrameNum[%d]\n", 

pstFrame-> stFrameInfo .nExtendWidth , pstFrame->stFrameInfo .nExtendHeight , pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && 

NULL != pUser) // 非自动释放模式，需要手动释放资源 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find no devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) {

printf("Open device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: set packet size fail nRet [0x%x]!\n", nRet); 

}

}

else 

{

printf("Warning: Get packet size fail nRet [0x%x]!\n", nPacketSize); 

}

}

// 以下设置 Line0 IO 输入，也可选择 Line2 作为输入、 Line2 延迟更低 

printf("Now set IO input...\n"); 

{

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetEnumValueByString (handle , "TriggerMode", "On"); 

if (MV_OK != nRet) 

{

printf("Set trigger mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 Line0 | en:Set trigger source as Line0 

nRet = MV_CC_SetEnumValueByString (handle , "TriggerSource", "Line0"); 

if (MV_OK != nRet) 

{

printf("Set trigger source fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发沿为 RisingEdge | en: Set TriggerActivation as RisingEdge nRet = MV_CC_SetEnumValueByString (handle ,"TriggerActivation", "RisingEdge"); 

if (MV_OK != nRet) 

{

printf("Set trigger activation RisingEdge fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发延迟 | en: Set TriggerDelay 

nRet = MV_CC_SetFloatValue (handle , "TriggerDelay", 0); 

if (MV_OK != nRet) 

{

printf("Set trigger delay fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭触发缓存、如需要可开启 | en: Turn off TriggerCacheEnable 

nRet = MV_CC_SetBoolValue (handle , "TriggerCacheEnable", false); 

if (MV_OK != nRet) 

{

printf("Set trigger cache enable fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 切换 LineSelector 为Line0 | en: Set LineSelector as Line0 

nRet = MV_CC_SetEnumValueByString (handle , "LineSelector", "Line0"); 

if (MV_OK != nRet) 

{

printf("Set line selector fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置 Line0 滤波时间 (us) 、误触发可适当加大 | Set Line0 LineDebouncerTime(us) 

nRet = MV_CC_SetIntValueEx (handle , "LineDebouncerTime", 50); 

if (MV_OK != nRet) 

{

printf("Set line debouncer time fail! nRet [0x%x]\n", nRet); 

break; 

}

}

// 以下设置 Line1 IO 输出、也可选择 Line2 作为输出、 Line2 延迟更低；用于控制外 部光源、等设备 printf("Now set IO output...\n"); 

{

// ch: 切换 LineSelector 为Line1 | en:Set LineSelector as Line1 

nRet = MV_CC_SetEnumValueByString (handle , "LineSelector", "Line1"); 

if (MV_OK != nRet) 

{

printf("Set line selector fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 输出源选择曝光开始 |en:Set LineSource as ExposureStartActive 

nRet = MV_CC_SetEnumValueByString (handle , "LineSource", "ExposureStartActive"); 

if (MV_OK != nRet) 

{

printf("Set LineSource fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开启输出使能 | en: Turn on StrobeEnable 

nRet = MV_CC_SetBoolValue (handle , "StrobeEnable", true); 

if (MV_OK != nRet) 

{

printf("Set strobe enable fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置输出线路持续时间（ us ） | en: Set StrobeLineDuration(us) 

nRet = MV_CC_SetIntValueEx (handle , "StrobeLineDuration", 0); 

if (MV_OK != nRet) 

{

printf("Set line strobe line duration fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置输出线路延迟（ us ） | en: Set StrobeLineDelay(us) 

nRet = MV_CC_SetIntValueEx (handle , "StrobeLineDelay", 0); 

if (MV_OK != nRet) 

{

printf("Set line strobe line delay fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 输出线路预延迟（ us ） | en: Set StrobeLinePreDelay(us) 

nRet = MV_CC_SetIntValueEx (handle , "StrobeLinePreDelay", 0); 

if (MV_OK != nRet) 

{

printf("Set line strobe line pre-delay fail! nRet [0x%x]\n", nRet); 

break; 

}

}// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

else 

{

printf("Start grabbing success!\n"); 

}

printf("Press a key to stop.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注销抓图回调 | en:Unregister image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , NULL, NULL, true); 

if ( MV_OK != nRet) 

{

printf("Unregister image callBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close device fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 QuickSoftwareTrigger.cpp 

采集卡快速软触发 

该示例程序说明如何使用采集卡实现快速软触发功能。快速软触发仅被部分采集卡支持，请以采集 卡实际情况为准。 

/* 

* 这个示例演示了如何使用采集卡快速软触发功能 

* This program shows how to use the quick software trigger of the frame grabbers. 

* [ 注] 快速软触发功能需要采集卡固件支持，目前只有部分 XoF(GS1104F) 和

CXP(GX1002,GX1004) 采集卡支持 

* [PS] The quick soft trigger function requires firmware support from the frame grabber, 

* and currently only some XoF (GS1104F) and CXP (GX1002, GX1004) frame grabbers support it. 

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

void* g_hInterface = NULL; 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintInterfaceInfo (MV_INTERFACE_INFO * pstInterfaceInfo) 

{

if (NULL == pstInterfaceInfo) 

{

printf("The Pointer of pstInterfaceInfo is NULL!\n"); 

return false; 

}

printf("Display name: %s\n",pstInterfaceInfo-> chDisplayName ); 

printf("Serial number: %s\n",pstInterfaceInfo-> chSerialNumber ); 

printf("model name: %s\n",pstInterfaceInfo-> chModelName ); 

printf("\n"); return true; 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stOutFrame = {0}; 

while(true) 

{

// ch: 通过采集卡软触发一次 | en:Software trigger once from interface 

nRet = MV_CC_SetCommandValue (g_hInterface ,"QuickSoftwareTrigger0"); 

if ( MV_OK != nRet) 

{

printf("Quick Software Trigger once failed! %#x\n", nRet); 

}

else 

{printf("Quick Software Trigger once success!\n"); 

}

nRet = MV_CC_GetImageBuffer (pUser, &stOutFrame, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stOutFrame. stFrameInfo .nExtendWidth ,stOutFrame. stFrameInfo .nExtendHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (pUser, &stOutFrame); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* hDevice = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

nRet = MV_CC_EnumInterfaces (MV_CXP_INTERFACE | MV_XOF_INTERFACE ,&stInterfaceInfoList); 

// 枚举采集卡 

if ( MV_OK != nRet) 

{

printf("Enum Interfaces fail! nRet [0x%x]\n", nRet); break; 

}

if (stInterfaceInfoList. nInterfaceNum > 0) 

{

for (unsigned int i = 0; i < stInterfaceInfoList. nInterfaceNum ; i++) 

{

printf("[Interface %d]:\n", i); 

MV_INTERFACE_INFO * pstInterfaceInfo =stInterfaceInfoList. pInterfaceInfos [i]; 

if (NULL == pstInterfaceInfo) 

{

break; 

}

PrintInterfaceInfo (pstInterfaceInfo); 

}

printf("Enum Interfaces success!\n\n"); 

}

else 

{

printf("Find No Interface!\n"); 

break; 

}

printf("Please Input Interfaces index(0-%d):", stInterfaceInfoList. nInterfaceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stInterfaceInfoList. nInterfaceNum )

{

printf("Input error!\n"); 

break; 

}

// 创建采集卡句柄 

nRet = MV_CC_CreateInterface (& g_hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

if ( MV_OK == nRet) 

{

printf("Create Interface success!\n"); 

}

else 

{

printf("Create Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 打开采集卡 

nRet = MV_CC_OpenInterface (g_hInterface , NULL); 

if ( MV_OK == nRet) {

printf("Open Interface success!\n"); 

}

else 

{

printf("Open Interface fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置数据流触发源为快速软触发 0 | en:Set Stream Trigger Source to QuickSoftwareTrigger0 

nRet = MV_CC_SetEnumValueByString (g_hInterface ,"StreamTriggerSource", "QuickSoftwareTrigger0"); 

if ( MV_OK != nRet) 

{

printf("Set StreamTriggerSource fail! nRet [0x%x], maybe firmware not support Quick Software Trigger\n", nRet); 

break; 

}

else 

{

printf("Set StreamTriggerSource = QuickSoftwareTrigger0 Success!\n"); 

}

// ch: 设置数据流触发方式为上升沿 | en:Set Stream Trigger Activation to RisingEdge 

nRet = MV_CC_SetEnumValueByString (g_hInterface ,"StreamTriggerActivation", "RisingEdge"); 

if ( MV_OK != nRet) 

{

printf("Set StreamTriggerActivation Fail! nRet [0x%x]\n", nRet); 

break; 

}

else 

{

printf("Set StreamTriggerActivation = RisingEdge Success!\n"); 

}

MV_CC_DEVICE_INFO_LIST stDeviceList = { 0 }; 

nRet = MV_CC_EnumDevicesByInterface (g_hInterface ,&stDeviceList); 

// 枚举采集卡设备 

if ( MV_OK != nRet) 

{

printf("Enum Interfaces Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

int nDeviceNum = 0; 

int nDeviceIndex[ MV_MAX_DEVICE_NUM ] = { 0 }; 

if (stDeviceList. nDeviceNum > 0) {

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

if ( MV_CXP_INTERFACE == stInterfaceInfoList. pInterfaceInfos [nIndex]-> nTLayerType )

{

if (0 == strcmp((char*)stInterfaceInfoList. pInterfaceInfos [nIndex]->chInterfaceID ,

(char*)pDeviceInfo->SpecialInfo .stCXPInfo .chInterfaceID )) 

{

printf("[device %d]:\n", nDeviceNum); 

nDeviceIndex[nDeviceNum] = i; 

PrintDeviceInfo (pDeviceInfo); 

nDeviceNum++; 

}

}

else 

{

if (0 == strcmp((char*)stInterfaceInfoList. pInterfaceInfos [nIndex]->chInterfaceID ,

(char*)pDeviceInfo->SpecialInfo .stXoFInfo .chInterfaceID )) 

{

printf("[device %d]:\n", nDeviceNum); 

nDeviceIndex[nDeviceNum] = i; 

PrintDeviceInfo (pDeviceInfo); 

nDeviceNum++; 

}

}

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

if (0 == nDeviceNum) 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", nDeviceNum - 1); 

nIndex = 0; 

scanf_s("%d", &nIndex); if (nIndex >= nDeviceNum) 

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (&hDevice, stDeviceList. pDeviceInfo [nDeviceIndex[nIndex]]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (hDevice); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (hDevice, "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (hDevice); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , hDevice, 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (hDevice); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (hDevice); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (hDevice); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

hDevice = NULL; 

// 关闭采集卡 

nRet = MV_CC_CloseInterface (g_hInterface ); 

if ( MV_OK == nRet) 

{

printf("Close Interface success!\n"); 

}

else 

{

printf("Close Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 销毁采集卡句柄 

nRet = MV_CC_DestroyInterface (g_hInterface ); 

if ( MV_OK == nRet) 

{

printf("Destroy Interface success!\n"); 

}

else 

{printf("Destroy Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

g_hInterface = NULL; 

} while (0); 

if (hDevice != NULL) 

{

MV_CC_CloseDevice (hDevice); 

MV_CC_DestroyHandle (hDevice); 

hDevice = NULL; 

}

if (g_hInterface != NULL) 

{

MV_CC_CloseInterface (g_hInterface ); 

MV_CC_DestroyInterface (g_hInterface ); 

g_hInterface = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 ForceIPEx.cpp 

强制设置相机 IP 

该示例程序说明如何强制设置网口相机 IP ，保证断电后重新连接，重新枚举后依旧生效。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

#pragma comment(lib, "wsock32.lib") 

#define PERSISTENT_CONFIG_REG 0x0014 

#define PERSISTENT_IPADDR_REG 0x064C 

#define PERSISTENT_SUBNETMASK_REG 0x065C 

#define PERSISTENT_DEFAULTGATEWAY_REG 0x066C 

bool WritesToRegisters (char* chSerialNumber, unsigned int nIpAddr, unsigned int nNetWorkMask, unsigned int nDefaultGateway); 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); // ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

// 地址的转换函数 

bool ConvertToHexIp (unsigned int *nHexIP, unsigned int *nDecIP, char c) 

{

if ( nDecIP[0] < 0 || nDecIP[0] > 255 

|| nDecIP[1] < 0 || nDecIP[1] > 255 

|| nDecIP[2] < 0 || nDecIP[2] > 255 

|| nDecIP[3] < 0 || nDecIP[3] > 255 

|| c != '\n') 

{

return false; 

}

*nHexIP = (nDecIP[0] << 24) + (nDecIP[1] << 16) + (nDecIP[2] << 8) + nDecIP[3]; 

return true; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned int nIP[4] = {0}; 

char c = '\0'; 

unsigned int nIpAddr = 0, nNetWorkMask = 0, nDefaultGateway = 0; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE ,&stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; }

// 记录第一次的序列号 

//Record the serial number for the first time 

char chSerialNumber[16] = {0}; 

memcpy(chSerialNumber, stDeviceList. pDeviceInfo [nIndex]->SpecialInfo .stGigEInfo .chSerialNumber ,sizeof(stDeviceList. pDeviceInfo [nIndex]->SpecialInfo .stGigEInfo .chSerialNumber )); 

printf("serial number:[%s]\n", chSerialNumber); 

// 输入 IP 子网掩码 默认网关 

// input ip, subnet mask and defaultway 

printf("Please input ip, example: 192.168.1.100\n"); 

if ( 5 != scanf("%d.%d.%d.%d%c", &nIP[0], &nIP[1], &nIP[2], &nIP[3], &c) ) 

{

printf("input count error\n"); 

break; 

}

if (! ConvertToHexIp (&nIpAddr, nIP, c)) 

{

printf("input IpAddr format is not correct\n"); 

break; 

}

printf("Please input NetMask, example: 255.255.255.0\n"); 

if ( 5 != scanf("%d.%d.%d.%d%c", &nIP[0], &nIP[1], &nIP[2], &nIP[3], &c) ) 

{

printf("input count error\n"); 

break; 

}

if (! ConvertToHexIp (&nNetWorkMask, nIP, c)) 

{

printf("input NetMask format is not correct\n"); 

break; 

}

printf("Please input DefaultWay, example: 192.168.1.1\n"); 

if ( 5 != scanf("%d.%d.%d.%d%c", &nIP[0], &nIP[1], &nIP[2], &nIP[3], &c) ) 

{

printf("input count error\n"); 

break; 

}

if (! ConvertToHexIp (&nDefaultGateway, nIP, c)) 

{

printf("input DefaultWay format is not correct\n"); 

break; 

}// 判断设备 Ip 是否可达 

//Determine whether the IP address is reachable 

bool bAccessible =

MV_CC_IsDeviceAccessible (stDeviceList. pDeviceInfo [nIndex], 

MV_ACCESS_Exclusive ); 

if(bAccessible) 

{

//ch: 设置 IP 配置选项 | en:set IP config 

nRet = MV_GIGE_SetIpConfig (handle , MV_IP_CFG_STATIC ); 

if (MV_OK != nRet) 

{

printf("MV_GIGE_SetIpConfig fail! nRet [%x]\n", nRet); 

break; 

}

printf("set IPConfig succeed\n"); 

//ch: 设置强制 IP | en:set force IP 

nRet = MV_GIGE_ForceIpEx (handle , nIpAddr, nNetWorkMask, nDefaultGateway); 

if (MV_OK != nRet) 

{

printf("MV_GIGE_ForceIpEx fail! nRet [%x]\n", nRet); 

break; 

}

printf("set IP succeed\n"); 

}

else 

{

//ch: 设置强制 IP | en:set force IP 

nRet = MV_GIGE_ForceIpEx (handle , nIpAddr, nNetWorkMask, nDefaultGateway); 

if (MV_OK != nRet) 

{

printf("MV_GIGE_ForceIpEx fail! nRet [%x]\n", nRet); 

break; 

}

printf("set IP succeed\n"); 

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

//ch: 需要重新创建句柄，设置为静态 IP 方式进行保存 | en:re-create the handle and set it to static IP for storage 

stDeviceList. pDeviceInfo [nIndex]->SpecialInfo .stGigEInfo .nCurrentIp = nIpAddr; 

stDeviceList. pDeviceInfo [nIndex]->SpecialInfo .stGigEInfo .nCurrentSubNetMask = nNetWorkMask; 

stDeviceList. pDeviceInfo [nIndex]->SpecialInfo .stGigEInfo .nDefultGateWay = nDefaultGateway; 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); if (MV_OK != nRet) 

{

printf("MV_CC_CreateHandle fail! nRet [%x]\n", nRet); 

break; 

}

// ch: 设置 IP 配置选项 | en:set IP config 

nRet = MV_GIGE_SetIpConfig (handle , MV_IP_CFG_STATIC ); 

if (MV_OK != nRet) 

{

printf("MV_GIGE_SetIpConfig fail! nRet [%x]\n", nRet); 

break; 

}

printf("set IPConfig succeed\n"); 

}

//ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

//ch: 若是第三方相机需要额外进行以下寄存器的写入 

//en: If it is a third-party camera, additional writing of the following registers may be required. 

//Sleep(500); 

//bool bSuccess = WritesToRegisters(chSerialNumber, nIpAddr, nNetWorkMask, nDefaultGateway); 

//if (!bSuccess) 

//{ 

//printf("Writing registers fail\n"); 

//break; 

//} 

printf("Finish, everything is OK.\n"); 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

bool WritesToRegisters (char* chSerialNumber, unsigned int nIpAddr, unsigned int nNetWorkMask, unsigned int nDefaultGateway) 

{

printf("Now start writing registers ...\n"); 

if (NULL == chSerialNumber) 

{

printf("Serial number is invalid\n"); 

return false; 

}

unsigned int nIndex = -1; 

int nRet = MV_OK ;

void* handle = NULL; 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

do 

{

//ch: 重新枚举设备 | en:After setting up ForceIP, re-enumerate it 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE ,&stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

printf("Pointer invalid!\n"); 

break; 

}

if (!strcmp(chSerialNumber, (char*)(pDeviceInfo->SpecialInfo .stGigEInfo .chSerialNumber ))) 

{

nIndex = i; printf("Find it, serial number:[%s]\n", pDeviceInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

break; 

}

}

}

else 

{

printf("Find no devices!\n"); 

return false; 

}

if (-1 == nIndex) 

{

printf("Can't find the device, that just modified IP\n"); 

return false; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open device fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 设置 presistent IP | en: set presistent IP 

unsigned int nConfig = htonl(0x05); 

nRet = MV_CC_WriteMemory (handle , (const void*)&(nConfig), 

PERSISTENT_CONFIG_REG , sizeof(nConfig)); 

if ( MV_OK != nRet) 

{

printf("Write config fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nIpAddr1 = htonl(nIpAddr); 

nRet = MV_CC_WriteMemory (handle , (const void*)&(nIpAddr1), 

PERSISTENT_IPADDR_REG , sizeof(nIpAddr)); 

if ( MV_OK != nRet) 

{

printf("Write IP fail! nRet [0x%x]\n", nRet); 

break; 

}unsigned int nNetWorkMask1 = htonl(nNetWorkMask); 

nRet = MV_CC_WriteMemory (handle , (const void*)&(nNetWorkMask1), 

PERSISTENT_SUBNETMASK_REG , sizeof(nNetWorkMask)); 

if ( MV_OK != nRet) 

{

printf("Write network mask fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nDefaultGateway1 = htonl(nDefaultGateway); 

nRet = MV_CC_WriteMemory (handle , (const void*)&(nDefaultGateway1), PERSISTENT_DEFAULTGATEWAY_REG ,sizeof(nDefaultGateway)); 

if ( MV_OK != nRet) 

{

printf("Write default gateway fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

printf("Writing registers success\n"); 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

if (MV_OK != nRet) 

{

return false; 

}

return true; 

}首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# MultiLightCtrl_ImageStitching.cpp 

线阵相机分时曝光并拆图拼图 

该示例程序演示如何设置线阵相机采用 2组分时曝光参数，先拆图再自上而下拼图，最后将拼好的 

raw 图以 bmp 格式保存至本地。 

/* 

* 这个示例演示了线阵相机采用 2组分时曝光参数，先拆图再自上而下拼图，并将拼好的裸图以 

bmp 格式保存至本地。 

* This sample shows the linear array camera uses 2 sets of time-sharing exposure to acquire raw data 

* then disassemble the raw data and top-down puzzle 

* and last save to bmp format to local. 

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" bool g_bExit = false; 

#define IMAGE_NAME_LEN 256 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void); 

// ch: 是否是 HB 格式 | en:Whether it is HB format 

bool IsHBPixelFormat (MvGvspPixelType ePixelType); 

// ch: 是否是 Bayer 格式 | en:Whether it is Bayer format 

bool IsBayerPixelFormat (MvGvspPixelType enType); 

// ch: 打印设备信息 | en:Print device info 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo); 

// ch: 获取图像位深 | en:Get pixel size 

unsigned int GetPixelSize (enum MvGvspPixelType enPixelType); 

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned char* pReconstructBuffer = NULL; 

unsigned char* pDstBuf = NULL; 

unsigned int nExposureNum = 2; // 分时频闪的灯数 , 默认曝光个数为 2

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum - 1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = MV_CC_SetIntValue (handle , "GevSCPSPacketSize", nPacketSize); 

if (nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 获取数据包大小 | en:Get payload size 

MVCC_INTVALUE_EX stParam; 

memset(&stParam, 0, sizeof( MVCC_INTVALUE_EX )); 

nRet = MV_CC_GetIntValueEx (handle , "PayloadSize", &stParam); 

if ( MV_OK != nRet) 

{

printf("Get PayloadSize fail! nRet [0x%x]\n", nRet); 

break; 

}

int64_t nPayloadSize = stParam. nCurValue ;

// ch: 设置相机曝光组数为 "nExposureNum" | en:Set exposure num to "nExposureNum" 

int nRet = MV_CC_SetEnumValue (handle , "MultiLightControl", nExposureNum); 

if ( MV_OK != nRet) 

{

printf("Set MultiLightControl fail ，nRet:[%#x]\n", nRet); 

}

else 

{

printf("Set MultiLightControl to [%d]\n", nExposureNum); 

}

// ch: 获取实际的曝光个数 | en:Get actual nExposureNum 

nExposureNum = nExposureNum & 0xF; 

// ch: 设置触发模式为 off | en:Set trigger mode as off nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_FRAME_OUT stImageInfo = { 0 }; 

MV_RECONSTRUCT_IMAGE_PARAM stImgReconstructionParam = { 0 }; 

uint64_t nReconstructBufferSize = 0; 

MV_CC_HB_DECODE_PARAM stDecodeParam = { 0 }; 

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 20000);// 线阵相 机需要更大的图像获取间隔 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nExtendWidth ,stImageInfo. stFrameInfo .nExtendHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

bool bpixel = 

IsHBPixelFormat (stImageInfo. stFrameInfo .enPixelType ); 

if (bpixel) 

{

stDecodeParam. pSrcBuf = stImageInfo. pBufAddr ;

stDecodeParam. nSrcLen =stImageInfo. stFrameInfo .nFrameLenEx ;

if (pDstBuf == NULL) 

{

pDstBuf = (unsigned char*)malloc(sizeof(unsigned char) * (nPayloadSize * 3)); 

if (NULL == pDstBuf) 

{

printf("malloc pDstData fail !\n"); 

nRet = MV_E_RESOURCE ;

break; 

}

}stDecodeParam. pDstBuf = pDstBuf; 

stDecodeParam. nDstBufSize = nPayloadSize * 3; 

nRet = MV_CC_HB_Decode (handle , &stDecodeParam); 

if (nRet != MV_OK )

{

printf("Decode fail![0x%x]\n", nRet); 

break; 

}

else 

{

printf("HB Decode success!\n"); 

}

stImgReconstructionParam. nWidth = stDecodeParam. nWidth ;

stImgReconstructionParam. nHeight =stDecodeParam. nHeight ;

stImgReconstructionParam. enPixelType =stDecodeParam. enDstPixelType ;

stImgReconstructionParam. pSrcData =stDecodeParam. pDstBuf ;

stImgReconstructionParam. nSrcDataLen =stDecodeParam. nDstBufLen ;

}

else 

{

// 图像重构结构体赋值 

stImgReconstructionParam. nWidth =stImageInfo. stFrameInfo .nExtendWidth ;

stImgReconstructionParam. nHeight =stImageInfo. stFrameInfo .nExtendHeight ;

stImgReconstructionParam. enPixelType =stImageInfo. stFrameInfo .enPixelType ;

stImgReconstructionParam. pSrcData =stImageInfo. pBufAddr ;

stImgReconstructionParam. nSrcDataLen =stImageInfo. stFrameInfo .nFrameLenEx ;

}

// 申请总的拆分图像缓存，拆分后的图像保存在 pReconstructBuffer 中，后续 可以进行存图处理 

nReconstructBufferSize = stImgReconstructionParam. nSrcDataLen ;

pReconstructBuffer = (unsigned char*)malloc(sizeof(unsigned char) * nReconstructBufferSize); 

if (NULL == pReconstructBuffer) 

{

printf("malloc pReconstructBuffer fail! nRet [0x%x]\n", nRet); 

break; 

}

// 计算每张子图的大小 unsigned int nRowSize = stImgReconstructionParam. nWidth *

GetPixelSize (stImgReconstructionParam. enPixelType ); 

unsigned int nSubImageHight = stImgReconstructionParam. nHeight / nExposureNum; 

// Bayer 格式行高需要是 2的倍数 , 否则无法插值 

if (IsBayerPixelFormat (stImgReconstructionParam. enPixelType )) 

{

nSubImageHight = nSubImageHight / 2 * 2; 

}

uint64_t nSubImageSize = (uint64_t)nRowSize *nSubImageHight; 

// 输出数据缓存赋值，频闪数为 2

// 自上而下进行拼图 

for (int i = 0; i < nExposureNum; ++i) 

{

stImgReconstructionParam. stDstBufList [i]. pBuf =pReconstructBuffer + i * nSubImageSize; //pReconstructBuffer 偏移 

stImgReconstructionParam. stDstBufList [i]. nBufSize =nSubImageSize; 

}

stImgReconstructionParam. nExposureNum = nExposureNum; 

stImgReconstructionParam. enReconstructMethod =

MV_SPLIT_BY_LINE ;

// Split Image And Reconstruct Image 

nRet = MV_CC_ReconstructImage (handle ,&stImgReconstructionParam); 

if (MV_OK != nRet) 

{

printf("Reconstruct Image fail! nRet [0x%x]\n", nRet); 

break; 

}

// 存原始数据 bmp 图片 

char chImageName[ IMAGE_NAME_LEN ] = { 0 }; 

MV_CC_IMAGE stImage; 

memset(&stImage, 0, sizeof( MV_CC_IMAGE )); 

MV_CC_SAVE_IMAGE_PARAM stSaveImageParam; 

memset(&stSaveImageParam, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

stImage. enPixelType = stImgReconstructionParam. enPixelType ;

stImage. nWidth = stImgReconstructionParam. nWidth ;

stImage. nHeight = stImgReconstructionParam. nHeight ;

stImage. nImageLen = stImgReconstructionParam. nSrcDataLen ;

stImage. pImageBuf = stImgReconstructionParam. pSrcData ;stSaveImageParam. enImageType = MV_Image_Bmp ;

stSaveImageParam. iMethodValue = 1; 

sprintf_s(chImageName, IMAGE_NAME_LEN ,"InPut_w%d_h%d_fn%03d.bmp", stImage. nWidth , stImage. nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_SaveImageToFileEx2 (handle , &stImage, &stSaveImageParam, chImageName); 

if (nRet != MV_OK )

{

printf("raw image save to File fail nRet[%x]\n", nRet); 

}

else 

{

printf("raw image save to File success,save to %s\n", chImageName); 

}

// 存拆分拼接后 bmp 图片 

memset(&stImage, 0, sizeof( MV_CC_IMAGE )); 

stImage. enPixelType = stImgReconstructionParam. enPixelType ;

stImage. nWidth = stImgReconstructionParam. nWidth ;

for (int i = 0; i < nExposureNum; ++i) 

{

stImage. nHeight += stImgReconstructionParam. stDstBufList [i]. nHeight ;

stImage. nImageLen += stImgReconstructionParam. stDstBufList [i]. nBufLen ;

}

stImage. pImageBuf = pReconstructBuffer; 

sprintf_s(chImageName, IMAGE_NAME_LEN , "OutPut_w%d_h%d.bmp", stImage. nWidth , stImage. nHeight ); 

nRet = MV_CC_SaveImageToFileEx2 (handle , &stImage, &stSaveImageParam, chImageName); 

if (nRet != MV_OK )

{

printf("After reconstruction SaveImage To File fail nRet[%x]\n", nRet); 

}

else 

{

printf("After reconstruction SaveImage To File success, save to %s\n", chImageName); 

}nRet = MV_CC_FreeImageBuffer (handle , &stImageInfo); 

if (nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

if (NULL != pReconstructBuffer) 

{

free(pReconstructBuffer); 

pReconstructBuffer = NULL; 

}

if (NULL != pDstBuf) 

{

free(pDstBuf); 

pDstBuf = NULL; 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); if (MV_OK != nRet) 

{

if (NULL != pDstBuf) 

{

free(pDstBuf); 

pDstBuf = NULL; 

}

if (NULL != pReconstructBuffer) 

{

free(pReconstructBuffer); 

pReconstructBuffer = NULL; 

}

}

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

void WaitForKeyPress (void) 

{

while (!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool IsHBPixelFormat (MvGvspPixelType ePixelType) 

{

switch (ePixelType) 

{

case PixelType_Gvsp_HB_Mono8 :

case PixelType_Gvsp_HB_Mono10 :

case PixelType_Gvsp_HB_Mono10_Packed :

case PixelType_Gvsp_HB_Mono12 :

case PixelType_Gvsp_HB_Mono12_Packed :case PixelType_Gvsp_HB_Mono16 :

case PixelType_Gvsp_HB_RGB8_Packed :

case PixelType_Gvsp_HB_BGR8_Packed :

case PixelType_Gvsp_HB_RGBA8_Packed :

case PixelType_Gvsp_HB_BGRA8_Packed :

case PixelType_Gvsp_HB_RGB16_Packed :

case PixelType_Gvsp_HB_BGR16_Packed :

case PixelType_Gvsp_HB_RGBA16_Packed :

case PixelType_Gvsp_HB_BGRA16_Packed :

case PixelType_Gvsp_HB_YUV422_Packed :

case PixelType_Gvsp_HB_YUV422_YUYV_Packed :

case PixelType_Gvsp_HB_BayerGR8 :

case PixelType_Gvsp_HB_BayerRG8 :

case PixelType_Gvsp_HB_BayerGB8 :

case PixelType_Gvsp_HB_BayerBG8 :

case PixelType_Gvsp_HB_BayerRBGG8 :

case PixelType_Gvsp_HB_BayerGB10 :

case PixelType_Gvsp_HB_BayerGB10_Packed :

case PixelType_Gvsp_HB_BayerBG10 :

case PixelType_Gvsp_HB_BayerBG10_Packed :

case PixelType_Gvsp_HB_BayerRG10 :

case PixelType_Gvsp_HB_BayerRG10_Packed :

case PixelType_Gvsp_HB_BayerGR10 :

case PixelType_Gvsp_HB_BayerGR10_Packed :

case PixelType_Gvsp_HB_BayerGB12 :

case PixelType_Gvsp_HB_BayerGB12_Packed :

case PixelType_Gvsp_HB_BayerBG12 :

case PixelType_Gvsp_HB_BayerBG12_Packed :

case PixelType_Gvsp_HB_BayerRG12 :

case PixelType_Gvsp_HB_BayerRG12_Packed :

case PixelType_Gvsp_HB_BayerGR12 :

case PixelType_Gvsp_HB_BayerGR12_Packed :

return true; 

default: 

return false; 

}

}

bool IsBayerPixelFormat (MvGvspPixelType enType) 

{

switch (enType) 

{

case PixelType_Gvsp_BayerGR8 :

case PixelType_Gvsp_BayerRG8 :

case PixelType_Gvsp_BayerGB8 :

case PixelType_Gvsp_BayerBG8 :

case PixelType_Gvsp_BayerRBGG8 :

case PixelType_Gvsp_BayerGR10 :

case PixelType_Gvsp_BayerRG10 :

case PixelType_Gvsp_BayerGB10 :

case PixelType_Gvsp_BayerBG10 :

case PixelType_Gvsp_BayerGR12 :

case PixelType_Gvsp_BayerRG12 :

case PixelType_Gvsp_BayerGB12 :

case PixelType_Gvsp_BayerBG12 :

case PixelType_Gvsp_BayerGR10_Packed :case PixelType_Gvsp_BayerRG10_Packed :

case PixelType_Gvsp_BayerGB10_Packed :

case PixelType_Gvsp_BayerBG10_Packed :

case PixelType_Gvsp_BayerGR12_Packed :

case PixelType_Gvsp_BayerRG12_Packed :

case PixelType_Gvsp_BayerGB12_Packed :

case PixelType_Gvsp_BayerBG12_Packed :

case PixelType_Gvsp_BayerGR16 :

case PixelType_Gvsp_BayerRG16 :

case PixelType_Gvsp_BayerGB16 :

case PixelType_Gvsp_BayerBG16 :

return true; 

default: 

return false; 

}

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n", nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

unsigned int GetPixelSize (enum MvGvspPixelType enPixelType) 

{

return (((enPixelType & 0x00ff0000) >> 16) / 8); 

}

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Events_Interface.cpp 

打开并接受采集卡事件 

该示例程序演示了如何打开并接收采集卡事件。 

/* 

* 这个示例演示了打开并接收采集卡事件的功能 

* This sample shows how to turn on the specified event of frame grabber and receive the event. 

*

*/ 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

//ch ：打印设备信息 | en: Print the information of devices 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST & stDeviceList); 

//ch ：打印采集卡信息 | en: Print the information of frame grabbers 

bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST & stInterfaceInfoList); 

//ch: 事件回调函数 | en: Event callback function 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser); 

//ch: 取图回调函数 | en: Image callback function 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree); 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{Sleep(10); 

}

_getch(); 

}

int main () 

{

int nRet = MV_OK ;

//ch: 采集卡接口类型 | en: The interface type of frame grabber 

int nInterfaceType = MV_GIGE_INTERFACE | MV_CAMERALINK_INTERFACE |

MV_CXP_INTERFACE | MV_XOF_INTERFACE ;

void* hInterface = NULL; //ch: 采集卡句柄 | en: Handle of frame grabber 

void* hDevHandle = NULL; //ch: 设备句柄 | en: Handle of device 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 枚举采集卡 | en: Enumerate frame grabbers 

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

nRet = MV_CC_EnumInterfaces (nInterfaceType, &stInterfaceInfoList); 

if ( MV_OK != nRet) 

{

printf("Enum interfaces fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stInterfaceInfoList. nInterfaceNum > 0) 

{

PrintInterfaceInfo (stInterfaceInfoList); 

printf("Enum interfaces success!\n\n"); 

}

else 

{

printf("Find no interface!\n"); 

break; 

}printf("Please input interfaces index(0-%d):", stInterfaceInfoList. nInterfaceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stInterfaceInfoList. nInterfaceNum )

{

printf("Input error!\n"); 

break; 

}

//ch: 创建采集卡句柄 | en: Create the handle of frame grabber 

nRet = MV_CC_CreateInterface (& hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

if ( MV_OK == nRet) 

{

printf("Create interface success!\n"); 

}

else 

{

printf("Create interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 打开采集卡 | en: Open the frame grabber 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

if ( MV_OK == nRet) 

{

printf("Open interface success!\n"); 

}

else 

{

printf("Open interface fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch ：开启采集卡 ReceiveImageFrameStart0 事件 | en: Turn on the ReceiveImageFrameStart0 event of frame grabber 

nRet = MV_CC_EventNotificationOn (hInterface ,"ReceiveImageFrameStart0"); 

if (nRet != MV_OK )

{

printf("EventNotificationOn fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注册采集卡事件回调 | en:Register event callback 

nRet = MV_CC_RegisterEventCallBackEx (hInterface ,"ReceiveImageFrameStart0", EventCallBack , NULL); 

if ( MV_OK != nRet) {

printf("Register Event CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 枚举采集卡上的相机 | en: Enumerate the devices on the frame grabber 

MV_CC_DEVICE_INFO_LIST stDeviceList = {0}; 

nRet = MV_CC_EnumDevicesByInterface (hInterface , &stDeviceList); 

if (nRet != MV_OK )

{

printf("MV_CC_EnumDevicesByInterface fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum == 0) 

{

printf("no device! fail!\n"); 

break; 

}

PrintDeviceInfo (stDeviceList); 

// ch: 选择设备 0并创建句柄 | en:Select device 0 and create handle 

nIndex = 0; 

nRet = MV_CC_CreateHandle (&hDevHandle, stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Open device fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Open device success!\n"); 

// ch: 注册取图回调 | en:Register image callback nRet = MV_CC_RegisterImageCallBackEx2 (hDevHandle, 

ImageCallbackEx2 , hDevHandle, true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Close device success!\n"); 

// ch: 销毁设备句柄 | Destroy handle of device 

nRet = MV_CC_DestroyHandle (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Destroy handle fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Destroy device handle success!\n"); 

hDevHandle = NULL; //ch: 关闭采集卡 | en: Close the frame grabber 

nRet = MV_CC_CloseInterface (hInterface ); 

if ( MV_OK == nRet) 

{

printf("Close interface success!\n"); 

}

else 

{

printf("Close interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁采集卡句柄 | Destroy handle of frame grabber 

nRet = MV_CC_DestroyInterface (hInterface ); 

if ( MV_OK == nRet) 

{

printf("Destroy interface success!\n"); 

}

else 

{

printf("Destroy interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

hInterface = NULL; 

} while (0); 

if (hDevHandle != NULL) 

{

MV_CC_CloseDevice (hDevHandle); 

MV_CC_DestroyHandle (hDevHandle); 

hDevHandle = NULL; 

}

if (hInterface != NULL) 

{

MV_CC_CloseInterface (hInterface ); 

MV_CC_DestroyInterface (hInterface ); 

hInterface = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST & stDeviceList) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pstMVDevInfo = stDeviceList. pDeviceInfo [i]; 

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == 

MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

}

return true; 

}

bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST & stInterfaceInfoList) 

{

for (unsigned int i = 0; i < stInterfaceInfoList. nInterfaceNum ; i++) 

{

printf("[Interface %d]:\n", i); 

MV_INTERFACE_INFO * pstInterfaceInfo =stInterfaceInfoList. pInterfaceInfos [i]; 

if (NULL == pstInterfaceInfo) 

{

break; 

}

printf("Display name: %s\n",pstInterfaceInfo-> chDisplayName ); 

printf("Serial number: %s\n",pstInterfaceInfo-> chSerialNumber ); 

printf("model name: %s\n",pstInterfaceInfo-> chModelName ); 

printf("\n"); 

}

return true; 

}

void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser) 

{

if (pEventInfo) 

{

__int64 nTimestamp = pEventInfo-> nTimestampHigh ;

nTimestamp = (nTimestamp << 32) + pEventInfo-> nTimestampLow ;printf("EventName[%s], EventID[%u], Timestamp[%lld]\n", 

pEventInfo-> EventName , pEventInfo-> nEventID ,nTimestamp); 

}

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", pstFrame-> stFrameInfo .nWidth , pstFrame-> stFrameInfo .nHeight ,pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && 

NULL != pUser) // 手动释放 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ImageSave.cpp 保存相机设备图像 

该示例程序说明如何保存从相机获取到的图像。可保存的图像格式包含裸图 (.raw) 、jpeg 、bmp 、

tiff 、png 。

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

void* handle = NULL; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

// ch: 保存图片 | en:Save Image int SaveImage (MV_SAVE_IAMGE_TYPE enSaveImageType, MV_FRAME_OUT *stImageInfo) 

{

char chImageName[256] = {0}; 

MV_CC_IMAGE stImg; 

MV_CC_SAVE_IMAGE_PARAM stSaveParams; 

memset(&stSaveParams, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

memset(&stImg, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

stImg. enPixelType = stImageInfo-> stFrameInfo .enPixelType ;

stImg. nHeight = stImageInfo-> stFrameInfo .nHeight ;

stImg. nWidth = stImageInfo-> stFrameInfo .nWidth ;

stImg.nImageBufLen = stImageInfo-> stFrameInfo .nFrameLenEx ;

stImg. pImageBuf = stImageInfo-> pBufAddr ;

stSaveParams. enImageType = enSaveImageType; 

stSaveParams. iMethodValue = 1; 

stSaveParams. nQuality = 99; 

if (MV_Image_Bmp == stSaveParams. enImageType )

{

sprintf_s(chImageName, 256, "Image_w%d_h%d_fn%03d.bmp", stImageInfo-> stFrameInfo .nWidth ,stImageInfo-> stFrameInfo .nHeight ,stImageInfo-> stFrameInfo .nFrameNum ); 

}

else if ( MV_Image_Jpeg == stSaveParams. enImageType )

{

sprintf_s(chImageName, 256, "Image_w%d_h%d_fn%03d.jpg", stImageInfo-> stFrameInfo .nWidth ,stImageInfo-> stFrameInfo .nHeight ,stImageInfo-> stFrameInfo .nFrameNum ); 

}

else if ( MV_Image_Tif == stSaveParams. enImageType )

{

sprintf_s(chImageName, 256, "Image_w%d_h%d_fn%03d.tif", stImageInfo-> stFrameInfo .nWidth ,stImageInfo-> stFrameInfo .nHeight ,stImageInfo-> stFrameInfo .nFrameNum ); 

}

else if ( MV_Image_Png == stSaveParams. enImageType )

{

sprintf_s(chImageName, 256, "Image_w%d_h%d_fn%03d.png", stImageInfo-> stFrameInfo .nWidth ,stImageInfo-> stFrameInfo .nHeight ,stImageInfo-> stFrameInfo .nFrameNum ); 

}

int nRet = MV_CC_SaveImageToFileEx2 (handle ,&stImg, &stSaveParams, (char*)chImageName); 

return nRet; 

}

bool IsHBPixelFormat (MvGvspPixelType ePixelType) {

switch (ePixelType) 

{

case PixelType_Gvsp_HB_Mono8 :

case PixelType_Gvsp_HB_Mono10 :

case PixelType_Gvsp_HB_Mono10_Packed :

case PixelType_Gvsp_HB_Mono12 :

case PixelType_Gvsp_HB_Mono12_Packed :

case PixelType_Gvsp_HB_Mono16 :

case PixelType_Gvsp_HB_RGB8_Packed :

case PixelType_Gvsp_HB_BGR8_Packed :

case PixelType_Gvsp_HB_RGBA8_Packed :

case PixelType_Gvsp_HB_BGRA8_Packed :

case PixelType_Gvsp_HB_RGB16_Packed :

case PixelType_Gvsp_HB_BGR16_Packed :

case PixelType_Gvsp_HB_RGBA16_Packed :

case PixelType_Gvsp_HB_BGRA16_Packed :

case PixelType_Gvsp_HB_YUV422_Packed :

case PixelType_Gvsp_HB_YUV422_YUYV_Packed :

case PixelType_Gvsp_HB_BayerGR8 :

case PixelType_Gvsp_HB_BayerRG8 :

case PixelType_Gvsp_HB_BayerGB8 :

case PixelType_Gvsp_HB_BayerBG8 :

case PixelType_Gvsp_HB_BayerRBGG8 :

case PixelType_Gvsp_HB_BayerGB10 :

case PixelType_Gvsp_HB_BayerGB10_Packed :

case PixelType_Gvsp_HB_BayerBG10 :

case PixelType_Gvsp_HB_BayerBG10_Packed :

case PixelType_Gvsp_HB_BayerRG10 :

case PixelType_Gvsp_HB_BayerRG10_Packed :

case PixelType_Gvsp_HB_BayerGR10 :

case PixelType_Gvsp_HB_BayerGR10_Packed :

case PixelType_Gvsp_HB_BayerGB12 :

case PixelType_Gvsp_HB_BayerGB12_Packed :

case PixelType_Gvsp_HB_BayerBG12 :

case PixelType_Gvsp_HB_BayerBG12_Packed :

case PixelType_Gvsp_HB_BayerRG12 :

case PixelType_Gvsp_HB_BayerRG12_Packed :

case PixelType_Gvsp_HB_BayerGR12 :

case PixelType_Gvsp_HB_BayerGR12_Packed :

return true; 

default: 

return false; 

}

}

int main () 

{

int nRet = MV_OK ;

unsigned char * pDstBuf = NULL; // 用于 HB 解码 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValue (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 获取数据包大小 | en:Get payload size 

MVCC_INTVALUE stParam; 

memset(&stParam, 0, sizeof( MVCC_INTVALUE )); 

nRet = MV_CC_GetIntValue (handle , "PayloadSize", &stParam); 

if ( MV_OK != nRet) 

{

printf("Get PayloadSize fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nPayloadSize = stParam. nCurValue ;

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 0); 

if ( MV_OK != nRet) 

{printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_FRAME_OUT stImageInfo = {0}; 

MV_CC_HB_DECODE_PARAM stDecodeParam = {0}; 

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 20000); // 线阵 相机需要更大的图像获取间隔 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

printf("Please Input Save Image Type(raw/Jpeg/bmp/tiff/png):"); 

while (true) 

{

char chSaveImageType[128] ={0}; 

scanf("%s", chSaveImageType); 

if (0 == strcmp(chSaveImageType,"raw")) 

{

// 判断是否为 HB 模式 ,若是进行解码 

bool bflag = 

IsHBPixelFormat (stImageInfo. stFrameInfo .enPixelType ); 

if(bflag) 

{

stDecodeParam. pSrcBuf = stImageInfo. pBufAddr ;

stDecodeParam. nSrcLen =stImageInfo. stFrameInfo .nFrameLenEx ;

if (pDstBuf == NULL) 

{

pDstBuf = (unsigned char *)malloc(sizeof(unsigned char) * (nPayloadSize*3)); 

if (NULL == pDstBuf) 

{

printf("malloc pDstData fail !\n"); 

nRet = MV_E_RESOURCE ;

break; 

}

}stDecodeParam. pDstBuf = pDstBuf; 

stDecodeParam. nDstBufSize = nPayloadSize; 

nRet = MV_CC_HB_Decode (handle , &stDecodeParam); 

if (nRet != MV_OK )

{

printf("Decode fail![0x%x]\n", nRet); 

break; 

}

else 

{

printf("HB Decode success!\n"); 

}

// 保存裸图 

char chRawPath[256] = {0}; 

sprintf_s(chRawPath, 256, "Image_w%d_h%d_fn%03d.raw", stDecodeParam. nWidth ,stDecodeParam. nHeight , stImageInfo. stFrameInfo .nFrameNum ); 

FILE* file = fopen(chRawPath, "wb+"); 

if (NULL != file) 

{

// 写入数据到文件 

size_t bytesWritten =fwrite(stDecodeParam. pDstBuf , 1, stDecodeParam. nDstBufLen , file); 

if (stDecodeParam. nDstBufLen == bytesWritten) 

{

printf("Save image raw success.\n"); 

}

else 

{

printf("Save image raw failed.\n"); 

}

// 关闭文件 

fclose(file); 

}

}

else 

{

// 保存裸图 

char chRawPath[256] = {0}; 

sprintf_s(chRawPath, 256, "Image_w%d_h%d_fn%03d.raw", stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

FILE* file = fopen(chRawPath, "wb+"); 

if (NULL != file) 

{

// 写入数据到文件 size_t bytesWritten =fwrite(stImageInfo. pBufAddr , 1, stImageInfo. stFrameInfo .nFrameLenEx , file); 

if (stImageInfo. stFrameInfo .nFrameLen == bytesWritten) 

{

printf("Save image raw success.\n"); 

}

else 

{

printf("Save image raw failed.\n"); 

}

// 关闭文件 

fclose(file); 

}

}

break; 

}

else if(0 == strcmp(chSaveImageType,"Jpeg")) 

{

nRet = SaveImage (MV_Image_Jpeg ,&stImageInfo); 

if( MV_OK == nRet) 

{

printf("Save Image Jpeg success.\n"); 

}

else 

{

printf("Save image Jpeg failed.\n"); 

}

break; 

}

else if(0 == strcmp(chSaveImageType,"bmp")) 

{

nRet = SaveImage (MV_Image_Bmp ,&stImageInfo); 

if( MV_OK == nRet) 

{

printf("Save Image bmp success.\n"); 

}

else 

{

printf("Save image bmp failed.\n"); 

}

break; 

}

else if(0 == strcmp(chSaveImageType,"tiff")) 

{

nRet = SaveImage (MV_Image_Tif ,&stImageInfo); 

if( MV_OK == nRet) 

{

printf("Save Image tif success.\n"); 

}

else 

{printf("Save image tif failed.\n"); 

}

break; 

}

else if(0 == strcmp(chSaveImageType,"png")) 

{

nRet = SaveImage (MV_Image_Png ,&stImageInfo); 

if( MV_OK == nRet) 

{

printf("Save Image png success.\n"); 

}

else 

{

printf("Save image png failed.\n"); 

}

break; 

}

else 

{

printf("Input not supoort,Please Input Save Image Type(raw/Jpeg/bmp/tiff/png):"); 

continue; 

}

}

if (MV_OK != nRet) 

{

if(NULL != pDstBuf) 

{

free (pDstBuf); 

pDstBuf = NULL; 

}

}

nRet = MV_CC_FreeImageBuffer (handle , &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# GrabImage_Display.cpp 

图像采集并显示 

该示例程序演示如何取图并显示取到的每一帧图像。 

#include <stdio.h> 

#include <process.h> 

#include <conio.h> 

#include "windows.h" 

#include "MvCameraControl.h" 

HWND g_hwnd = NULL; 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{printf("Not support.\n"); 

}

return true; 

}

LRESULT CALLBACK WndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) 

{

switch(msg) 

{

case WM_DESTROY: 

PostQuitMessage(0); 

g_hwnd = NULL; 

break; 

}

return DefWindowProc(hWnd, msg, wParam, lParam); 

}

static unsigned int __stdcall CreateRenderWindow (void* pUser) 

{

HINSTANCE hInstance = ::GetModuleHandle(NULL); // 获取应 用程序的模块句柄 

WNDCLASSEX wc; 

wc.cbSize = sizeof(wc); 

wc.style = CS_HREDRAW | CS_VREDRAW; // 窗口的 风格 

wc.cbClsExtra = 0; 

wc.cbWndExtra = 0; 

wc.hInstance = hInstance; 

wc.hIcon = ::LoadIcon(NULL, IDI_APPLICATION); // 图标风 格

wc.hIconSm = ::LoadIcon( NULL, IDI_APPLICATION ); 

wc.hbrBackground = (HBRUSH)( COLOR_WINDOW + 1); // 背景色 

wc.hCursor = ::LoadCursor(NULL, IDC_ARROW); // 鼠标风 格

wc.lpfnWndProc = WndProc ; // 自定义 消息处理函数 

wc.lpszMenuName = NULL; 

wc.lpszClassName = "RenderWindow"; // 该窗口 类的名称 

if(!RegisterClassEx(&wc)) 

{

return 0; 

}

DWORD style = WS_OVERLAPPEDWINDOW; DWORD styleEx = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE; 

RECT rect = {0, 0, 640, 480}; 

AdjustWindowRectEx(&rect, style, false, styleEx); 

HWND hWnd = CreateWindowEx(styleEx, "RenderWindow", "Display", style, 0, 0, 

rect.right - rect.left, rect.bottom - rect.top, NULL, NULL, hInstance, NULL); 

if(hWnd == NULL) 

{

return 0; 

}

::UpdateWindow(hWnd); 

::ShowWindow(hWnd, SW_SHOW); 

g_hwnd = hWnd; 

MSG msg = {0}; 

while(msg.message != WM_QUIT) 

{

if(PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) 

{

TranslateMessage(&msg); 

DispatchMessage(&msg); 

}

}

return 0; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

MV_CC_IMAGE stImageData = { 0 }; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nExtendWidth ,stImageInfo. stFrameInfo .nExtendHeight ,stImageInfo. stFrameInfo .nFrameNum ); if (g_hwnd )

{

stImageData. nWidth =stImageInfo. stFrameInfo .nExtendWidth ;

stImageData. nHeight =stImageInfo. stFrameInfo .nExtendHeight ;

stImageData. enPixelType =stImageInfo. stFrameInfo .enPixelType ;

stImageData.nImageBufLen = stImageInfo. stFrameInfo .nFrameLenEx ;

stImageData. pImageBuf = stImageInfo. pBufAddr ;

MV_CC_DisplayOneFrameEx2 (pUser, g_hwnd , &stImageData,0); 

}

nRet = MV_CC_FreeImageBuffer (pUser, &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList = {0}; nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) {

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hCreateWindow = (void*) _beginthreadex( NULL , 0 , 

CreateRenderWindow , handle , 0 , &nThreadID); 

if (NULL == hCreateWindow) 

{

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

WaitForSingleObject(hThreadHandle, INFINITE); 

CloseHandle(hThreadHandle); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# InterfaceAndDeviceDemo.cpp 

采集卡下的相机控制 

该示例程序说明如何通过普通枚举接口枚举到自研采集卡下的相机，并实现打开相机、开始取流等 操作。 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

//ch ：打印设备信息 | en: Print the information of devices 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST & stDeviceList); 

//ch ：打印采集卡信息 | en: Print the information of frame grabbers bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST & stInterfaceInfoList); 

//ch ：取流回调函数 | en: Stream grabbing callback function 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree); 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

int main () 

{

int nRet = MV_OK ;

// ch: 初始化 SDK | en:Initialize SDK 

MV_CC_Initialize (); 

//ch: 采集卡接口类型 | en: The interface type of frame grabber 

int nInterfaceType = MV_GIGE_INTERFACE | MV_CAMERALINK_INTERFACE |

MV_CXP_INTERFACE | MV_XOF_INTERFACE ;

void* hInterface = NULL; //ch: 采集卡句柄 | en: Handle of frame grabber 

void* hDevHandle = NULL; //ch: 设备句柄 | en: Handle of device 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 枚举采集卡 | en: Enumerate frame grabbers 

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

nRet = MV_CC_EnumInterfaces (nInterfaceType, &stInterfaceInfoList); 

if ( MV_OK != nRet) 

{

printf("Enum interfaces fail! nRet [0x%x]\n", nRet); 

break; 

}if (stInterfaceInfoList. nInterfaceNum > 0) 

{

PrintInterfaceInfo (stInterfaceInfoList); 

printf("Enum interfaces success!\n\n"); 

}

else 

{

printf("Find no interface!\n"); 

break; 

}

printf("Please input interfaces index(0-%d):", stInterfaceInfoList. nInterfaceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stInterfaceInfoList. nInterfaceNum )

{

printf("Input error!\n"); 

break; 

}

//ch: 创建采集卡句柄 | en: Create the handle of frame grabber 

nRet = MV_CC_CreateInterface (& hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

if ( MV_OK == nRet) 

{

printf("Create interface success!\n"); 

}

else 

{

printf("Create interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 打开采集卡 | en: Open the frame grabber 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

if ( MV_OK == nRet) 

{

printf("Open interface success!\n"); 

}

else 

{

printf("Open interface fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch: 枚举采集卡上的相机 | en: Enumerate the devices on the frame grabber MV_CC_DEVICE_INFO_LIST stDeviceList = {0}; 

nRet = MV_CC_EnumDevicesByInterface (hInterface , &stDeviceList); 

if (nRet != MV_OK )

{

printf("MV_CC_EnumDevicesByInterface fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum == 0) 

{

printf("no device! fail!\n"); 

break; 

}

PrintDeviceInfo (stDeviceList); 

printf("Please input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (&hDevHandle, stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Open device fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Open device success!\n"); // ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (hDevHandle); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (hDevHandle,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (hDevHandle, 

ImageCallbackEx2 , hDevHandle, true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (hDevHandle, "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (hDevHandle); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Start grabbing success!\n"); 

printf("Press a key to stop grabbing.\n"); WaitForKeyPress (); 

//ch ：停止取流 | en: Stop grabbing 

MV_CC_StopGrabbing (hDevHandle); 

printf("Stop grabbing success!\n"); 

// ch: 关闭设备 | Close device 

MV_CC_CloseDevice (hDevHandle); 

printf("Close device success!\n"); 

// ch: 销毁设备句柄 | Destroy handle of device 

MV_CC_DestroyHandle (hDevHandle); 

printf("Destroy device handle success!\n"); 

hDevHandle = NULL; 

//ch: 关闭采集卡 | en: Close the frame grabber 

MV_CC_CloseInterface (hInterface ); 

printf("Close interface success!\n"); 

// ch: 销毁采集卡句柄 | Destroy handle of frame grabber 

nRet = MV_CC_DestroyInterface (hInterface ); 

printf("Destroy interface success!\n"); 

hInterface = NULL; 

} while (0); 

if (hDevHandle != NULL) 

{

MV_CC_CloseDevice (hDevHandle); 

MV_CC_DestroyHandle (hDevHandle); 

hDevHandle = NULL; 

}

if (hInterface != NULL) 

{

MV_CC_CloseInterface (hInterface ); 

MV_CC_DestroyInterface (hInterface ); 

hInterface = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST & stDeviceList) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pstMVDevInfo = stDeviceList. pDeviceInfo [i]; 

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp 

& 0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == 

MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

}

return true; 

}

bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST & stInterfaceInfoList) 

{

for (unsigned int i = 0; i < stInterfaceInfoList. nInterfaceNum ; i++) 

{

printf("[Interface %d]:\n", i); 

MV_INTERFACE_INFO * pstInterfaceInfo =stInterfaceInfoList. pInterfaceInfos [i]; 

if (NULL == pstInterfaceInfo) 

{

break; 

}

printf("Display name: %s\n",pstInterfaceInfo-> chDisplayName ); 

printf("Serial number: %s\n",pstInterfaceInfo-> chSerialNumber ); 

printf("model name: %s\n",pstInterfaceInfo-> chModelName ); 

printf("\n"); 

}

return true; 

}void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

pstFrame-> stFrameInfo .nExtendWidth , pstFrame->stFrameInfo .nExtendHeight , pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && 

NULL != pUser) // 非自动释放模式，需要手动释放资源 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> 宏定义

# GigE_STATUS 错误码   

> 状态码 »SDK 内部自定义状态码

范围为 0x80000200-0x800002FF 更多 ... 宏定义 

#define MV_E_NOT_IMPLEMENTED 0x80000200 

命令不被设备支持 更多 ... 

#define MV_E_INVALID_ADDRESS 0x80000201 

访问的目标地址不存在 更多 ... 

#define MV_E_WRITE_PROTECT 0x80000202 

目标地址不可写 更多 ... 

#define MV_E_ACCESS_DENIED 0x80000203 

设备无访问权限 更多 ... 

#define MV_E_BUSY 0x80000204 

设备忙，或网络断开 更多 ... 

#define MV_E_PACKET 0x80000205 

网络包数据错误 更多 ... 

#define MV_E_NETER 0x80000206 

网络相关错误 更多 ... 

#define MV_E_SUPPORT_MODIFY_DEVICE_IP 0x8000020E 

在固定 IP 模式下不支持修改设备 IP 模式 更多 ... 

#define MV_E_KEY_VERIFICATION 0x8000020F 

秘钥校验错误 更多 ... 

#define MV_E_IP_CONFLICT 0x80000221 

设备 IP 冲突 更多 ... 

# 详细描述 

范围为 0x80000200-0x800002FF 宏定义说明 

◆ MV_E_NOT_IMPLEMENTED 

#define MV_E_NOT_IMPLEMENTED 0x80000200 

命令不被设备支持 

◆ MV_E_INVALID_ADDRESS 

#define MV_E_INVALID_ADDRESS 0x80000201 

访问的目标地址不存在 

◆ MV_E_WRITE_PROTECT 

#define MV_E_WRITE_PROTECT 0x80000202 

目标地址不可写 

◆ MV_E_ACCESS_DENIED 

#define MV_E_ACCESS_DENIED 0x80000203 

设备无访问权限 

◆ MV_E_BUSY 

#define MV_E_BUSY 0x80000204 

设备忙，或网络断开 

◆ MV_E_PACKET 

#define MV_E_PACKET 0x80000205 网络包数据错误 

◆ MV_E_NETER 

#define MV_E_NETER 0x80000206 

网络相关错误 

◆ MV_E_SUPPORT_MODIFY_DEVICE_IP 

#define MV_E_SUPPORT_MODIFY_DEVICE_IP 0x8000020E 

在固定 IP 模式下不支持修改设备 IP 模式 

◆ MV_E_KEY_VERIFICATION 

#define MV_E_KEY_VERIFICATION 0x8000020F 

秘钥校验错误 

◆ MV_E_IP_CONFLICT 

#define MV_E_IP_CONFLICT 0x80000221 

设备 IP 冲突 

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# MultiCast.cpp 

设置组播模式 

该示例程序说明如何设置传输模式为组播模式。通过询问用户启动多播控制应用程序或者多播监控 应用程序，然后根据用户输入，以对应的访问权限打开相机，最后通过 

MV_GIGE_SetTransmissionType() 设置组播模式。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (pUser, &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 |en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf("%d", &nIndex); if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 询问用户启动多播控制应用程序或多播监控应用程序 

// en:Ask the user to launch: the multicast controlling application or the multicast monitoring application. 

printf("Start multicast sample in (c)ontrol or in (m)onitor mode? (c/m)\n"); 

char key; 

do 

{

scanf("%c", &key); 

}

while ( (key != 'c') && (key != 'm') && (key != 'C') && (key != 'M')); 

// ch: 查询用户使用的模式 | en:Query the user for the mode to use. 

bool monitorMode = (key == 'm') || (key == 'M'); 

// ch: 打开设备 | Open device 

if (monitorMode) 

{

nRet = MV_CC_OpenDevice (handle , MV_ACCESS_Monitor ); 

}

else 

{

nRet = MV_CC_OpenDevice (handle , MV_ACCESS_Control ); 

}

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; }

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE && false == monitorMode) 

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!\n", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!\n", nPacketSize); 

}

}

// ch: 指定组播 ip | en:multicast IP 

char strIp[] = "239.192.1.23"; 

unsigned int nIp1, nIp2, nIp3, nIp4, nIp; 

sscanf_s(strIp, "%d.%d.%d.%d", &nIp1, &nIp2, &nIp3, &nIp4); 

nIp = (nIp1 << 24) | (nIp2 << 16) | (nIp3 << 8) | nIp4; 

// ch: 可指定端口号作为组播组端口 | en:multicast port 

MV_TRANSMISSION_TYPE stTransmissionType; 

memset(&stTransmissionType, 0, sizeof( MV_TRANSMISSION_TYPE )); 

stTransmissionType. enTransmissionType =

MV_GIGE_TRANSTYPE_MULTICAST ;

stTransmissionType. nDestIp = nIp; 

stTransmissionType. nDestPort = 1042; 

nRet = MV_GIGE_SetTransmissionType (handle , &stTransmissionType); 

if ( MV_OK != nRet) 

{

printf("Set Transmission Type fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# InterfaceDemo.cpp 

采集卡的枚举及控制 

该示例程序说明如何通过枚举接口枚举自研采集卡，并实现打开采集卡、设置属性等操作。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

void* hInterface = NULL; // ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintInterfaceInfo (MV_INTERFACE_INFO * pstInterfaceInfo) 

{

if (NULL == pstInterfaceInfo) 

{

printf("The Pointer of pstInterfaceInfo is NULL!\n"); 

return false; 

}

printf("Display name: %s\n",pstInterfaceInfo-> chDisplayName ); 

printf("Serial number: %s\n",pstInterfaceInfo-> chSerialNumber ); 

printf("model name: %s\n",pstInterfaceInfo-> chModelName ); 

printf("\n"); 

return true; 

}

void Set_Get_Enum (const char* str) 

{

MVCC_ENUMVALUE stEnumValue = {0}; 

MVCC_ENUMENTRY stEnumentryInfo = {0}; 

int nRet = MV_CC_GetEnumValue (hInterface ,str, &stEnumValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str, nRet); 

return; 

}

stEnumentryInfo. nValue = stEnumValue. nCurValue ;

nRet = MV_CC_GetEnumEntrySymbolic (hInterface ,str, &stEnumentryInfo); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%s] Success!\n",str,stEnumentryInfo. chSymbolic ); 

}MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetEnumValue (hInterface ,str,stEnumValue. nCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%s] Success!\n",str,stEnumentryInfo. chSymbolic ); 

}

}

}

void Set_Get_Bool (const char* str) 

{

bool bValue = false; 

int nRet = MV_CC_GetBoolValue (hInterface ,str, &bValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%d] Success!\n",str,bValue); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetBoolValue (hInterface ,str, bValue); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%d] Success!\n",str,bValue); 

}

}

}

void Set_Get_Int (const char* str) 

{

MVCC_INTVALUE_EX stIntValue; 

int nRet = MV_CC_GetIntValueEx (hInterface ,str,&stIntValue); 

if (MV_OK != nRet) {

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%d] Success!\n",str,stIntValue. nCurValue ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetIntValueEx (hInterface ,str,stIntValue. nCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%d] Success!\n",str,stIntValue. nCurValue ); 

}

}

}

void Set_Get_String (const char* str) 

{

MVCC_STRINGVALUE StringValue; 

int nRet = MV_CC_GetStringValue (hInterface ,str, &StringValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%s] Success!\n",str,StringValue. chCurValue ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetStringValue (hInterface ,str, StringValue. chCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{printf("Set %s = [%s] Success!\n",str,StringValue. chCurValue ); 

}

}

}

void Set_Get_Float (const char* str) 

{

MVCC_FLOATVALUE FloatValue; 

int nRet = MV_CC_GetFloatValue (hInterface ,str, &FloatValue); 

if (MV_OK != nRet) 

{

printf("Get %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Get %s = [%f] Success!\n",str,FloatValue. fCurValue ); 

}

MV_XML_AccessMode enAccessMode = AM_NI ;

nRet = MV_XML_GetNodeAccessMode (hInterface , str, &enAccessMode); 

if( MV_OK == nRet && AM_RW == enAccessMode) 

{

nRet = MV_CC_SetFloatValue (hInterface ,str, FloatValue. fCurValue ); 

if ( MV_OK != nRet) 

{

printf("Set %s Fail! nRet [0x%x]\n", str,nRet); 

return; 

}

else 

{

printf("Set %s = [%f] Success!\n",str,FloatValue. fCurValue ); 

}

}

}

int main () 

{

int nRet = MV_OK ;

printf("[0]: GIGE Interface\n"); 

printf("[1]: CAMERALINK Interface\n"); 

printf("[2]: CXP Interface\n"); 

printf("[3]: XoF Interface\n\n"); 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) {

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_INTERFACE_INFO_LIST stInterfaceInfoList={0}; 

unsigned int nType = 0; 

printf("Please Input Enum Interfaces Type(0-%d):", 3); 

scanf_s("%d", &nType); 

switch(nType) 

{

case 0: 

{

nRet = MV_CC_EnumInterfaces (MV_GIGE_INTERFACE ,&stInterfaceInfoList); 

break; 

}

case 1: 

{

nRet = MV_CC_EnumInterfaces (MV_CAMERALINK_INTERFACE ,&stInterfaceInfoList); 

break; 

}

case 2: 

{

nRet = MV_CC_EnumInterfaces (MV_CXP_INTERFACE ,&stInterfaceInfoList); 

break; 

}

case 3: 

{

nRet = MV_CC_EnumInterfaces (MV_XOF_INTERFACE ,&stInterfaceInfoList); 

break; 

}

default: 

{

printf("Input error!\n"); 

break; 

}

}

// 枚举采集卡 

if ( MV_OK != nRet) 

{

printf("Enum Interfaces fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stInterfaceInfoList. nInterfaceNum > 0) {

for (unsigned int i = 0; i < stInterfaceInfoList. nInterfaceNum ; i++) 

{

printf("[Interface %d]:\n", i); 

MV_INTERFACE_INFO * pstInterfaceInfo =stInterfaceInfoList. pInterfaceInfos [i]; 

if (NULL == pstInterfaceInfo) 

{

break; 

}

PrintInterfaceInfo (pstInterfaceInfo); 

}

printf("Enum Interfaces success!\n\n"); 

}

else 

{

printf("Find No Interface!\n"); 

break; 

}

printf("Please Input Interfaces index(0-%d):", stInterfaceInfoList. nInterfaceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stInterfaceInfoList. nInterfaceNum )

{

printf("Input error!\n"); 

break; 

}

// 创建采集卡句柄 

nRet = MV_CC_CreateInterface (& hInterface ,stInterfaceInfoList. pInterfaceInfos [nIndex]); 

if ( MV_OK == nRet) 

{

printf("Create Interface success!\n"); 

}

else 

{

printf("Create Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 打开采集卡 

nRet = MV_CC_OpenInterface (hInterface , NULL); 

if ( MV_OK == nRet) 

{

printf("Open Interface success!\n"); 

}

else 

{printf("Open Interface fail! nRet [0x%x]\n", nRet); 

break; 

}

// 采集卡属性操作 ,不同类型卡对各自常用属性进行获取和设置 

switch(nType) 

{

case 0: 

{

//MV_GIGE_INTERFACE 卡属性获取和设置操作 

Set_Get_Enum ("StreamSelector"); 

Set_Get_Enum ("TimerSelector"); 

Set_Get_Enum ("TimerTriggerSource"); 

Set_Get_Enum ("TimerTriggerActivation"); 

Set_Get_Bool ("HBDecompression"); 

Set_Get_Int ("TimerDuration"); 

Set_Get_Int ("TimerDelay"); 

Set_Get_Int ("TimerFrequency"); 

break; 

}

case 1: 

{

//MV_CAMERALINK_INTERFACE 卡属性操作 

Set_Get_Enum ("StreamSelector"); 

Set_Get_Enum ("CameraType"); 

Set_Get_Enum ("StreamPartialImageControl"); 

Set_Get_Int ("ImageHeight"); 

Set_Get_Int ("FrameTimeoutTime"); 

break; 

}

case 2: 

{

//MV_CXP_INTERFACE 卡属性操作 

Set_Get_Enum ("StreamSelector"); 

Set_Get_String ("CurrentStreamDevice"); 

Set_Get_Int ("StreamEnableStatus"); 

Set_Get_Bool ("BayerCFAEnable"); 

Set_Get_Bool ("IspGammaEnable"); 

Set_Get_Float ("IspGamma"); 

break; 

}

case 3: 

{

//MV_XOF_INTERFACE 卡属性操作 

Set_Get_Enum ("StreamSelector"); 

Set_Get_String ("CurrentStreamDevice"); 

Set_Get_Int ("StreamEnableStatus"); 

Set_Get_Bool ("BayerCFAEnable"); 

Set_Get_Bool ("IspGammaEnable"); 

Set_Get_Float ("IspGamma"); 

break; 

}

default: 

{

printf("Input error!\n"); break; 

}

}

// 关闭采集卡 

nRet = MV_CC_CloseInterface (hInterface ); 

if ( MV_OK == nRet) 

{

printf("Close Interface success!\n"); 

}

else 

{

printf("Close Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// 销毁采集卡句柄 

nRet = MV_CC_DestroyInterface (hInterface ); 

if ( MV_OK == nRet) 

{

printf("Destroy Interface success!\n"); 

}

else 

{

printf("Destroy Interface Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

hInterface = NULL; 

} while (0); 

if (hInterface != NULL) 

{

MV_CC_CloseInterface (hInterface ); 

MV_CC_DestroyInterface (hInterface ); 

hInterface = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# ImageSave.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

int SaveImage (MV_SAVE_IAMGE_TYPE enSaveImageType, MV_FRAME_OUT 

*stImageInfo) 

bool IsHBPixelFormat (MvGvspPixelType ePixelType) 

int main () 

# 变量 

bool g_bExit = false void * handle = NULL 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ImageSave.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ImageSave.cpp .

◆ SaveImage() 

int SaveImage ( MV_SAVE_IAMGE_TYPE enSaveImageType, 

MV_FRAME_OUT * stImageInfo 

)

示例 

ImageSave.cpp .

◆ IsHBPixelFormat() 

bool IsHBPixelFormat ( MvGvspPixelType ePixelType )

示例 

ImageSave.cpp .◆ main() 

int main ( )

示例 

ImageSave.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

ImageSave.cpp .

◆ handle 

void* handle = NULL 

示例 

ChunkData.cpp , ConnectSpecCamera.cpp , ConvertPixelType.cpp ,

DynamicallyLoadDLL.cpp , Events.cpp , ForceIPEx.cpp ,

Grab_ActionCommand.cpp , Grab_Asynchronous.cpp , Grab_Callback.cpp ,

GrabImage.cpp , GrabImage_Display.cpp , GrabStrategies.cpp ,

HighBandwidthDecode.cpp , ImageContrast.cpp , ImageSave.cpp ,

LensShadingCorrection.cpp , LineScanSoftwareTrigger.cpp , MultiCast.cpp ,

MultiLightCtrl_ImageStitching.cpp ,

ParametrizeCamera_AreaScanIOSettings.cpp ,

ParametrizeCamera_FileAccess.cpp ,

ParametrizeCamera_LineScanIOSettings.cpp ,

ParametrizeCamera_LoadAndSave.cpp , 以及 Recording.cpp .

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> AreaScanCamera
> 函数 |变量

# LensShadingCorrection.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

int main () 

# 变量 

unsigned char * g_pDstData = NULL 

unsigned int g_nDstDataSize = 0 

unsigned char * g_pCalibBuf = NULL 

unsigned int g_nCalibBufSize = 0 

bool g_IsNeedCalib = true 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

LensShadingCorrection.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

LensShadingCorrection.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

LensShadingCorrection.cpp .

◆ main() 

int main ( )

示例 

LensShadingCorrection.cpp .

# 变量说明 ◆ g_pDstData 

unsigned char* g_pDstData = NULL 

示例 

LensShadingCorrection.cpp .

◆ g_nDstDataSize 

unsigned int g_nDstDataSize = 0 

示例 

LensShadingCorrection.cpp .

◆ g_pCalibBuf 

unsigned char* g_pCalibBuf = NULL 

示例 

LensShadingCorrection.cpp .

◆ g_nCalibBufSize 

unsigned int g_nCalibBufSize = 0 

示例 

LensShadingCorrection.cpp .

◆ g_IsNeedCalib 

bool g_IsNeedCalib = true 

示例 

LensShadingCorrection.cpp .

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> FrameGrabber
> 函数 |变量

# InterfaceDemo.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintInterfaceInfo (MV_INTERFACE_INFO *pstInterfaceInfo) 

void Set_Get_Enum (const char *str) 

void Set_Get_Bool (const char *str) 

void Set_Get_Int (const char *str) 

void Set_Get_String (const char *str) 

void Set_Get_Float (const char *str) 

int main () 

# 变量 

void * hInterface = NULL 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

InterfaceDemo.cpp .

◆ PrintInterfaceInfo() 

bool PrintInterfaceInfo ( MV_INTERFACE_INFO * pstInterfaceInfo )

示例 

InterfaceDemo.cpp .

◆ Set_Get_Enum() 

void Set_Get_Enum ( const char * str )

示例 

InterfaceDemo.cpp .

◆ Set_Get_Bool() 

void Set_Get_Bool ( const char * str )

示例 

InterfaceDemo.cpp .

◆ Set_Get_Int() 

void Set_Get_Int ( const char * str )

示例 

InterfaceDemo.cpp .◆ Set_Get_String() 

void Set_Get_String ( const char * str )

示例 

InterfaceDemo.cpp .

◆ Set_Get_Float() 

void Set_Get_Float ( const char * str )

示例 

InterfaceDemo.cpp .

◆ main() 

int main ( )

示例 

InterfaceDemo.cpp .

# 变量说明 

◆ hInterface 

void* hInterface = NULL 

示例 

Events_Interface.cpp , InterfaceAndDeviceDemo.cpp , 以及 InterfaceDemo.cpp .

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> FrameGrabber
> 函数

# Events_Interface.cpp 文件参考 

# 函数 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST &stDeviceList) 

bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST &stInterfaceInfoList) 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO *pEventInfo, void *pUser) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

void WaitForKeyPress (void) 

int main () 

# 函数说明 

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO_LIST & stDeviceList )

示例 

Events_Interface.cpp .◆ PrintInterfaceInfo() 

bool PrintInterfaceInfo ( MV_INTERFACE_INFO_LIST & stInterfaceInfoList )

示例 

Events_Interface.cpp .

◆ EventCallBack() 

void __stdcall EventCallBack ( MV_EVENT_OUT_INFO * pEventInfo, 

void * pUser 

)

示例 

Events_Interface.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

Events_Interface.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Events_Interface.cpp .

◆ main() 

int main ( )

示例 

Events_Interface.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> FrameGrabber
> 函数 |变量

# QuickSoftwareTrigger.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintInterfaceInfo (MV_INTERFACE_INFO *pstInterfaceInfo) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

void * g_hInterface = NULL bool g_bExit = false 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

QuickSoftwareTrigger.cpp .

◆ PrintInterfaceInfo() 

bool PrintInterfaceInfo ( MV_INTERFACE_INFO * pstInterfaceInfo )

示例 

QuickSoftwareTrigger.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

QuickSoftwareTrigger.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

QuickSoftwareTrigger.cpp .

◆ main() int main ( )

示例 

QuickSoftwareTrigger.cpp .

# 变量说明 

◆ g_hInterface 

void* g_hInterface = NULL 

示例 

QuickSoftwareTrigger.cpp .

◆ g_bExit 

bool g_bExit = false 

示例 

QuickSoftwareTrigger.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 samples   

> AreaScanCamera
> 函数 |变量

# ParametrizeCamera_AreaScanIOSettings.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

int main () 

# 变量 

bool g_bExit = false 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ParametrizeCamera_AreaScanIOSettings.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ParametrizeCamera_AreaScanIOSettings.cpp .◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

ParametrizeCamera_AreaScanIOSettings.cpp .

◆ main() 

int main ( )

示例 

ParametrizeCamera_AreaScanIOSettings.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

ParametrizeCamera_AreaScanIOSettings.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# GrabImage_Display.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

LRESULT CALLBACK WndProc (HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) 

static unsigned int __stdcall CreateRenderWindow (void *pUser) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

HWND g_hwnd = NULL 

bool g_bExit = false 

# 函数说明 ◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

GrabImage_Display.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

GrabImage_Display.cpp .

◆ WndProc() 

LRESULT CALLBACK WndProc ( HWND hWnd, 

UINT msg, 

WPARAM wParam, 

LPARAM lParam 

)

示例 

GrabImage_Display.cpp .

◆ CreateRenderWindow() 

static unsigned int __stdcall CreateRenderWindow ( void * 

pUse r )

> stati c

示例 

GrabImage_Display.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

GrabImage_Display.cpp .◆ main() 

int main ( )

示例 

GrabImage_Display.cpp .

# 变量说明 

◆ g_hwnd 

HWND g_hwnd = NULL 

示例 

GrabImage_Display.cpp .

◆ g_bExit 

bool g_bExit = false 

示例 

GrabImage_Display.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明   

> samples
> General
> 宏定义 |函数

# HighBandwidthDecode.cpp 文件参考 

# 宏定义 

#define IMAGE_NAME_LEN 256 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

int main () 

# 宏定义说明 

◆ IMAGE_NAME_LEN 

#define IMAGE_NAME_LEN 256 

示例 

HighBandwidthDecode.cpp .

# 函数说明 

◆ WaitForKeyPress() void WaitForKeyPress ( void )

示例 

HighBandwidthDecode.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

HighBandwidthDecode.cpp .

◆ main() 

int main ( )

示例 

HighBandwidthDecode.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ConnectSpecCamera.cpp 

通过 IP 地址连接相机 该示例程序说明如何通过 IP 地址连接网口相机。通过输入需要连接的相机 IP （Camera Ip ）和相机 对应的网卡 IP （Export Ip ）来连接相机，输入的 IP 地址格式应为 xx.xx.xx.xx 。

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (pUser, &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; }

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

MV_CC_DEVICE_INFO stDevInfo = {0}; 

MV_GIGE_DEVICE_INFO stGigEDev = {0}; 

// ch: 需要连接的相机 ip( 根据实际填充 ) | en:The camera IP that needs to be connected (based on actual padding) 

printf("Please input Current Camera Ip : "); 

char nCurrentIp[128]; 

scanf("%s", &nCurrentIp); 

// ch: 相机对应的网卡 ip( 根据实际填充 ) | en:The pc IP that needs to be connected (based on actual padding) 

printf("Please input Net Export Ip : "); 

char nNetExport[128]; 

scanf("%s", &nNetExport); 

unsigned int nIp1, nIp2, nIp3, nIp4, nIp; 

sscanf_s(nCurrentIp, "%d.%d.%d.%d", &nIp1, &nIp2, &nIp3, &nIp4); 

nIp = (nIp1 << 24) | (nIp2 << 16) | (nIp3 << 8) | nIp4; 

stGigEDev. nCurrentIp = nIp; 

sscanf_s(nNetExport, "%d.%d.%d.%d", &nIp1, &nIp2, &nIp3, &nIp4); 

nIp = (nIp1 << 24) | (nIp2 << 16) | (nIp3 << 8) | nIp4; 

stGigEDev. nNetExport = nIp; 

stDevInfo. nTLayerType = MV_GIGE_DEVICE ;// ch: 仅支持 GigE 相机 | en:Only support GigE camera 

stDevInfo. SpecialInfo .stGigEInfo = stGigEDev; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle nRet = MV_CC_CreateHandle (& handle , &stDevInfo); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet[0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDevInfo. nTLayerType == MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; }

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ConvertPixelType.cpp 

图像格式转换 

该示例程序通过图像转换接口将设备采集到的原始图像数据转换成所需的像素格式。 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) {

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

bool IsColor (MvGvspPixelType enType) 

{

switch(enType) 

{

case PixelType_Gvsp_BGR8_Packed :

case PixelType_Gvsp_YUV422_Packed :

case PixelType_Gvsp_YUV422_YUYV_Packed :

case PixelType_Gvsp_BayerGR8 :

case PixelType_Gvsp_BayerRG8 :

case PixelType_Gvsp_BayerGB8 :

case PixelType_Gvsp_BayerBG8 :

case PixelType_Gvsp_BayerGB10 :

case PixelType_Gvsp_BayerGB10_Packed :

case PixelType_Gvsp_BayerBG10 :

case PixelType_Gvsp_BayerBG10_Packed :

case PixelType_Gvsp_BayerRG10 :

case PixelType_Gvsp_BayerRG10_Packed :

case PixelType_Gvsp_BayerGR10 :

case PixelType_Gvsp_BayerGR10_Packed :

case PixelType_Gvsp_BayerGB12 :

case PixelType_Gvsp_BayerGB12_Packed :

case PixelType_Gvsp_BayerBG12 :

case PixelType_Gvsp_BayerBG12_Packed :

case PixelType_Gvsp_BayerRG12 :

case PixelType_Gvsp_BayerRG12_Packed :

case PixelType_Gvsp_BayerGR12 :case PixelType_Gvsp_BayerGR12_Packed :

case PixelType_Gvsp_BayerRBGG8 :

case PixelType_Gvsp_BayerGR16 :

case PixelType_Gvsp_BayerRG16 :

case PixelType_Gvsp_BayerGB16 :

case PixelType_Gvsp_BayerBG16 :

return true; 

default: 

return false; 

}

}

bool IsMono (MvGvspPixelType enType) 

{

switch(enType) 

{

case PixelType_Gvsp_Mono10 :

case PixelType_Gvsp_Mono10_Packed :

case PixelType_Gvsp_Mono12 :

case PixelType_Gvsp_Mono12_Packed :

case PixelType_Gvsp_Mono14 :

case PixelType_Gvsp_Mono16 :

return true; 

default: 

return false; 

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned char *pConvertData = NULL; 

unsigned int nConvertDataSize = 0; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_FRAME_OUT stImageInfo = {0}; 

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

MvGvspPixelType enDstPixelType = PixelType_Gvsp_Undefined ;unsigned int nChannelNum = 0; 

char chFileName[MAX_PATH] = {0}; 

// ch: 如果是彩色则转成 RGB8 | en:if pixel type is color, convert it to RGB8 

if (IsColor (stImageInfo. stFrameInfo .enPixelType )) 

{

nChannelNum = 3; 

enDstPixelType = PixelType_Gvsp_RGB8_Packed ;

sprintf(chFileName, "AfterConvertRGB.raw"); 

}

// ch: 如果是黑白则转换成 Mono8 | en:if pixel type is mono, convert it to mono8 

else if ( IsMono (stImageInfo. stFrameInfo .enPixelType )) 

{

nChannelNum = 1; 

enDstPixelType = PixelType_Gvsp_Mono8 ;

sprintf(chFileName, "AfterConvertMono8.raw"); 

}

else 

{

printf("Don't need to convert!\n"); 

}

if (enDstPixelType != PixelType_Gvsp_Undefined )

{

// ch: 设置插值算法为均衡 | en:set interpolation algorithm type, 0-Fast 1-Equilibrium 2-Optimal 3-Optimal plus 

nRet = MV_CC_SetBayerCvtQuality (handle , 1); 

if ( MV_OK != nRet) 

{

printf("set Bayer convert quality fail! nRet [0x%x]\n", nRet); 

break; 

}

pConvertData = (unsigned char*)malloc(stImageInfo. stFrameInfo .nWidth *stImageInfo. stFrameInfo .nHeight * nChannelNum); 

if (NULL == pConvertData) 

{

printf("malloc pConvertData fail!\n"); 

break; 

}

nConvertDataSize = stImageInfo. stFrameInfo .nWidth *stImageInfo. stFrameInfo .nHeight * nChannelNum; 

// ch: 像素格式转换 | en:Convert pixel format 

MV_CC_PIXEL_CONVERT_PARAM_EX stConvertParam = {0}; 

stConvertParam. nWidth = stImageInfo. stFrameInfo .nWidth ;//ch: 图像宽 | en:image width stConvertParam. nHeight =stImageInfo. stFrameInfo .nHeight ; //ch: 图像高 |en:image height 

stConvertParam. pSrcData = stImageInfo. pBufAddr ;//ch: 输入数据缓存 | en:input data buffer 

stConvertParam. nSrcDataLen =stImageInfo. stFrameInfo .nFrameLen ; //ch: 输入数据大小 |en:input data size 

stConvertParam. enSrcPixelType =stImageInfo. stFrameInfo .enPixelType ; //ch: 输入像素格式 |en:input pixel format 

stConvertParam. enDstPixelType = enDstPixelType; //ch: 输出像素格式 | en:output pixel format 

stConvertParam. pDstBuffer = pConvertData; //ch: 输出数据缓存 | en:output data buffer 

stConvertParam. nDstBufferSize = nConvertDataSize; //ch: 输出缓存大小 | en:output buffer size 

nRet = MV_CC_ConvertPixelTypeEx (handle ,&stConvertParam); 

if ( MV_OK != nRet) 

{

printf("Convert Pixel Type fail! nRet [0x%x]\n", nRet); 

break; 

}

FILE* fp = NULL; 

errno_t err = fopen_s(&fp, chFileName, "wb"); 

if (0 != err || NULL == fp) 

{

printf("Open file failed\n"); 

break; 

}

fwrite(stConvertParam. pDstBuffer , 1, stConvertParam. nDstLen , fp); 

fclose(fp); 

printf("Convert pixeltype succeed\n"); 

}

MV_CC_FreeImageBuffer (handle , &stImageInfo); 

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (pConvertData) 

{

free(pConvertData); 

pConvertData = NULL; 

}

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Events.cpp 

获取相机事件 

该示例程序说明如何配置相机事件功能、如何注册事件回调以及如何在事件回调函数中处理获取到 的事件信息。 Event 事件例如： ExposureEnd 。

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall EventCallBack (MV_EVENT_OUT_INFO * pEventInfo, void* pUser) 

{

if (pEventInfo) 

{

__int64 nBlockId = pEventInfo-> nBlockIdHigh ;

nBlockId = (nBlockId << 32) + pEventInfo-> nBlockIdLow ;

__int64 nTimestamp = pEventInfo-> nTimestampHigh ;

nTimestamp = (nTimestamp << 32) + pEventInfo-> nTimestampLow ;

printf("EventName[%s], EventID[%u], BlockId[%I64d], Timestamp[%I64d]\n", 

pEventInfo-> EventName , pEventInfo->nEventID ,nBlockId,nTimestamp); 

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开启 Event | en:Set Event of ExposureEnd On 

nRet = MV_CC_EventNotificationOn (handle , "ExposureEnd"); 

if ( MV_OK != nRet) 

{

printf("Set Event Notification On fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注册事件回调 | en:Register event callback 

nRet = MV_CC_RegisterEventCallBackEx (handle , "ExposureEnd", 

EventCallBack , handle ); 

if ( MV_OK != nRet) 

{

printf("Register Event CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) {

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Grab_ActionCommand.cpp 

PTP 时钟协议 

该示例程序说明如何通过 PTP 时钟协议对相机进行采图。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

unsigned int g_DeviceKey = 1; 

unsigned int g_GroupKey = 1; 

unsigned int g_GroupMask = 1; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall ActionCommandWorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_ACTION_CMD_INFO stActionCmdInfo = {0}; 

MV_ACTION_CMD_RESULT_LIST stActionCmdResults = {0}; 

stActionCmdInfo. nDeviceKey = g_DeviceKey ;

stActionCmdInfo. nGroupKey = g_GroupKey ;

stActionCmdInfo. nGroupMask = g_GroupMask ;

stActionCmdInfo. pBroadcastAddress = "255.255.255.255"; 

stActionCmdInfo. nTimeOut = 100; 

stActionCmdInfo. bActionTimeEnable = 0; 

while(! g_bExit )

{

//Send the PTP clock photo command 

nRet = 

MV_GIGE_IssueActionCommand (&stActionCmdInfo,&stActionCmdResults); if ( MV_OK != nRet) 

{

printf("Issue Action Command fail! nRet [0x%x]\n", nRet); 

continue; 

}

printf("NumResults = %d\r\n",stActionCmdResults. nNumResults ); 

MV_ACTION_CMD_RESULT * pResults = stActionCmdResults. pResults ;

for (unsigned int i = 0;i < stActionCmdResults. nNumResults ;i++) 

{

//Print the device infomation 

printf("Ip == %s, Status == 0x%x\r\n",pResults->strDeviceAddress ,pResults-> nStatus ); 

pResults++; 

}

}

return 0; 

}

static unsigned int __stdcall ReceiveImageWorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (pUser, &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 on | en:Set trigger mode as on 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 1); 

if ( MV_OK != nRet) {

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发源为 Action1 | en:Set trigger source as Action1 

nRet = MV_CC_SetEnumValueByString (handle , "TriggerSource", "Action1"); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Source fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置 Action Device Key | en:Set Action Device Key 

nRet = MV_CC_SetIntValueEx (handle , "ActionDeviceKey", 

g_DeviceKey ); 

if ( MV_OK != nRet) 

{

printf("Set Action Device Key fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置 Action Group Key | en:Set Action Group Key100 

nRet = MV_CC_SetIntValueEx (handle , "ActionGroupKey", 

g_GroupKey ); 

if ( MV_OK != nRet) 

{

printf("Set Action Group Key fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置 Action Group Mask | en:Set Action Group Mask 

nRet = MV_CC_SetIntValueEx (handle , "ActionGroupMask", 

g_GroupMask ); 

if ( MV_OK != nRet) 

{

printf("Set Action Group Mask fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nReceiveImageThreadID = 0; void* hReceiveImageThreadHandle = (void*) _beginthreadex( NULL , 0 , ReceiveImageWorkThread , handle , 0 , &nReceiveImageThreadID ); 

if (NULL == hReceiveImageThreadHandle) 

{

break; 

}

unsigned int nActionCommandThreadID = 0; 

void* hActionCommandThreadHandle = (void*) _beginthreadex( NULL , 0 , ActionCommandWorkThread , NULL, 0 , &nActionCommandThreadID ); 

if (NULL == hActionCommandThreadHandle) 

{

return 0; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Grab_Callback.cpp 

通过回调获取相机图像 

该示例程序说明如何通过回调的方式获取相机图像。创建句柄，打开相机，注册回调函数，开始取 流，在回调函数中可以获取到图像相关信息，停止取流，关闭相机，销毁句柄。 #include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

if (pstFrame) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

pstFrame-> stFrameInfo .nExtendWidth , pstFrame->stFrameInfo .nExtendHeight , pstFrame-> stFrameInfo .nFrameNum ); 

if (false == bAutoFree && NULL != pUser) // 非自动释放模式，需要手动释放资源 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; }

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}}

// ch: 设置触发模式为 off | eb:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 注销抓图回调 | en:Unregister image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , NULL, NULL, true); 

if ( MV_OK != nRet) 

{

printf("Unregister Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# GrabImage.cpp 

获取相机图像 

该示例程序说明如何通过主动取图的方式获取相机图像。创建句柄，打开相机，开始取流，创建取 流线程（用户分配采集 buffer ， MV_CC_GetOneFrameTimeout() 取图（拷贝）），停止取流，关 闭相机，销毁句柄。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stOutFrame = {0}; 

while(true) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stOutFrame, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stOutFrame. stFrameInfo .nWidth ,stOutFrame. stFrameInfo .nHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (pUser, &stOutFrame); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# GrabStrategies.cpp 

取图策略 

该示例程序说明如何使用不同的取图策略获取相机采集的图像。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall UpcomingThread (void* pUser) 

{

Sleep(3000);// 为了等 MV_CC_GetImageBuffer 调用后再发送软触发命令 

printf("Trigger Software Once for MV_GrabStrategy_UpcomingImage\n"); 

MV_CC_SetCommandValue (pUser, "TriggerSoftware"); 

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned char * pData = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList = {0}; 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) {

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

if( MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize) != 

MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置软触发模式 | en:Set Trigger Mode and Set Trigger Source 

nRet = MV_CC_SetEnumValueByString (handle , "TriggerMode", "On"); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

nRet = MV_CC_SetEnumValueByString (handle , "TriggerSource", "Software"); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Source fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nImageNodeNum = 5; // ch: 设置缓存节点个数 | en:Set number of image node 

nRet = MV_CC_SetImageNodeNum (handle , nImageNodeNum); 

if ( MV_OK != nRet) 

{

printf("Set number of image node fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("\n******************************************************* *******************\n"); 

printf("* 0.MV_GrabStrategy_OneByOne; 1.MV_GrabStrategy_LatestImagesOnly; *\n"); 

printf("* 2.MV_GrabStrategy_LatestImages; 3.MV_GrabStrategy_UpcomingImage; *\n"); 

printf("********************************************************* *****************\n"); 

printf("Please Input Grab Strategy:"); 

unsigned int nGrabStrategy = 0; 

scanf_s("%d", &nGrabStrategy); 

// ch:U3V 相机不支持 MV_GrabStrategy_UpcomingImage | en:U3V device not support UpcomingImage 

if (nGrabStrategy == MV_GrabStrategy_UpcomingImage && 

MV_USB_DEVICE == stDeviceList. pDeviceInfo [nIndex]-> nTLayerType )

{

printf("U3V device not support UpcomingImage\n"); 

break; 

}

switch(nGrabStrategy) 

{

case MV_GrabStrategy_OneByOne :

{

printf("Grab using the MV_GrabStrategy_OneByOne default strategy\n"); 

nRet = MV_CC_SetGrabStrategy (handle ,

MV_GrabStrategy_OneByOne ); 

if ( MV_OK != nRet) 

{

printf("Set Grab Strategy fail! nRet [0x%x]\n", nRet); 

break; 

}

}

break; 

case MV_GrabStrategy_LatestImagesOnly :

{

printf("Grab using strategy MV_GrabStrategy_LatestImagesOnly\n"); nRet = MV_CC_SetGrabStrategy (handle ,

MV_GrabStrategy_LatestImagesOnly ); 

if ( MV_OK != nRet) 

{

printf("Set Grab Strategy fail! nRet [0x%x]\n", nRet); 

break; 

}

}

break; 

case MV_GrabStrategy_LatestImages :

{

printf("Grab using strategy MV_GrabStrategy_LatestImages\n"); 

nRet = MV_CC_SetGrabStrategy (handle ,

MV_GrabStrategy_LatestImages ); 

if ( MV_OK != nRet) 

{

printf("Set Grab Strategy fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置输出缓存个数 | en:Set Output Queue Size 

nRet = MV_CC_SetOutputQueueSize (handle , 2); 

if ( MV_OK != nRet) 

{

printf("Set Output Queue Size fail! nRet [0x%x]\n", nRet); 

break; 

}

}

break; 

case MV_GrabStrategy_UpcomingImage :

{

printf("Grab using strategy MV_GrabStrategy_UpcomingImage\n"); 

nRet = MV_CC_SetGrabStrategy (handle ,

MV_GrabStrategy_UpcomingImage ); 

if ( MV_OK != nRet) 

{

printf("Set Grab Strategy fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

UpcomingThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

}

break; default: 

printf("Input error!Use default strategy:MV_GrabStrategy_OneByOne\n"); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 发送软触发命令 | en:Send Trigger Software command 

for (unsigned int i = 0;i < nImageNodeNum;i++) 

{

nRet = MV_CC_SetCommandValue (handle , "TriggerSoftware"); 

if (MV_OK != nRet) 

{

printf("Send Trigger Software command fail! nRet [0x%x]\n", nRet); 

break; 

}

Sleep(500);// 如果帧率过小或 TriggerDelay 很大，可能会出现软触发命令没 有全部起效而导致取不到数据的情况 

}

MV_FRAME_OUT stOutFrame = {0}; 

if (nGrabStrategy != MV_GrabStrategy_UpcomingImage )

{

while(true) 

{

nRet = MV_CC_GetImageBuffer (handle , &stOutFrame, 0);// 超时时间设置成 0，因为缓存列表中已经有数据存在 

if (nRet == MV_OK )

{

printf("Get One Frame: Width[%d], Height[%d], FrameNum[%d]\n", 

stOutFrame. stFrameInfo .nWidth ,stOutFrame. stFrameInfo .nHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

break; 

}

nRet = MV_CC_FreeImageBuffer (handle , &stOutFrame); 

if(nRet != MV_OK )

{printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

}

else// 仅用于 upcoming 

{

nRet = MV_CC_GetImageBuffer (handle , &stOutFrame, 5000);// 需要 比较大的超时时间来获取即将到达的这帧数据 

if (nRet == MV_OK )

{

printf("Get One Frame: Width[%d], Height[%d], FrameNum[%d]\n", 

stOutFrame. stFrameInfo .nWidth ,stOutFrame. stFrameInfo .nHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

nRet = MV_CC_FreeImageBuffer (handle , &stOutFrame); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; }

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# HighBandwidthDecode.cpp 

高清无损压缩 该示例程序演示通过高清无损压缩算法将从相机取到的无损压缩码流解码成裸数据。 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

#define IMAGE_NAME_LEN 256 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE ){

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned char * pDstBuf = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) {

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) {

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 获取数据包大小 | en:Get payload size 

MVCC_INTVALUE stParam; 

memset(&stParam, 0, sizeof( MVCC_INTVALUE )); 

nRet = MV_CC_GetIntValue (handle , "PayloadSize", &stParam); 

if ( MV_OK != nRet) 

{

printf("Get PayloadSize fail! nRet [0x%x]\n", nRet); 

break; }

unsigned int nPayloadSize = stParam. nCurValue ;

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_FRAME_OUT stImageInfo = {0}; 

unsigned int nImageNum = 10; 

char chImageName[ IMAGE_NAME_LEN ] = {0}; 

MV_CC_HB_DECODE_PARAM stDecodeParam = {0}; 

for(unsigned int i = 0;i < nImageNum; i++) 

{

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get One Frame: Width[%d], Height[%d], FrameNum[%d] ，PixelFormat[0x%x]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ,stImageInfo. stFrameInfo .enPixelType ); 

//ch: 无损压缩解码 | en:Lossless compression decoding 

stDecodeParam. pSrcBuf = stImageInfo. pBufAddr ;

stDecodeParam. nSrcLen =stImageInfo. stFrameInfo .nFrameLenEx ;

if (pDstBuf == NULL) 

{

pDstBuf = (unsigned char *)malloc(sizeof(unsigned char) * (nPayloadSize)); 

if (NULL == pDstBuf) 

{

printf("malloc pDstData fail !\n"); 

nRet = MV_E_RESOURCE ;

break; 

}

}

stDecodeParam. pDstBuf = pDstBuf; 

stDecodeParam. nDstBufSize = nPayloadSize; 

nRet = MV_CC_HB_Decode (handle , &stDecodeParam); 

if (nRet != MV_OK )

{

printf("Decode fail![0x%x]\n", nRet); 

break; }

MV_CC_FreeImageBuffer (handle , &stImageInfo); 

// ch: 解码后的图保存至本地 | en:Save decode image 

MV_CC_IMAGE stImg; 

MV_CC_SAVE_IMAGE_PARAM stSaveParams; 

memset(&stSaveParams, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

memset(&stImg, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

stImg. enPixelType = stDecodeParam. enDstPixelType ;

stImg. nHeight = stDecodeParam. nHeight ;

stImg. nWidth = stDecodeParam. nWidth ;

stImg.nImageBufLen = stDecodeParam. nDstBufLen ;

stImg. pImageBuf = stDecodeParam. pDstBuf ;

stSaveParams. enImageType = MV_Image_Bmp ;

stSaveParams. iMethodValue = 1; 

sprintf_s(chImageName, IMAGE_NAME_LEN ,"Image_w%d_h%d_fn%03d.bmp", stDecodeParam. nWidth ,stDecodeParam. nHeight , stImageInfo. stFrameInfo .nFrameNum ); 

nRet = MV_CC_SaveImageToFileEx2 (handle , &stImg, &stSaveParams, chImageName); 

if (nRet!= MV_OK )

{

printf("Save image fail! nRet [0x%x]\n", nRet); 

}

printf("Decode succeed\n"); 

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if(pDstBuf) 

{

free(pDstBuf); 

pDstBuf = NULL; 

}

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ImageContrast.cpp 

图像对比度调节 

该示例程序说明如何采集图像并调节采集图像的对比度。 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); // ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}return true; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

unsigned char * pDstData = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

MV_FRAME_OUT stImageInfo = {0}; 

nRet = MV_CC_GetImageBuffer (handle , &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

pDstData = (unsigned char *)malloc(sizeof(unsigned char) * (stImageInfo. stFrameInfo .nFrameLen )); 

if (pDstData == NULL) 

{

printf("malloc pData fail !\n"); 

break; 

}

MV_CC_CONTRAST_PARAM stContrastParam = {0}; 

stContrastParam. nWidth = stImageInfo. stFrameInfo .nWidth ;

stContrastParam. nHeight = stImageInfo. stFrameInfo .nHeight ;

stContrastParam. enPixelType =stImageInfo. stFrameInfo .enPixelType ;

stContrastParam. pSrcBuf = stImageInfo. pBufAddr ;

stContrastParam. nSrcBufLen =stImageInfo. stFrameInfo .nFrameLen ;

stContrastParam. pDstBuf = pDstData; 

stContrastParam. nDstBufSize =stImageInfo. stFrameInfo .nFrameLen ;

stContrastParam. nContrastFactor = 1000; 

nRet = MV_CC_ImageContrast (handle , &stContrastParam); if (MV_OK != nRet) 

{

printf("Adjust image contrast fail! nRet [0x%x]\n", nRet); 

break; 

}

FILE* fp = NULL; 

errno_t err = fopen_s(&fp, "BeforeContrast.raw", "wb"); 

if (0 != err || NULL == fp) 

{

printf("Open file failed\n"); 

break; 

}

fwrite(stImageInfo. pBufAddr , 1, stImageInfo. stFrameInfo .nFrameLen , fp); 

fclose(fp); 

fp = NULL; 

MV_CC_FreeImageBuffer (handle , &stImageInfo); 

err = fopen_s(&fp, "AfterContrast.raw", "wb"); 

if (0 != err || NULL == fp) 

{

printf("Open file failed\n"); 

break; 

}

fwrite(pDstData, 1, stImageInfo. stFrameInfo .nFrameLen , fp); 

fclose(fp); 

printf("Image contrast succeed\n"); 

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (pDstData) 

{

free(pDstData); 

pDstData = NULL; 

}

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

# LensShadingCorrection.cpp 

LSC 

该示例程序说明如何进行 LSC 标定和校正。需要先通过 LSC 标定功能获取到标定表，然后才能对相 机图像进行 LSC 校正处理。 

#include <stdio.h> 

#include <Windows.h> 

#include <conio.h> 

#include <io.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}unsigned char * g_pDstData = NULL; 

unsigned int g_nDstDataSize = 0; 

unsigned char * g_pCalibBuf = NULL; 

unsigned int g_nCalibBufSize = 0; 

bool g_IsNeedCalib = true; 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT * pstFrame, void *pUser, bool bAutoFree) 

{

printf("Get One Frame: Width[%d], Height[%d], nFrameNum[%d]\n", pstFrame-> stFrameInfo .nWidth , pstFrame-> stFrameInfo .nHeight ,pstFrame-> stFrameInfo .nFrameNum ); 

int nRet = MV_OK ;

do 

{

// 判断是否需要标定 

if (true == g_IsNeedCalib )

{

// LSC 标定 

MV_CC_LSC_CALIB_PARAM stLSCCalib = { 0 }; 

stLSCCalib. nWidth = pstFrame-> stFrameInfo .nWidth ;

stLSCCalib. nHeight = pstFrame-> stFrameInfo .nHeight ;

stLSCCalib. enPixelType = pstFrame-> stFrameInfo .enPixelType ;

stLSCCalib. pSrcBuf = pstFrame-> pBufAddr ;

stLSCCalib. nSrcBufLen = pstFrame-> stFrameInfo .nFrameLenEx ;

if (g_pCalibBuf == NULL || g_nCalibBufSize < (pstFrame->stFrameInfo .nWidth * pstFrame->stFrameInfo .nHeight *sizeof(unsigned short))) 

{

if ( g_pCalibBuf )

{

free( g_pCalibBuf ); 

g_pCalibBuf = NULL; 

g_nCalibBufSize = 0; 

}

g_pCalibBuf = (unsigned char *)malloc(pstFrame->stFrameInfo .nWidth *pstFrame-> stFrameInfo .nHeight *sizeof(unsigned short)); 

if ( g_pCalibBuf == NULL) 

{

printf("malloc pCalibBuf fail !\n"); 

break; 

}g_nCalibBufSize = pstFrame-> stFrameInfo .nWidth *pstFrame-> stFrameInfo .nHeight * sizeof(unsigned short); 

}

stLSCCalib. pCalibBuf = g_pCalibBuf ;

stLSCCalib. nCalibBufSize = g_nCalibBufSize ;

stLSCCalib. nSecNumW = 689; 

stLSCCalib. nSecNumH = 249; 

stLSCCalib. nPadCoef = 2; 

stLSCCalib. nCalibMethod = 2; 

stLSCCalib. nTargetGray = 100; 

// 同一个相机，在场景、算法参数和图像参数都不变情况下，理论上只需要进行一 次标定，可将标定表保存下来。 

// 不同相机图片标定出来的标定表不可复用，当场景改变或算法参数改变或图像参 数改变时，需要重新标定。 

nRet = MV_CC_LSCCalib (pUser, &stLSCCalib); 

if (MV_OK != nRet) 

{

printf("LSC Calib fail! nRet [0x%x]\n", nRet); 

break; 

}

// 保存标定表到本地 

FILE* fp_out = fopen("./LSCCalib.bin", "wb"); 

if (NULL == fp_out) 

{

printf("open LSCCalib.bin fail! \n"); 

break; 

}

fwrite(stLSCCalib. pCalibBuf , 1, stLSCCalib. nCalibBufLen ,fp_out); 

fclose(fp_out); 

fp_out = NULL; 

g_IsNeedCalib = false; 

}

// LSC 校正 

if ( g_pDstData == NULL || g_nDstDataSize < pstFrame->stFrameInfo.nFrameLenEx) 

{

if (g_pDstData )

{

free( g_pDstData ); 

g_pDstData = NULL; 

g_nDstDataSize = 0; 

}g_pDstData = (unsigned char *)malloc(pstFrame->stFrameInfo .nFrameLenEx ); 

if (g_pDstData == NULL) 

{

printf("malloc pDstData fail !\n"); 

break; 

}

g_nDstDataSize = pstFrame-> stFrameInfo .nFrameLenEx ;

}

MV_CC_LSC_CORRECT_PARAM stLSCCorrectParam = { 0 }; 

stLSCCorrectParam. nWidth = pstFrame-> stFrameInfo .nWidth ;

stLSCCorrectParam. nHeight = pstFrame-> stFrameInfo .nHeight ;

stLSCCorrectParam. enPixelType = pstFrame->stFrameInfo .enPixelType ;

stLSCCorrectParam. pSrcBuf = pstFrame-> pBufAddr ;

stLSCCorrectParam. nSrcBufLen = pstFrame->stFrameInfo .nFrameLenEx ;

stLSCCorrectParam. pDstBuf = g_pDstData ;

stLSCCorrectParam. nDstBufSize = g_nDstDataSize ;

stLSCCorrectParam. pCalibBuf = g_pCalibBuf ;

stLSCCorrectParam. nCalibBufLen = g_nCalibBufSize ;

nRet = MV_CC_LSCCorrect (pUser, &stLSCCorrectParam); 

if ( MV_OK != nRet) 

{

printf("LSC Correct fail! nRet [0x%x]\n", nRet); 

break; 

}

if (pstFrame-> stFrameInfo .nFrameNum < 10) 

{

// 保存图像到文件 

MV_CC_IMAGE stImage; 

memset(&stImage, 0, sizeof( MV_CC_IMAGE )); 

MV_CC_SAVE_IMAGE_PARAM stSaveImageParam; 

memset(&stSaveImageParam, 0, sizeof( MV_CC_SAVE_IMAGE_PARAM )); 

stImage. nWidth = pstFrame-> stFrameInfo .nWidth ;

stImage. nHeight = pstFrame-> stFrameInfo .nHeight ;

stImage. enPixelType = pstFrame-> stFrameInfo .enPixelType ;

stImage. pImageBuf = pstFrame-> pBufAddr ;

stImage. nImageLen = pstFrame-> stFrameInfo .nFrameLenEx ;

stSaveImageParam. enImageType = MV_Image_Bmp ;

stSaveImageParam. iMethodValue = 1; stSaveImageParam. nQuality = 99; 

char chImagePath[256] = { 0 }; 

sprintf_s(chImagePath, 256, "Before Image_w%d_h%d_fn%03d.bmp", stImage. nWidth , stImage. nHeight ,stImage. nImageLen ); 

nRet = MV_CC_SaveImageToFileEx2 (pUser, &stImage, &stSaveImageParam, chImagePath); 

if (MV_OK != nRet) 

{

printf("SaveImageToFile failed[%x]!\n", nRet); 

break; 

}

stImage. pImageBuf = g_pDstData ;

sprintf_s(chImagePath, 256, "After Image_w%d_h%d_fn%03d.bmp", stImage. nWidth , stImage. nHeight ,pstFrame-> stFrameInfo .nFrameNum ); 

nRet = MV_CC_SaveImageToFileEx2 (pUser, &stImage, &stSaveImageParam, chImagePath); 

if (MV_OK != nRet) 

{

printf("SaveImageToFile failed[%x]!\n", nRet); 

break; 

}

}

} while (0); 

if (false == bAutoFree && 

NULL != pUser) // 手动释放 

{

MV_CC_FreeImageBuffer (pUser, pstFrame); 

}

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}

}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | eb:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// 判断是否可以本地导入 

FILE* fp = fopen("./LSCCalib.bin", "rb"); 

if (fp) 

{

int nFileLen = filelength(fileno(fp)); 

if (g_pCalibBuf == NULL || g_nCalibBufSize < nFileLen) 

{

if ( g_pCalibBuf ){

free( g_pCalibBuf ); 

g_pCalibBuf = NULL; 

g_nCalibBufSize = 0; 

}

g_pCalibBuf = (unsigned char *)malloc(nFileLen); 

if ( g_pCalibBuf == NULL) 

{

printf("malloc pCalibBuf fail !\n"); 

break; 

}

g_nCalibBufSize = nFileLen; 

}

fread( g_pCalibBuf , 1, g_nCalibBufSize , fp); 

fclose(fp); 

g_IsNeedCalib = false; 

}

// ch: 注册抓图回调 | en:Register image callback 

nRet = MV_CC_RegisterImageCallBackEx2 (handle , ImageCallbackEx2 ,

handle , true); 

if ( MV_OK != nRet) 

{

printf("Register Image CallBack fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}// ch: 关闭设备 | en:Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Close Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | en:Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (g_pCalibBuf )

{

free( g_pCalibBuf ); 

g_pCalibBuf = NULL; 

g_nCalibBufSize = 0; 

}

if (g_pDstData )

{

free( g_pDstData ); 

g_pDstData = NULL; 

g_nDstDataSize = 0; 

}

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; }

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ParametrizeCamera_FileAccess.cpp 

导入或导出文件到相机 

该示例程序说明如何导入文件到相机以及如何导出相机文件。演示了通过 

MV_CC_FileAccessRead() 从设备读取文件（例如 UserSet1.bin ）；通过 

MV_CC_FileAccessWrite() 将文件（例如 UserSet1.bin ）写入相机；以及通过 

MV_CC_GetFileAccessProgress() 获取文件的存取进度。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); }

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE ,&stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Open Device success.\n"); 

printf("\n"); 

printf("0: Read the file from the device and save it locally:\n"); //0: 从设备读取文件并保存到本地 

printf("1: Import the local file into the device:\n"); //1: 将本地文件导入到设备中 

printf("Please enter your choice:\n"); 

unsigned int nOperationIndex = 0; 

scanf_s("%d", &nOperationIndex); 

if (0 != nOperationIndex && 1 != nOperationIndex) 

{

printf("Input error!\n"); 

break; 

}

if (0 == nOperationIndex) 

{

// 从设备读取文件并保存到本地 

//ch:1. 设备切换 UserSet1 参数组 | en:1. Device switches to UserSet1 parameter set 

nRet = MV_CC_SetEnumValueByString (handle , "UserSetSelector", "UserSet1"); 

if (MV_OK != nRet) 

{

printf("Set UserSetSelector UserSet1 fail! nRet [0x%x]\n", nRet); 

break; 

}//ch:2. 相机加载当前组的参数 | en: 2. Camera loads parameters of the current group 

nRet = MV_CC_SetCommandValue (handle , "UserSetLoad"); 

if (MV_OK != nRet) 

{

printf("Set command UserSetLoad fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch:3. 从相机读取 "UserSet1" 信息并保存到本地 "UserSet1.bin" 文件中 ; ( 设备支持 "UserSet1" "UserSet2" "UserSet3" 可选） 

//en:3. Read the 'UserSet1' information from the camera and save it to the local 'UserSet1.bin' file. (The device supports 'UserSet1', 'UserSet2', and 'UserSet3' (optional).) 

MV_CC_FILE_ACCESS stFileAccess = { 0 }; 

stFileAccess. pUserFileName = "UserSet1.bin"; 

stFileAccess. pDevFileName = "UserSet1"; 

nRet = MV_CC_FileAccessRead (handle , &stFileAccess); // 此接口 是阻塞的，读取完成后返回， 接口耗时可能略长 ; ( 优化方式 1. 可以开启单独线程进行 文件写入 ; 优化方式 2. 可以开启单独线程使用 MV_CC_GetFileAccessProgress 实时获取写入进度） 

if (MV_OK != nRet) 

{

printf("File Access Read fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("File Access Read Success.\n"); 

}

else 

{

// 将本地文件导入到设备中 

//ch:1. 切换当前设备参数组为 UserSet1 | en: 1. Switch the current device parameter set to UserSet1 

nRet = MV_CC_SetEnumValueByString (handle , "UserSetSelector", "UserSet1"); 

if (MV_OK != nRet) 

{

printf("Set UserSetSelector UserSet1 fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch:2. 将本地文件 "UserSet1.bin" 导入到设备 "UserSet1" 中 |en: 2. Import the local file 'UserSet1.bin' into the device 'UserSet1'. 

MV_CC_FILE_ACCESS stFileAccess = { 0 }; 

stFileAccess. pUserFileName = "UserSet1.bin"; stFileAccess. pDevFileName = "UserSet1"; 

nRet = MV_CC_FileAccessWrite (handle , &stFileAccess); // 

此接口是阻塞的，写入完成后返回， 接口耗时可能略长 ; （优化方式 1. 可以开启单独线 程进行文件写入 ; 优化方式 2. 可以开启单独线程使用 

MV_CC_GetFileAccessProgress 实时获取写入进度） 

if (MV_OK != nRet) 

{

printf("File Access Write fail! nRet [0x%x]\n", nRet); 

}

printf("File Access Write Success.\n"); 

//ch:3. 相机加载当前组写入配置 | en: 3. Camera loads parameters of the current set 

nRet = MV_CC_SetCommandValue (handle , "UserSetLoad"); 

if (MV_OK != nRet) 

{

printf("Set command UserSetLoad fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch:4. 配置相机默认 以 UserSet1 参数组 启动 | en: 4. Configure the camera to start with the UserSet1 parameter set by default. 

nRet = MV_CC_SetEnumValueByString (handle , "UserSetDefault", "UserSet1"); 

if (MV_OK != nRet) 

{

printf("Set UserSetDefault UserSet1 fail! nRet [0x%x]\n", nRet); 

break; 

}

//ch:5. 保存配置 | en: 5. Save Configuration 

nRet = MV_CC_SetCommandValue (handle , "UserSetSave"); 

if (MV_OK != nRet) 

{

printf("Set command UserSetSave fail! nRet [0x%x]\n", nRet); 

break; 

}

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Clos Device success.\n"); // ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ParametrizeCamera_LoadAndSave.cpp 导入或导出相机属性 

该示例程序说明如何导入和导出相机的属性树文件。演示了通过 MV_CC_FeatureSave() 将相机属 性导出到文件（例如 FeatureFile.ini ）中；通过 MV_CC_FeatureLoad() 从文件（例如 

FeatureFile.ini ）中导入相机的属性树。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE ,&stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Start export the camera properties to the file\n"); 

printf("Wait......\n"); 

// ch: 将相机属性导出到文件中 | en:Export the camera properties to the file 

nRet = MV_CC_FeatureSave (handle , "FeatureFile.mfs"); 

if ( MV_OK != nRet) 

{

printf("Save Feature fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Finish export the camera properties to the file\n\n"); 

printf("Start import the camera properties from the file\n"); printf("Wait......\n"); 

// ch: 从文件中导入相机属性 | en:Import the camera properties from the file 

nRet = MV_CC_FeatureLoad (handle , "FeatureFile.mfs"); 

if ( MV_OK != nRet) 

{

printf("Load Feature fail! nRet [0x%x]\n", nRet); 

break; 

}

printf("Finish import the camera properties from the file\n"); 

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# Recording.cpp 

视频录像存储 

该示例程序演示如何将相机拍摄到的画面存储为视频录像。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "MvCameraControl.h" 

bool g_bExit = false; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) 

{

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall WorkThread (void* pUser) 

{

int nRet = MV_OK ;

MV_FRAME_OUT stImageInfo = {0}; 

MV_CC_INPUT_FRAME_INFO stInputFrameInfo = {0}; 

while(1) 

{

nRet = MV_CC_GetImageBuffer (pUser, &stImageInfo, 1000); 

if (nRet == MV_OK )

{

printf("Get Image Buffer: Width[%d], Height[%d], FrameNum[%d]\n", 

stImageInfo. stFrameInfo .nWidth ,stImageInfo. stFrameInfo .nHeight ,stImageInfo. stFrameInfo .nFrameNum ); 

stInputFrameInfo. pData = stImageInfo. pBufAddr ;

stInputFrameInfo. nDataLen =stImageInfo. stFrameInfo .nFrameLen ;

nRet = MV_CC_InputOneFrame (pUser, &stInputFrameInfo); 

if (MV_OK != nRet) 

{

printf("Input one frame fail! nRet [0x%x]\n", nRet); 

}

nRet = MV_CC_FreeImageBuffer (pUser, &stImageInfo); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

nRet = MV_CC_Initialize (); 

if ( MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); 

nRet = MV_CC_EnumDevices (MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if ( MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ; i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); }

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

nRet = MV_CC_CreateHandle (& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if ( MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 打开设备 | en:Open device 

nRet = MV_CC_OpenDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 探测网络最佳包大小 (只对 GigE 相机有效 ) | en:Detection network optimal package size(It only works for the GigE camera) 

if (stDeviceList. pDeviceInfo [nIndex]-> nTLayerType == 

MV_GIGE_DEVICE )

{

int nPacketSize = MV_CC_GetOptimalPacketSize (handle ); 

if (nPacketSize > 0) 

{

nRet = 

MV_CC_SetIntValueEx (handle ,"GevSCPSPacketSize",nPacketSize); 

if(nRet != MV_OK )

{

printf("Warning: Set Packet Size fail nRet [0x%x]!", nRet); 

}}

else 

{

printf("Warning: Get Packet Size fail nRet [0x%x]!", nPacketSize); 

}

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

nRet = MV_CC_SetEnumValue (handle , "TriggerMode", 0); 

if ( MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置 HB 模式为 off | en:Set HB mode as off 

nRet = MV_CC_SetEnumValue (handle ,"ImageCompressionMode", 0); 

if ( MV_OK != nRet) 

{

printf("Get ImageCompressionMode fail! nRet [0x%x]\n", nRet); 

}

MV_CC_RECORD_PARAM stRecordPar; 

MVCC_INTVALUE stParam = {0}; 

nRet = MV_CC_GetIntValue (handle , "Width", &stParam); 

if ( MV_OK != nRet) 

{

printf("Get Width fail! nRet [0x%x]\n", nRet); 

break; 

}

stRecordPar. nWidth = stParam. nCurValue ;

nRet = MV_CC_GetIntValue (handle , "Height", &stParam); 

if ( MV_OK != nRet) 

{

printf("Get Height fail! nRet [0x%x]\n", nRet); 

break; 

}

stRecordPar. nHeight = stParam. nCurValue ;

MVCC_ENUMVALUE stEnumValue = {0}; 

nRet = MV_CC_GetEnumValue (handle , "PixelFormat", &stEnumValue); 

if ( MV_OK != nRet) 

{

printf("Get Width fail! nRet [0x%x]\n", nRet); 

break; 

}stRecordPar. enPixelType =

MvGvspPixelType (stEnumValue. nCurValue ); 

MVCC_FLOATVALUE stFloatValue; 

nRet = MV_CC_GetFloatValue (handle , "ResultingFrameRate", &stFloatValue); 

if ( MV_OK != nRet) 

{

printf("Get Float value fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 帧率 (大于 1/16)fps | en:Frame Rate (>1/16)fps 

stRecordPar. fFrameRate = stFloatValue. fCurValue ;

// ch: 码率 kbps(128kbps-16Mbps) | en:Bitrate kbps(128kbps-16Mbps) 

stRecordPar. nBitRate = 1000; 

// ch: 录像格式 (仅支持 AVI) | en:Record Format(AVI is only supported) 

stRecordPar. enRecordFmtType = MV_FormatType_AVI ;

stRecordPar. strFilePath = "./Recording.avi"; 

nRet = MV_CC_StartRecord (handle ,&stRecordPar); 

if ( MV_OK != nRet) 

{

printf("Start Record fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

nRet = MV_CC_StartGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , handle , 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

printf("Start work thread fail! \n"); 

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; 

Sleep(1000); 

// ch: 停止取流 | en:Stop grab image nRet = MV_CC_StopGrabbing (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

nRet = MV_CC_StopRecord (handle ); 

if ( MV_OK != nRet) 

{

printf("Stop record fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

nRet = MV_CC_CloseDevice (handle ); 

if ( MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

nRet = MV_CC_DestroyHandle (handle ); 

if ( MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if (handle != NULL) 

{

MV_CC_DestroyHandle (handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

MV_CC_Finalize (); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return 0; 

}首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# DynamicallyLoadDLL.cpp 

动态调用 

该示例程序说明如何动态调用相机进行取图。 

#include <stdio.h> 

#include <Windows.h> 

#include <process.h> 

#include <conio.h> 

#include "CameraParams.h" 

#include "ObsoleteCamParams.h" 

#include "MvErrorDefine.h" 

typedef int (__stdcall * DLL_Initialize ) (); 

typedef int (__stdcall * DLL_Finalize ) (); 

typedef unsigned int (__stdcall * DLL_GetSDKVersion ) (); 

typedef int (__stdcall * DLL_EnumerateTls ) (); 

typedef int (__stdcall * DLL_EnumDevices ) (IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST *pstDevList); 

typedef int (__stdcall * DLL_EnumDevicesEx ) (IN unsigned int nTLayerType, IN OUT MV_CC_DEVICE_INFO_LIST *pstDevList, IN const char* pManufacturerName); 

typedef bool (__stdcall * DLL_IsDeviceAccessible ) (IN 

MV_CC_DEVICE_INFO * pstDevInfo, IN unsigned int nAccessMode); 

typedef int (__stdcall * DLL_CreateHandle ) (OUT void ** handle , IN const MV_CC_DEVICE_INFO * pstDevInfo); typedef int (__stdcall * DLL_CreateHandleWithoutLog )(OUT void ** handle , IN const MV_CC_DEVICE_INFO * pstDevInfo); 

typedef int (__stdcall * DLL_DestroyHandle ) (IN void * handle ); 

typedef int (__stdcall * DLL_OpenDevice ) (IN void* handle , IN unsigned int nAccessMode, IN unsigned short nSwitchoverKey); 

typedef int (__stdcall * DLL_CloseDevice ) (IN void* handle ); 

typedef int (__stdcall * DLL_RegisterImageCallBackEx )(void* 

handle , void(__stdcall* cbOutput)(unsigned char * pData, 

MV_FRAME_OUT_INFO_EX * pFrameInfo, void* pUser),void* pUser); 

typedef int (__stdcall *

DLL_RegisterImageCallBackForRGB )(void* handle , void(__stdcall* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void* pUser), void* pUser); 

typedef int (__stdcall *

DLL_RegisterImageCallBackForBGR )(void* handle , void(__stdcall* cbOutput)(unsigned char * pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void* pUser), void* pUser); 

typedef int (__stdcall * DLL_StartGrabbing ) (IN void* handle ); 

typedef int (__stdcall * DLL_StopGrabbing ) (IN void* handle ); 

typedef int (__stdcall * DLL_GetImageForRGB ) (IN void* handle , IN OUT unsigned char * pData , IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX * pFrameInfo, int nMsec); 

typedef int (__stdcall * DLL_GetImageForBGR ) (IN void* handle , IN OUT unsigned char * pData , IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX * pFrameInfo, int nMsec); 

typedef int (__stdcall * DLL_GetImageBuffer ) (IN void* handle , MV_FRAME_OUT * pFrameInfo, int nMsec); 

typedef int (__stdcall * DLL_FreeImageBuffer ) (IN void* handle , MV_FRAME_OUT * pFrameInfo); 

typedef int (__stdcall * DLL_GetOneFrameTimeout ) (IN void* handle , IN OUT unsigned char * pData , IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX * pFrameInfo, int nMsec); 

typedef int (__stdcall * DLL_Display ) (IN void* handle , void* hWnd); 

typedef int (__stdcall * DLL_DisplayOneFrame ) (IN void* handle , IN MV_DISPLAY_FRAME_INFO * pDisplayInfo); 

typedef int (__stdcall * DLL_SetImageNodeNum ) (IN void* handle , unsigned int nNum); 

typedef int (__stdcall * DLL_GetDeviceInfo ) (IN void * handle , IN OUT MV_CC_DEVICE_INFO * pstDevInfo); 

typedef int (__stdcall * DLL_GetAllMatchInfo ) (IN void* handle , IN OUT MV_ALL_MATCH_INFO * pstInfo); 

typedef int (__stdcall * DLL_GetIntValueEx ) (IN void* handle ,IN const char* strKey,OUT MVCC_INTVALUE_EX 

*pIntValue); 

typedef int (__stdcall * DLL_SetIntValueEx ) (IN void* handle ,IN const char* strKey,IN int64_t nValue); 

typedef int (__stdcall * DLL_GetEnumValue ) (IN void* handle ,IN const char* strValue,OUT MVCC_ENUMVALUE 

*pEnumValue); typedef int (__stdcall * DLL_SetEnumValue ) (IN void* handle ,IN const char* strValue,IN unsigned int nValue); 

typedef int (__stdcall * DLL_SetEnumValueByString ) (IN void* handle ,IN const char* strValue,IN const char* sValue); 

typedef int (__stdcall * DLL_GetFloatValue ) (IN void* handle ,IN const char* strValue,OUT MVCC_FLOATVALUE 

*pFloatValue); 

typedef int (__stdcall * DLL_SetFloatValue ) (IN void* handle ,IN const char* strValue,IN float fValue); 

typedef int (__stdcall * DLL_GetBoolValue ) (IN void* handle ,IN const char* strValue,OUT bool *pBoolValue); 

typedef int (__stdcall * DLL_SetBoolValue ) (IN void* handle ,IN const char* strValue,IN bool bValue); 

typedef int (__stdcall * DLL_GetStringValue ) (IN void* handle ,IN const char* strKey,OUT MVCC_STRINGVALUE 

*pStringValue); 

typedef int (__stdcall * DLL_SetStringValue ) (IN void* handle ,IN const char* strKey,IN const char * sValue); 

typedef int (__stdcall * DLL_SetCommandValue ) (IN void* handle ,IN const char* strValue); 

typedef int (__stdcall * DLL_LocalUpgrade ) (IN void* handle , const void *pFilePathName); 

typedef int (__stdcall * DLL_GetUpgradeProcess ) (IN void* handle , unsigned int* pnProcess); 

typedef int (__stdcall * DLL_GetOptimalPacketSize ) (IN void* handle ); 

typedef int (__stdcall * DLL_ReadMemory ) (IN void* handle , void *pBuffer, int64_t nAddress, int64_t nLength); 

typedef int (__stdcall * DLL_WriteMemory ) (IN void* handle , const void *pBuffer, int64_t nAddress, int64_t nLength); 

typedef int (__stdcall * DLL_RegisterExceptionCallBack )(IN void* handle , void(__stdcall* cbException)(unsigned int nMsgType, void* pUser), void* pUser); 

typedef int (__stdcall * DLL_RegisterEventCallBackEx )(void* 

handle , const char* pEventName, void(__stdcall* cbEvent)( MV_EVENT_OUT_INFO * pEventInfo, void* pUser),void* pUser); 

typedef int (__stdcall * DLL_RegisterAllEventCallBack )(void* 

handle , void(__stdcall* cbEvent)( MV_EVENT_OUT_INFO * pEventInfo, void* pUser),void* pUser); 

typedef int (__stdcall * DLL_ForceIpEx ) (IN void* handle , unsigned int nIP, unsigned int nSubNetMask, unsigned int nDefaultGateWay); 

typedef int (__stdcall * DLL_SetIpConfig ) (IN void* handle , unsigned int nType); 

typedef int (__stdcall * DLL_SetNetTransMode ) (IN void* handle , unsigned int nType); 

typedef int (__stdcall * DLL_GetNetTransInfo ) (IN void* handle , MV_NETTRANS_INFO * pstInfo); 

typedef int (__stdcall * DLL_SetGvcpTimeout ) (IN void* handle , unsigned int nMillisec); 

typedef int (__stdcall * DLL_SetResend ) (IN void* handle , unsigned int bEnable, unsigned int nMaxResendPercent, unsigned int nResendTimeout); typedef int (__stdcall * DLL_SetTransmissionType ) (IN void* handle , MV_TRANSMISSION_TYPE * pstTransmissionType); 

typedef int (__stdcall * DLL_IssueActionCommand ) (IN 

MV_ACTION_CMD_INFO * pstActionCmdInfo, OUT 

MV_ACTION_CMD_RESULT_LIST * pstActionCmdResults); 

typedef int (__stdcall * DLL_SetDeviceBauderate ) (IN void* handle , unsigned int nBaudrate); 

typedef int (__stdcall * DLL_GetDeviceBauderate ) (IN void* handle ,unsigned int* pnCurrentBaudrate); 

typedef int (__stdcall * DLL_GetSupportBauderates ) (IN void* handle ,unsigned int* pnBaudrateAblity); 

typedef int (__stdcall * DLL_SetGenCPTimeOut ) (IN void* handle , unsigned int nMillisec); 

typedef int (__stdcall * DLL_GetGenICamXML ) (IN void* handle , IN OUT unsigned char* pData, IN unsigned int nDataSize, OUT unsigned int* pnDataLen); 

typedef int (__stdcall * DLL_SaveImageEx2 ) (IN void* handle , IN OUT MV_SAVE_IMAGE_PARAM_EX* pSaveParam); 

typedef int (__stdcall * DLL_ConvertPixelType ) (IN void* handle , IN OUT MV_CC_PIXEL_CONVERT_PARAM* pstCvtParam); 

typedef int (__stdcall * DLL_SetBayerCvtQuality ) (IN void* handle , IN unsigned int BayerCvtQuality); 

typedef int (__stdcall * DLL_FeatureSave ) (IN void* handle , IN const char* pFileName); 

typedef int (__stdcall * DLL_FeatureLoad ) (IN void* handle , IN const char* pFileName); 

typedef int (__stdcall * DLL_FileAccessRead ) (IN void* handle , IN MV_CC_FILE_ACCESS * pstFileAccess); 

typedef int (__stdcall * DLL_FileAccessWrite ) (IN void* handle , IN MV_CC_FILE_ACCESS * pstFileAccess); 

typedef int (__stdcall * DLL_GetFileAccessProgress ) (IN void* handle , OUT MV_CC_FILE_ACCESS_PROGRESS *pstFileAccessProgress); 

typedef int (__stdcall * DLL_StartRecord ) (IN void* handle , IN MV_CC_RECORD_PARAM * pstRecordParam); 

typedef int (__stdcall * DLL_InputOneFrame ) (IN void* handle , IN MV_CC_INPUT_FRAME_INFO * pstInputFrameInfo); 

typedef int (__stdcall * DLL_StopRecord ) (IN void* handle ); 

bool g_bExit = false; 

struct MultiThrParam 

{

void *pUser; 

HINSTANCE hDll; 

}; 

// ch: 等待按键输入 | en:Wait for key press 

void WaitForKeyPress (void) {

while(!_kbhit()) 

{

Sleep(10); 

}

_getch(); 

}

bool PrintDeviceInfo (MV_CC_DEVICE_INFO * pstMVDevInfo) 

{

if (NULL == pstMVDevInfo) 

{

printf("The Pointer of pstMVDevInfo is NULL!\n"); 

return false; 

}

if (pstMVDevInfo-> nTLayerType == MV_GIGE_DEVICE )

{

int nIp1 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0xff000000) >> 24); 

int nIp2 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x00ff0000) >> 16); 

int nIp3 = ((pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x0000ff00) >> 8); 

int nIp4 = (pstMVDevInfo-> SpecialInfo .stGigEInfo .nCurrentIp &0x000000ff); 

// ch: 打印当前相机 ip 和用户自定义名字 | en:print current ip and user defined name 

printf("CurrentIp: %d.%d.%d.%d\n" , nIp1, nIp2, nIp3, nIp4); 

printf("UserDefinedName: %s\n\n" , pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_USB_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .chSerialNumber ); 

printf("Device Number: %d\n\n", pstMVDevInfo->SpecialInfo .stUsb3VInfo .nDeviceNumber ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_GIGE_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stGigEInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CAMERALINK_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chUserDefinedName ); printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCMLInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_CXP_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stCXPInfo .chModelName ); 

}

else if (pstMVDevInfo-> nTLayerType == MV_GENTL_XOF_DEVICE )

{

printf("UserDefinedName: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chUserDefinedName ); 

printf("Serial Number: %s\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chSerialNumber ); 

printf("Model Name: %s\n\n", pstMVDevInfo->SpecialInfo .stXoFInfo .chModelName ); 

}

else 

{

printf("Not support.\n"); 

}

return true; 

}

static unsigned int __stdcall WorkThread (void* stMuthreadPar) 

{

struct MultiThrParam *stMulThrPar = (struct MultiThrParam*)stMuthreadPar; 

int nRet = MV_OK ;

MV_FRAME_OUT stOutFrame = {0}; 

DLL_GetImageBuffer DLLGetImageBuffer =(DLL_GetImageBuffer )GetProcAddress(stMulThrPar->hDll, "MV_CC_GetImageBuffer"); 

DLL_FreeImageBuffer DLLFreeImageBuffer = (DLL_FreeImageBuffer )GetProcAddress(stMulThrPar->hDll, "MV_CC_FreeImageBuffer"); 

while(true) 

{

nRet = DLLGetImageBuffer(stMulThrPar->pUser, &stOutFrame, 1000); 

if (nRet == MV_OK )

{printf("Get Image Buffer: Width[%d], Height[%d], nFrameNum[%d]\n", 

stOutFrame. stFrameInfo .nWidth ,stOutFrame. stFrameInfo .nHeight ,stOutFrame. stFrameInfo .nFrameNum ); 

nRet = DLLFreeImageBuffer(stMulThrPar->pUser, &stOutFrame); 

if(nRet != MV_OK )

{

printf("Free Image Buffer fail! nRet [0x%x]\n", nRet); 

}

}

else 

{

printf("Get Image fail! nRet [0x%x]\n", nRet); 

}

if( g_bExit )

{

break; 

}

}

return 0; 

}

int main () 

{

int nRet = MV_OK ;

void* handle = NULL; 

HINSTANCE MvCamCtrlDll = NULL; 

// ch: 以默认方式加载动态库 | en:Load dynamic libraries by default 

MvCamCtrlDll = LoadLibrary("MvCameraControl.dll"); 

if (MvCamCtrlDll) 

{

do 

{

// ch: 初始化 SDK | en:Initialize SDK 

DLL_Initialize DLLInitialize = (DLL_Initialize )GetProcAddress(MvCamCtrlDll, "MV_CC_Initialize"); 

nRet = DLLInitialize(); 

if (MV_OK != nRet) 

{

printf("Initialize SDK fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 枚举设备 | en:Enum device 

MV_CC_DEVICE_INFO_LIST stDeviceList; 

memset(&stDeviceList, 0, sizeof( MV_CC_DEVICE_INFO_LIST )); DLL_EnumDevices DLLEnumDevices = ( DLL_EnumDevices )GetProcAddress (MvCamCtrlDll,"MV_CC_EnumDevices"); 

nRet = DLLEnumDevices( MV_GIGE_DEVICE | MV_USB_DEVICE |

MV_GENTL_CAMERALINK_DEVICE | MV_GENTL_CXP_DEVICE |

MV_GENTL_XOF_DEVICE , &stDeviceList); 

if (MV_OK != nRet) 

{

printf("Enum Devices fail! nRet [0x%x]\n", nRet); 

break; 

}

if (stDeviceList. nDeviceNum > 0) 

{

for (unsigned int i = 0; i < stDeviceList. nDeviceNum ;i++) 

{

printf("[device %d]:\n", i); 

MV_CC_DEVICE_INFO * pDeviceInfo = stDeviceList. pDeviceInfo [i]; 

if (NULL == pDeviceInfo) 

{

break; 

}

PrintDeviceInfo (pDeviceInfo); 

}

}

else 

{

printf("Find No Devices!\n"); 

break; 

}

printf("Please Input camera index(0-%d):", stDeviceList. nDeviceNum -1); 

unsigned int nIndex = 0; 

scanf_s("%d", &nIndex); 

if (nIndex >= stDeviceList. nDeviceNum )

{

printf("Input error!\n"); 

break; 

}

// ch: 选择设备并创建句柄 | en:Select device and create handle 

DLL_CreateHandle DLLCreateHandle = (DLL_CreateHandle )GetProcAddress(MvCamCtrlDll, "MV_CC_CreateHandle"); 

nRet = DLLCreateHandle(& handle ,stDeviceList. pDeviceInfo [nIndex]); 

if (MV_OK != nRet) 

{

printf("Create Handle fail! nRet [0x%x]\n", nRet); 

break; }

// ch: 打开设备 | en:Open device 

DLL_OpenDevice DLLOpenDevice = (DLL_OpenDevice )GetProcAddress(MvCamCtrlDll, "MV_CC_OpenDevice"); 

nRet = DLLOpenDevice( handle , MV_ACCESS_Exclusive , 0); 

if (MV_OK != nRet) 

{

printf("Open Device fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 设置触发模式为 off | en:Set trigger mode as off 

DLL_SetEnumValue DLLSetEnumValue = (DLL_SetEnumValue )GetProcAddress(MvCamCtrlDll, "MV_CC_SetEnumValue"); 

nRet = DLLSetEnumValue( handle , "TriggerMode", 

MV_TRIGGER_MODE_OFF ); 

if (MV_OK != nRet) 

{

printf("Set Trigger Mode fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 开始取流 | en:Start grab image 

DLL_StartGrabbing DLLStartGrabbing =(DLL_StartGrabbing )GetProcAddress(MvCamCtrlDll, "MV_CC_StartGrabbing"); 

nRet = DLLStartGrabbing( handle ); 

if (MV_OK != nRet) 

{

printf("Start Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

unsigned int nThreadID = 0; 

MultiThrParam stMuthreadPar; 

stMuthreadPar.pUser = handle ;

stMuthreadPar.hDll = MvCamCtrlDll; 

void* hThreadHandle = (void*) _beginthreadex( NULL , 0 , 

WorkThread , (void*)&stMuthreadPar, 0 , &nThreadID ); 

if (NULL == hThreadHandle) 

{

break; 

}

printf("Press a key to stop grabbing.\n"); 

WaitForKeyPress (); 

g_bExit = true; Sleep(1000); 

// ch: 停止取流 | en:Stop grab image 

DLL_StopGrabbing DLLStopGrabbing = (DLL_StartGrabbing )GetProcAddress(MvCamCtrlDll, "MV_CC_StopGrabbing"); 

nRet = DLLStopGrabbing( handle ); 

if (MV_OK != nRet) 

{

printf("Stop Grabbing fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 关闭设备 | Close device 

DLL_CloseDevice DLLCloseDevice = (DLL_CloseDevice )GetProcAddress(MvCamCtrlDll, "MV_CC_CloseDevice"); 

nRet = DLLCloseDevice( handle ); 

if (MV_OK != nRet) 

{

printf("ClosDevice fail! nRet [0x%x]\n", nRet); 

break; 

}

// ch: 销毁句柄 | Destroy handle 

DLL_DestroyHandle DLLDestroyHandle =(DLL_DestroyHandle )GetProcAddress(MvCamCtrlDll, "MV_CC_DestroyHandle"); 

nRet = DLLDestroyHandle( handle ); 

if (MV_OK != nRet) 

{

printf("Destroy Handle fail! nRet [0x%x]\n", nRet); 

break; 

}

handle = NULL; 

} while (0); 

if ( handle != NULL) 

{

DLL_DestroyHandle DLLDestroyHandle =(DLL_DestroyHandle )GetProcAddress(MvCamCtrlDll, "MV_CC_DestroyHandle"); 

nRet = DLLDestroyHandle( handle ); 

handle = NULL; 

}

// ch: 反初始化 SDK | en:Finalize SDK 

DLL_Finalize DLLFinalize =(DLL_Finalize )GetProcAddress(MvCamCtrlDll, "MV_CC_Finalize"); DLLFinalize(); 

FreeLibrary(MvCamCtrlDll); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

}

else 

{

DWORD errCode = 0; 

errCode = GetLastError(); 

printf("error code %ld!\n",errCode); 

printf("Press a key to exit.\n"); 

WaitForKeyPress (); 

return -1; 

}

return 0; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# 弃用列表 

全局 MV_CAML_GetSupportBauderates (IN void *handle, unsigned int *pnBaudrateAblity) 

该接口已弃用，建议改用 MV_CAML_GetSupportBaudrates() 接口 全局 MV_USB_RegisterStreamExceptionCallBack (IN void *handle, IN void(__stdcall *cbException)(MV_CC_STREAM_EXCEPTION_TYPE enExceptionType, void *pUser), IN void *pUser) 

自V4.6.0 废弃。建议改用 MV_CC_RegisterStreamExceptionCallBack() 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> LightController
> 函数 |变量

# ConfigLightController.cpp 文件参考 

# 函数 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO *pEventInfo, void *pUser) 

void WaitForKeyPress (void) 

bool PrintInterfaceInfo (MV_INTERFACE_INFO *pstInterfaceInfo) 

void Set_Get_Enum (const char *str) void Set_Get_Bool (const char *str) 

void Set_Get_Int (const char *str) 

void Set_Get_String (const char *str) 

void Set_Get_Float (const char *str) 

int main () 

# 变量 

void * hInterface = NULL 

# 函数说明 

◆ EventCallBack() 

void __stdcall EventCallBack ( MV_EVENT_OUT_INFO * pEventInfo, 

void * pUser 

)

示例 

ConfigLightController.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ConfigLightController.cpp .

◆ PrintInterfaceInfo() 

bool PrintInterfaceInfo ( MV_INTERFACE_INFO * pstInterfaceInfo )示例 

ConfigLightController.cpp .

◆ Set_Get_Enum() 

void Set_Get_Enum ( const char * str )

示例 

ConfigLightController.cpp .

◆ Set_Get_Bool() 

void Set_Get_Bool ( const char * str )

示例 

ConfigLightController.cpp .

◆ Set_Get_Int() 

void Set_Get_Int ( const char * str )

示例 

ConfigLightController.cpp .

◆ Set_Get_String() 

void Set_Get_String ( const char * str )

示例 

ConfigLightController.cpp .

◆ Set_Get_Float() 

void Set_Get_Float ( const char * str )

示例 

ConfigLightController.cpp .

◆ main() int main ( )

示例 

ConfigLightController.cpp .

# 变量说明 

◆ hInterface 

void* hInterface = NULL 

示例 

ConfigLightController.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> LineScanCamera
> 函数 |变量

# LineScanSoftwareTrigger.cpp 文件参考 函数 

bool CheckFeatureNodeAccess (void *hHandle, char *pNodeName) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

static unsigned int __stdcall SoftwareTriggerCommandThread (void *pUser) 

void WaitForKeyPress (void) 

int main () 

# 变量 

bool g_bExit = false 

char g_chTriggerCmd [128] 

# 函数说明 

◆ CheckFeatureNodeAccess() 

bool CheckFeatureNodeAccess ( void * hHandle, 

char * pNodeName 

)

示例 

LineScanSoftwareTrigger.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )示例 

LineScanSoftwareTrigger.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

LineScanSoftwareTrigger.cpp .

◆ SoftwareTriggerCommandThread() 

static unsigned int __stdcall SoftwareTriggerCommandThread ( void * 

pUse r )

> stati c

示例 

LineScanSoftwareTrigger.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

LineScanSoftwareTrigger.cpp .

◆ main() 

int main ( )

示例 

LineScanSoftwareTrigger.cpp .

# 变量说明 ◆ g_bExit 

bool g_bExit = false 

示例 

LineScanSoftwareTrigger.cpp .

◆ g_chTriggerCmd 

char g_chTriggerCmd[128] 

示例 

LineScanSoftwareTrigger.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> LineScanCamera
> 函数 |变量

# ParametrizeCamera_LineScanIOSettings.cpp 文件参考 函数 

bool CheckFeatureNodeAccess (void *hHandle, char *pNodeName) 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

int main () 

# 变量 

bool g_bExit = false 

# 函数说明 

◆ CheckFeatureNodeAccess() 

bool CheckFeatureNodeAccess ( void * hHandle, 

char * pNodeName 

)

示例 

ParametrizeCamera_LineScanIOSettings.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ParametrizeCamera_LineScanIOSettings.cpp .◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ParametrizeCamera_LineScanIOSettings.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

ParametrizeCamera_LineScanIOSettings.cpp .

◆ main() 

int main ( )

示例 

ParametrizeCamera_LineScanIOSettings.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

ParametrizeCamera_LineScanIOSettings.cpp .

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# ChunkData.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

int main () 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ChunkData.cpp .◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ChunkData.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

ChunkData.cpp .

◆ main() 

int main ( )

示例 

ChunkData.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明     

> samples
> General
> 宏定义 |函数 |变量

# Grab_Asynchronous.cpp 文件参考 

# 宏定义 

#define Max_Count 5

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

bool g_bExit = false 

uint64_t m_nImageSize = 0 

CMVMutex * g_mutex = NULL 

ArrayQueue * m_queue = NULL 宏定义说明 

◆ Max_Count 

#define Max_Count 5

示例 

Grab_Asynchronous.cpp .

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Grab_Asynchronous.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

Grab_Asynchronous.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

Grab_Asynchronous.cpp .◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

Grab_Asynchronous.cpp .

◆ main() 

int main ( )

示例 

Grab_Asynchronous.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

Grab_Asynchronous.cpp .

◆ m_nImageSize 

uint64_t m_nImageSize = 0 

示例 

Grab_Asynchronous.cpp .

◆ g_mutex 

CMVMutex* g_mutex = NULL 

示例 

Grab_Asynchronous.cpp .◆ m_queue 

ArrayQueue* m_queue = NULL 

示例 

Grab_Asynchronous.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 宏定义 |函数

# ForceIPEx.cpp 文件参考 

# 宏定义 

#define PERSISTENT_CONFIG_REG 0x0014 

#define PERSISTENT_IPADDR_REG 0x064C 

#define PERSISTENT_SUBNETMASK_REG 0x065C 

#define PERSISTENT_DEFAULTGATEWAY_REG 0x066C 函数 

bool WritesToRegisters (char *chSerialNumber, unsigned int nIpAddr, unsigned int nNetWorkMask, unsigned int nDefaultGateway) 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

bool ConvertToHexIp (unsigned int *nHexIP, unsigned int *nDecIP, char c) 

int main () 

# 宏定义说明 

◆ PERSISTENT_CONFIG_REG 

#define PERSISTENT_CONFIG_REG 0x0014 

示例 

ForceIPEx.cpp .

◆ PERSISTENT_IPADDR_REG 

#define PERSISTENT_IPADDR_REG 0x064C 

示例 

ForceIPEx.cpp .

◆ PERSISTENT_SUBNETMASK_REG 

#define PERSISTENT_SUBNETMASK_REG 0x065C 

示例 

ForceIPEx.cpp .◆ PERSISTENT_DEFAULTGATEWAY_REG 

#define PERSISTENT_DEFAULTGATEWAY_REG 0x066C 

示例 

ForceIPEx.cpp .

# 函数说明 

◆ WritesToRegisters() 

bool WritesToRegisters ( char * chSerialNumber, 

unsigned int nIpAddr, 

unsigned int nNetWorkMask, 

unsigned int nDefaultGateway 

)

示例 

ForceIPEx.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ForceIPEx.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ForceIPEx.cpp .

◆ ConvertToHexIp() 

bool ConvertToHexIp ( unsigned int * nHexIP, 

unsigned int * nDecIP, char c

)

示例 

ForceIPEx.cpp .

◆ main() 

int main ( )

示例 

ForceIPEx.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明     

> samples
> LineScanCamera
> 宏定义 |函数 |变量

# MultiLightCtrl_ImageStitching.cpp 文件参考 

# 宏定义 #define IMAGE_NAME_LEN 256 

# 函数 

void WaitForKeyPress (void) 

bool IsHBPixelFormat (MvGvspPixelType ePixelType) 

bool IsBayerPixelFormat (MvGvspPixelType enType) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

unsigned int GetPixelSize (enum MvGvspPixelType enPixelType) 

int main () 

# 变量 

bool g_bExit = false 

# 宏定义说明 

◆ IMAGE_NAME_LEN 

#define IMAGE_NAME_LEN 256 

示例 

MultiLightCtrl_ImageStitching.cpp .

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )示例 

MultiLightCtrl_ImageStitching.cpp .

◆ IsHBPixelFormat() 

bool IsHBPixelFormat ( MvGvspPixelType ePixelType )

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ IsBayerPixelFormat() 

bool IsBayerPixelFormat ( MvGvspPixelType enType )

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ GetPixelSize() 

unsigned int GetPixelSize ( enum MvGvspPixelType enPixelType )

示例 

MultiLightCtrl_ImageStitching.cpp .

◆ main() 

int main ( )

示例 

MultiLightCtrl_ImageStitching.cpp .

# 变量说明 ◆ g_bExit 

bool g_bExit = false 

示例 

MultiLightCtrl_ImageStitching.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> FrameGrabber
> 函数

# InterfaceAndDeviceDemo.cpp 文件参考 

# 函数 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO_LIST &stDeviceList) 

bool PrintInterfaceInfo (MV_INTERFACE_INFO_LIST &stInterfaceInfoList) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

void WaitForKeyPress (void) int main () 

# 函数说明 

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO_LIST & stDeviceList )

示例 

InterfaceAndDeviceDemo.cpp .

◆ PrintInterfaceInfo() 

bool PrintInterfaceInfo ( MV_INTERFACE_INFO_LIST & stInterfaceInfoList )

示例 

InterfaceAndDeviceDemo.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

InterfaceAndDeviceDemo.cpp .

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

InterfaceAndDeviceDemo.cpp .

◆ main() int main ( )

示例 

InterfaceAndDeviceDemo.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# MultiCast.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 变量 

bool g_bExit = false 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

MultiCast.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

MultiCast.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

MultiCast.cpp .

◆ main() 

int main ( )

示例 

MultiCast.cpp .变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

MultiCast.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples

# samples 目录参考 

# 目录 

目录 AreaScanCamera 

目录 FrameGrabber 

目录 General 目录 LightController 

目录 LineScanCamera 

# 文件 

文件 05 SampleProgram.h 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General

# General 目录参考 

# 文件 

文件 ChunkData.cpp 

文件 ConnectSpecCamera.cpp 

文件 ConvertPixelType.cpp 文件 DynamicallyLoadDLL.cpp 

文件 Events.cpp 

文件 ForceIpDemo.cpp 

文件 ForceIPEx.cpp 

文件 Grab_ActionCommand.cpp 

文件 Grab_Asynchronous.cpp 

文件 Grab_Callback.cpp 

文件 GrabImage.cpp 

文件 GrabImage_Display.cpp 

文件 GrabStrategies.cpp 

文件 HighBandwidthDecode.cpp 

文件 ImageContrast.cpp 

文件 ImageSave.cpp 

文件 MultiCast.cpp 

文件 ParametrizeCamera_FileAccess.cpp 

文件 ParametrizeCamera_LoadAndSave.cpp 

文件 ReconnectDemo.cpp 

文件 Recording.cpp 

首页 发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> AreaScanCamera

# AreaScanCamera 目录参考 

# 文件 

文件 BasicDemo.cpp 

文件 BasicDemoByGenTL.cpp 

文件 BasicDemoShapes.cpp 

文件 LensShadingCorrection.cpp 

文件 ParametrizeCamera_AreaScanIOSettings.cpp 

首页 

发版说明 

编程引导 

API 参考 相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> FrameGrabber

# FrameGrabber 目录参考 

# 文件 

文件 Events_Interface.cpp 

文件 InterfaceAndDeviceDemo.cpp 

文件 InterfaceDemo.cpp 

文件 QuickSoftwareTrigger.cpp 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 samples   

> General
> 函数 |变量

# ConnectSpecCamera.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

bool g_bExit = false 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ConnectSpecCamera.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

ConnectSpecCamera.cpp .◆ main() 

int main ( )

示例 

ConnectSpecCamera.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

ConnectSpecCamera.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# ConvertPixelType.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

bool IsColor (MvGvspPixelType enType) 

bool IsMono (MvGvspPixelType enType) 

int main () 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ConvertPixelType.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ConvertPixelType.cpp .

◆ IsColor() 

bool IsColor ( MvGvspPixelType enType )

示例 

ConvertPixelType.cpp .◆ IsMono() 

bool IsMono ( MvGvspPixelType enType )

示例 

ConvertPixelType.cpp .

◆ main() 

int main ( )

示例 

ConvertPixelType.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# Events.cpp 文件参考 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall EventCallBack (MV_EVENT_OUT_INFO *pEventInfo, void *pUser) 

int main () 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Events.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

Events.cpp .

◆ EventCallBack() 

void __stdcall EventCallBack ( MV_EVENT_OUT_INFO * pEventInfo, 

void * pUser 

)

示例 

Events.cpp .

◆ main() int main ( )

示例 

Events.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# Grab_ActionCommand.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall ActionCommandWorkThread (void *pUser) 

static unsigned int __stdcall ReceiveImageWorkThread (void *pUser) 

int main () 变量 

bool g_bExit = false 

unsigned int g_DeviceKey = 1 

unsigned int g_GroupKey = 1 

unsigned int g_GroupMask = 1 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Grab_ActionCommand.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

Grab_ActionCommand.cpp .

◆ ActionCommandWorkThread() 

static unsigned int __stdcall ActionCommandWorkThread ( void * 

pUse r )

> stati c

示例 

Grab_ActionCommand.cpp .◆ ReceiveImageWorkThread() 

static unsigned int __stdcall ReceiveImageWorkThread ( void * 

pUse r )

> stati c

示例 

Grab_ActionCommand.cpp .

◆ main() 

int main ( )

示例 

Grab_ActionCommand.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

Grab_ActionCommand.cpp .

◆ g_DeviceKey 

unsigned int g_DeviceKey = 1 

示例 

Grab_ActionCommand.cpp .

◆ g_GroupKey 

unsigned int g_GroupKey = 1 

示例 

Grab_ActionCommand.cpp .◆ g_GroupMask 

unsigned int g_GroupMask = 1 

示例 

Grab_ActionCommand.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# Grab_Callback.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

void __stdcall ImageCallbackEx2 (MV_FRAME_OUT *pstFrame, void *pUser, bool bAutoFree) 

int main () 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Grab_Callback.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

Grab_Callback.cpp .

◆ ImageCallbackEx2() 

void __stdcall ImageCallbackEx2 ( MV_FRAME_OUT * pstFrame, 

void * pUser, 

bool bAutoFree 

)

示例 

Grab_Callback.cpp .

◆ main() 

int main ( )

示例 

Grab_Callback.cpp .首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# GrabImage.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

bool g_bExit = false 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

GrabImage.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

GrabImage.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

GrabImage.cpp .

◆ main() 

int main ( )

示例 

GrabImage.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 示例 

GrabImage.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# GrabStrategies.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall UpcomingThread (void *pUser) 

int main () 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

GrabStrategies.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

GrabStrategies.cpp .

◆ UpcomingThread() 

static unsigned int __stdcall UpcomingThread ( void * 

pUse r )

> stati c

示例 

GrabStrategies.cpp .

◆ main() 

int main ( )

示例 

GrabStrategies.cpp .

首页 

发版说明 

编程引导 API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# ImageContrast.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

int main () 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ImageContrast.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ImageContrast.cpp .◆ main() 

int main ( )

示例 

ImageContrast.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> General
> 函数

# ParametrizeCamera_FileAccess.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

int main () 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ParametrizeCamera_FileAccess.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ParametrizeCamera_FileAccess.cpp .

◆ main() 

int main ( )

示例 

ParametrizeCamera_FileAccess.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 法律声明 

> samples
> General
> 函数

# ParametrizeCamera_LoadAndSave.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

int main () 

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

ParametrizeCamera_LoadAndSave.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

ParametrizeCamera_LoadAndSave.cpp .

◆ main() 

int main ( )

示例 ParametrizeCamera_LoadAndSave.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明   

> samples
> General
> 函数 |变量

# Recording.cpp 文件参考 

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall WorkThread (void *pUser) 

int main () 

# 变量 

bool g_bExit = false 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

Recording.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

Recording.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

pUse r )

> stati c

示例 

Recording.cpp .

◆ main() 

int main ( )

示例 

Recording.cpp .

# 变量说明 ◆ g_bExit 

bool g_bExit = false 

示例 

Recording.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明     

> samples
> General
> 类型定义 |函数 |变量

# DynamicallyLoadDLL.cpp 文件参考 

# 类型定义 

typedef int(__stdcall * DLL_Initialize ) () 

typedef int(__stdcall * DLL_Finalize ) () 

typedef unsigned int(__stdcall * DLL_GetSDKVersion ) () 

typedef int(__stdcall * DLL_EnumerateTls ) () typedef int(__stdcall * DLL_EnumDevices ) (IN unsigned int nTLayerType, IN OUT 

MV_CC_DEVICE_INFO_LIST *pstDevList) 

typedef int(__stdcall * DLL_EnumDevicesEx ) (IN unsigned int nTLayerType, IN OUT 

MV_CC_DEVICE_INFO_LIST *pstDevList, IN const char *pManufacturerName) 

typedef bool(__stdcall * DLL_IsDeviceAccessible ) (IN MV_CC_DEVICE_INFO 

*pstDevInfo, IN unsigned int nAccessMode) 

typedef int(__stdcall * DLL_CreateHandle ) (OUT void ** handle , IN const 

MV_CC_DEVICE_INFO *pstDevInfo) 

typedef int(__stdcall * DLL_CreateHandleWithoutLog ) (OUT void ** handle , IN const 

MV_CC_DEVICE_INFO *pstDevInfo) 

typedef int(__stdcall * DLL_DestroyHandle ) (IN void * handle )

typedef int(__stdcall * DLL_OpenDevice ) (IN void * handle , IN unsigned int nAccessMode, IN unsigned short nSwitchoverKey) 

typedef int(__stdcall * DLL_CloseDevice ) (IN void * handle )

typedef int(__stdcall * DLL_RegisterImageCallBackEx ) (void * handle , void(__stdcall *cbOutput) (unsigned char *pData, 

MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_RegisterImageCallBackForRGB ) (void * handle ,void(__stdcall *cbOutput) (unsigned char *pData, 

MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_RegisterImageCallBackForBGR ) (void * handle ,void(__stdcall *cbOutput) (unsigned char *pData, 

MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_StartGrabbing ) (IN void * handle )typedef int(__stdcall * DLL_StopGrabbing ) (IN void * handle )

typedef int(__stdcall * DLL_GetImageForRGB ) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

typedef int(__stdcall * DLL_GetImageForBGR ) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

typedef int(__stdcall * DLL_GetImageBuffer ) (IN void * handle , MV_FRAME_OUT 

*pFrameInfo, int nMsec) 

typedef int(__stdcall * DLL_FreeImageBuffer ) (IN void * handle , MV_FRAME_OUT 

*pFrameInfo) 

typedef int(__stdcall * DLL_GetOneFrameTimeout ) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT 

MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

typedef int(__stdcall * DLL_Display ) (IN void * handle , void *hWnd) 

typedef int(__stdcall * DLL_DisplayOneFrame ) (IN void * handle , IN 

MV_DISPLAY_FRAME_INFO *pDisplayInfo) 

typedef int(__stdcall * DLL_SetImageNodeNum ) (IN void * handle , unsigned int nNum) 

typedef int(__stdcall * DLL_GetDeviceInfo ) (IN void * handle , IN OUT 

MV_CC_DEVICE_INFO *pstDevInfo) 

typedef int(__stdcall * DLL_GetAllMatchInfo ) (IN void * handle , IN OUT 

MV_ALL_MATCH_INFO *pstInfo) 

typedef int(__stdcall * DLL_GetIntValueEx ) (IN void * handle , IN const char *strKey, OUT MVCC_INTVALUE_EX *pIntValue) 

typedef int(__stdcall * DLL_SetIntValueEx ) (IN void * handle , IN const char *strKey, IN int64_t nValue) typedef int(__stdcall * DLL_GetEnumValue ) (IN void * handle , IN const char *strValue, OUT MVCC_ENUMVALUE *pEnumValue) 

typedef int(__stdcall * DLL_SetEnumValue ) (IN void * handle , IN const char *strValue, IN unsigned int nValue) 

typedef int(__stdcall * DLL_SetEnumValueByString ) (IN void * handle , IN const char *strValue, IN const char *sValue) 

typedef int(__stdcall * DLL_GetFloatValue ) (IN void * handle , IN const char *strValue, OUT MVCC_FLOATVALUE *pFloatValue) 

typedef int(__stdcall * DLL_SetFloatValue ) (IN void * handle , IN const char *strValue, IN float fValue) 

typedef int(__stdcall * DLL_GetBoolValue ) (IN void * handle , IN const char *strValue, OUT bool *pBoolValue) 

typedef int(__stdcall * DLL_SetBoolValue ) (IN void * handle , IN const char *strValue, IN bool bValue) 

typedef int(__stdcall * DLL_GetStringValue ) (IN void * handle , IN const char *strKey, OUT MVCC_STRINGVALUE *pStringValue) 

typedef int(__stdcall * DLL_SetStringValue ) (IN void * handle , IN const char *strKey, IN const char *sValue) 

typedef int(__stdcall * DLL_SetCommandValue ) (IN void * handle , IN const char *strValue) 

typedef int(__stdcall * DLL_LocalUpgrade ) (IN void * handle , const void *pFilePathName) 

typedef int(__stdcall * DLL_GetUpgradeProcess ) (IN void * handle , unsigned int *pnProcess) 

typedef int(__stdcall * DLL_GetOptimalPacketSize ) (IN void * handle )

typedef int(__stdcall * DLL_ReadMemory ) (IN void * handle , void *pBuffer, int64_t nAddress, int64_t nLength) typedef int(__stdcall * DLL_WriteMemory ) (IN void * handle , const void *pBuffer, int64_t nAddress, int64_t nLength) 

typedef int(__stdcall * DLL_RegisterExceptionCallBack ) (IN void * handle ,void(__stdcall *cbException) (unsigned int nMsgType, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_RegisterEventCallBackEx ) (void * handle , const char *pEventName, void(__stdcall *cbEvent) (MV_EVENT_OUT_INFO *pEventInfo, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_RegisterAllEventCallBack ) (void * handle , void(__stdcall *cbEvent) ( MV_EVENT_OUT_INFO *pEventInfo, void *pUser), void *pUser) 

typedef int(__stdcall * DLL_ForceIpEx ) (IN void * handle , unsigned int nIP, unsigned int nSubNetMask, unsigned int nDefaultGateWay) 

typedef int(__stdcall * DLL_SetIpConfig ) (IN void * handle , unsigned int nType) 

typedef int(__stdcall * DLL_SetNetTransMode ) (IN void * handle , unsigned int nType) 

typedef int(__stdcall * DLL_GetNetTransInfo ) (IN void * handle ,

MV_NETTRANS_INFO *pstInfo) 

typedef int(__stdcall * DLL_SetGvcpTimeout ) (IN void * handle , unsigned int nMillisec) 

typedef int(__stdcall * DLL_SetResend ) (IN void * handle , unsigned int bEnable, unsigned int nMaxResendPercent, unsigned int nResendTimeout) 

typedef int(__stdcall * DLL_SetTransmissionType ) (IN void * handle ,

MV_TRANSMISSION_TYPE *pstTransmissionType) 

typedef int(__stdcall * DLL_IssueActionCommand ) (IN MV_ACTION_CMD_INFO 

*pstActionCmdInfo, OUT MV_ACTION_CMD_RESULT_LIST 

*pstActionCmdResults) typedef int(__stdcall * DLL_SetDeviceBauderate ) (IN void * handle , unsigned int nBaudrate) 

typedef int(__stdcall * DLL_GetDeviceBauderate ) (IN void * handle , unsigned int *pnCurrentBaudrate) 

typedef int(__stdcall * DLL_GetSupportBauderates ) (IN void * handle , unsigned int *pnBaudrateAblity) 

typedef int(__stdcall * DLL_SetGenCPTimeOut ) (IN void * handle , unsigned int nMillisec) 

typedef int(__stdcall * DLL_GetGenICamXML ) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, OUT unsigned int *pnDataLen) 

typedef int(__stdcall * DLL_SaveImageEx2 ) (IN void * handle , IN OUT MV_SAVE_IMAGE_PARAM_EX *pSaveParam) 

typedef int(__stdcall * DLL_ConvertPixelType ) (IN void * handle , IN OUT MV_CC_PIXEL_CONVERT_PARAM *pstCvtParam) 

typedef int(__stdcall * DLL_SetBayerCvtQuality ) (IN void * handle , IN unsigned int BayerCvtQuality) 

typedef int(__stdcall * DLL_FeatureSave ) (IN void * handle , IN const char *pFileName) 

typedef int(__stdcall * DLL_FeatureLoad ) (IN void * handle , IN const char *pFileName) 

typedef int(__stdcall * DLL_FileAccessRead ) (IN void * handle , IN 

MV_CC_FILE_ACCESS *pstFileAccess) 

typedef int(__stdcall * DLL_FileAccessWrite ) (IN void * handle , IN 

MV_CC_FILE_ACCESS *pstFileAccess) 

typedef int(__stdcall * DLL_GetFileAccessProgress ) (IN void * handle , OUT 

MV_CC_FILE_ACCESS_PROGRESS *pstFileAccessProgress) typedef int(__stdcall * DLL_StartRecord ) (IN void * handle , IN 

MV_CC_RECORD_PARAM *pstRecordParam) 

typedef int(__stdcall * DLL_InputOneFrame ) (IN void * handle , IN 

MV_CC_INPUT_FRAME_INFO *pstInputFrameInfo) 

typedef int(__stdcall * DLL_StopRecord ) (IN void * handle )

# 函数 

void WaitForKeyPress (void) 

bool PrintDeviceInfo (MV_CC_DEVICE_INFO *pstMVDevInfo) 

static unsigned int __stdcall WorkThread (void *stMuthreadPar) 

int main () 

# 变量 

bool g_bExit = false 

# 类型定义说明 

◆ DLL_Initialize 

typedef int(__stdcall * DLL_Initialize) () 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_Finalize 

typedef int(__stdcall * DLL_Finalize) () 

示例 DynamicallyLoadDLL.cpp .

◆ DLL_GetSDKVersion 

typedef unsigned int(__stdcall * DLL_GetSDKVersion) () 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_EnumerateTls 

typedef int(__stdcall * DLL_EnumerateTls) () 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_EnumDevices 

typedef int(__stdcall * DLL_EnumDevices) (IN unsigned int nTLayerType, IN OUT 

MV_CC_DEVICE_INFO_LIST *pstDevList) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_EnumDevicesEx 

typedef int(__stdcall * DLL_EnumDevicesEx) (IN unsigned int nTLayerType, IN OUT 

MV_CC_DEVICE_INFO_LIST *pstDevList, IN const char *pManufacturerName) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_IsDeviceAccessible 

typedef bool(__stdcall * DLL_IsDeviceAccessible) (IN MV_CC_DEVICE_INFO *pstDevInfo, IN unsigned int nAccessMode) 

示例 

DynamicallyLoadDLL.cpp .◆ DLL_CreateHandle 

typedef int(__stdcall * DLL_CreateHandle) (OUT void ** handle , IN const 

MV_CC_DEVICE_INFO *pstDevInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_CreateHandleWithoutLog 

typedef int(__stdcall * DLL_CreateHandleWithoutLog) (OUT void ** handle , IN const 

MV_CC_DEVICE_INFO *pstDevInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_DestroyHandle 

typedef int(__stdcall * DLL_DestroyHandle) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_OpenDevice 

typedef int(__stdcall * DLL_OpenDevice) (IN void * handle , IN unsigned int nAccessMode, IN unsigned short nSwitchoverKey) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_CloseDevice 

typedef int(__stdcall * DLL_CloseDevice) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterImageCallBackEx typedef int(__stdcall * DLL_RegisterImageCallBackEx) (void * handle , void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterImageCallBackForRGB 

typedef int(__stdcall * DLL_RegisterImageCallBackForRGB) (void * handle , void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterImageCallBackForBGR 

typedef int(__stdcall * DLL_RegisterImageCallBackForBGR) (void * handle , void(__stdcall *cbOutput)(unsigned char *pData, MV_FRAME_OUT_INFO_EX *pFrameInfo, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_StartGrabbing 

typedef int(__stdcall * DLL_StartGrabbing) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_StopGrabbing 

typedef int(__stdcall * DLL_StopGrabbing) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetImageForRGB typedef int(__stdcall * DLL_GetImageForRGB) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetImageForBGR 

typedef int(__stdcall * DLL_GetImageForBGR) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetImageBuffer 

typedef int(__stdcall * DLL_GetImageBuffer) (IN void * handle , MV_FRAME_OUT *pFrameInfo, int nMsec) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_FreeImageBuffer 

typedef int(__stdcall * DLL_FreeImageBuffer) (IN void * handle , MV_FRAME_OUT *pFrameInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetOneFrameTimeout 

typedef int(__stdcall * DLL_GetOneFrameTimeout) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, IN OUT MV_FRAME_OUT_INFO_EX *pFrameInfo, int nMsec) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_Display typedef int(__stdcall * DLL_Display) (IN void * handle , void *hWnd) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_DisplayOneFrame 

typedef int(__stdcall * DLL_DisplayOneFrame) (IN void * handle , IN 

MV_DISPLAY_FRAME_INFO *pDisplayInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetImageNodeNum 

typedef int(__stdcall * DLL_SetImageNodeNum) (IN void * handle , unsigned int nNum) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetDeviceInfo 

typedef int(__stdcall * DLL_GetDeviceInfo) (IN void * handle , IN OUT MV_CC_DEVICE_INFO 

*pstDevInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetAllMatchInfo 

typedef int(__stdcall * DLL_GetAllMatchInfo) (IN void * handle , IN OUT MV_ALL_MATCH_INFO 

*pstInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetIntValueEx 

typedef int(__stdcall * DLL_GetIntValueEx) (IN void * handle , IN const char *strKey, OUT 

MVCC_INTVALUE_EX *pIntValue) 示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetIntValueEx 

typedef int(__stdcall * DLL_SetIntValueEx) (IN void * handle , IN const char *strKey, IN int64_t nValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetEnumValue 

typedef int(__stdcall * DLL_GetEnumValue) (IN void * handle , IN const char *strValue, OUT 

MVCC_ENUMVALUE *pEnumValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetEnumValue 

typedef int(__stdcall * DLL_SetEnumValue) (IN void * handle , IN const char *strValue, IN unsigned int nValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetEnumValueByString 

typedef int(__stdcall * DLL_SetEnumValueByString) (IN void * handle , IN const char *strValue, IN const char *sValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetFloatValue 

typedef int(__stdcall * DLL_GetFloatValue) (IN void * handle , IN const char *strValue, OUT 

MVCC_FLOATVALUE *pFloatValue) 示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetFloatValue 

typedef int(__stdcall * DLL_SetFloatValue) (IN void * handle , IN const char *strValue, IN float fValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetBoolValue 

typedef int(__stdcall * DLL_GetBoolValue) (IN void * handle , IN const char *strValue, OUT bool *pBoolValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetBoolValue 

typedef int(__stdcall * DLL_SetBoolValue) (IN void * handle , IN const char *strValue, IN bool bValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetStringValue 

typedef int(__stdcall * DLL_GetStringValue) (IN void * handle , IN const char *strKey, OUT 

MVCC_STRINGVALUE *pStringValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetStringValue 

typedef int(__stdcall * DLL_SetStringValue) (IN void * handle , IN const char *strKey, IN const char *sValue) 示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetCommandValue 

typedef int(__stdcall * DLL_SetCommandValue) (IN void * handle , IN const char *strValue) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_LocalUpgrade 

typedef int(__stdcall * DLL_LocalUpgrade) (IN void * handle , const void *pFilePathName) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetUpgradeProcess 

typedef int(__stdcall * DLL_GetUpgradeProcess) (IN void * handle , unsigned int *pnProcess) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetOptimalPacketSize 

typedef int(__stdcall * DLL_GetOptimalPacketSize) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_ReadMemory 

typedef int(__stdcall * DLL_ReadMemory) (IN void * handle , void *pBuffer, int64_t nAddress, int64_t nLength) 

示例 

DynamicallyLoadDLL.cpp .◆ DLL_WriteMemory 

typedef int(__stdcall * DLL_WriteMemory) (IN void * handle , const void *pBuffer, int64_t nAddress, int64_t nLength) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterExceptionCallBack 

typedef int(__stdcall * DLL_RegisterExceptionCallBack) (IN void * handle , void(__stdcall *cbException)(unsigned int nMsgType, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterEventCallBackEx 

typedef int(__stdcall * DLL_RegisterEventCallBackEx) (void * handle , const char *pEventName, void(__stdcall *cbEvent)( MV_EVENT_OUT_INFO *pEventInfo, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_RegisterAllEventCallBack 

typedef int(__stdcall * DLL_RegisterAllEventCallBack) (void * handle , void(__stdcall *cbEvent)( MV_EVENT_OUT_INFO *pEventInfo, void *pUser), void *pUser) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_ForceIpEx 

typedef int(__stdcall * DLL_ForceIpEx) (IN void * handle , unsigned int nIP, unsigned int nSubNetMask, unsigned int nDefaultGateWay) 

示例 

DynamicallyLoadDLL.cpp .◆ DLL_SetIpConfig 

typedef int(__stdcall * DLL_SetIpConfig) (IN void * handle , unsigned int nType) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetNetTransMode 

typedef int(__stdcall * DLL_SetNetTransMode) (IN void * handle , unsigned int nType) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetNetTransInfo 

typedef int(__stdcall * DLL_GetNetTransInfo) (IN void * handle , MV_NETTRANS_INFO *pstInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetGvcpTimeout 

typedef int(__stdcall * DLL_SetGvcpTimeout) (IN void * handle , unsigned int nMillisec) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetResend 

typedef int(__stdcall * DLL_SetResend) (IN void * handle , unsigned int bEnable, unsigned int nMaxResendPercent, unsigned int nResendTimeout) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetTransmissionType 

typedef int(__stdcall * DLL_SetTransmissionType) (IN void * handle ,

MV_TRANSMISSION_TYPE *pstTransmissionType) 示例 

DynamicallyLoadDLL.cpp .

◆ DLL_IssueActionCommand 

typedef int(__stdcall * DLL_IssueActionCommand) (IN MV_ACTION_CMD_INFO 

*pstActionCmdInfo, OUT MV_ACTION_CMD_RESULT_LIST *pstActionCmdResults) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetDeviceBauderate 

typedef int(__stdcall * DLL_SetDeviceBauderate) (IN void * handle , unsigned int nBaudrate) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetDeviceBauderate 

typedef int(__stdcall * DLL_GetDeviceBauderate) (IN void * handle , unsigned int *pnCurrentBaudrate) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetSupportBauderates 

typedef int(__stdcall * DLL_GetSupportBauderates) (IN void * handle , unsigned int *pnBaudrateAblity) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetGenCPTimeOut 

typedef int(__stdcall * DLL_SetGenCPTimeOut) (IN void * handle , unsigned int nMillisec) 

示例 

DynamicallyLoadDLL.cpp .◆ DLL_GetGenICamXML 

typedef int(__stdcall * DLL_GetGenICamXML) (IN void * handle , IN OUT unsigned char *pData, IN unsigned int nDataSize, OUT unsigned int *pnDataLen) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SaveImageEx2 

typedef int(__stdcall * DLL_SaveImageEx2) (IN void * handle , IN OUT MV_SAVE_IMAGE_PARAM_EX *pSaveParam) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_ConvertPixelType 

typedef int(__stdcall * DLL_ConvertPixelType) (IN void * handle , IN OUT MV_CC_PIXEL_CONVERT_PARAM *pstCvtParam) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_SetBayerCvtQuality 

typedef int(__stdcall * DLL_SetBayerCvtQuality) (IN void * handle , IN unsigned int BayerCvtQuality) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_FeatureSave 

typedef int(__stdcall * DLL_FeatureSave) (IN void * handle , IN const char *pFileName) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_FeatureLoad typedef int(__stdcall * DLL_FeatureLoad) (IN void * handle , IN const char *pFileName) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_FileAccessRead 

typedef int(__stdcall * DLL_FileAccessRead) (IN void * handle , IN MV_CC_FILE_ACCESS 

*pstFileAccess) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_FileAccessWrite 

typedef int(__stdcall * DLL_FileAccessWrite) (IN void * handle , IN MV_CC_FILE_ACCESS 

*pstFileAccess) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_GetFileAccessProgress 

typedef int(__stdcall * DLL_GetFileAccessProgress) (IN void * handle , OUT 

MV_CC_FILE_ACCESS_PROGRESS *pstFileAccessProgress) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_StartRecord 

typedef int(__stdcall * DLL_StartRecord) (IN void * handle , IN MV_CC_RECORD_PARAM 

*pstRecordParam) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_InputOneFrame typedef int(__stdcall * DLL_InputOneFrame) (IN void * handle , IN 

MV_CC_INPUT_FRAME_INFO *pstInputFrameInfo) 

示例 

DynamicallyLoadDLL.cpp .

◆ DLL_StopRecord 

typedef int(__stdcall * DLL_StopRecord) (IN void * handle )

示例 

DynamicallyLoadDLL.cpp .

# 函数说明 

◆ WaitForKeyPress() 

void WaitForKeyPress ( void )

示例 

DynamicallyLoadDLL.cpp .

◆ PrintDeviceInfo() 

bool PrintDeviceInfo ( MV_CC_DEVICE_INFO * pstMVDevInfo )

示例 

DynamicallyLoadDLL.cpp .

◆ WorkThread() 

static unsigned int __stdcall WorkThread ( void * 

stMuthreadPa r )

> stati c

示例 

DynamicallyLoadDLL.cpp .

◆ main() int main ( )

示例 

DynamicallyLoadDLL.cpp .

# 变量说明 

◆ g_bExit 

bool g_bExit = false 

示例 

DynamicallyLoadDLL.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> LightController

# LightController 目录参考 文件 

文件 ConfigLightController.cpp 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> LineScanCamera

# LineScanCamera 目录参考 

# 文件 

文件 LineScanSoftwareTrigger.cpp 

文件 MultiLightCtrl_ImageStitching.cpp 

文件 ParametrizeCamera_LineScanIOSettings.cpp 首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples

# 05 SampleProgram.h 文件参考 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples General
> 变量

# ForceIpDemo.cpp 文件参考 

# 变量 

CForceIpDemoApp theApp 

# 变量说明 

◆ theApp 

CForceIpDemoApp theApp 

示例 

ForceIpDemo.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples General
> 变量

# ReconnectDemo.cpp 文件参考 

# 变量 

CBasicDemoApp theApp 

# 变量说明 

◆ theApp 

CBasicDemoApp theApp 

示例 

ReconnectDemo.cpp .

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples

AreaScanCamera 

> 变量

# BasicDemo.cpp 文件参考 

# 变量 

CBasicDemoApp theApp 

# 变量说明 

◆ theApp 

CBasicDemoApp theApp 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

samples 

AreaScanCamera 

> 变量

# BasicDemoByGenTL.cpp 文件参考 

# 变量 

CBasicDemoByGenTLApp theApp 

# 变量说明 

◆ theApp 

CBasicDemoByGenTLApp theApp 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

> samples
> AreaScanCamera
> 变量

# BasicDemoShapes.cpp 文件参考 变量 

CBasicDemoShapesApp theApp 

# 变量说明 

◆ theApp 

CBasicDemoShapesApp theApp 

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 

常见问题 

法律声明 

# ForceIpDemo.cpp 

设置相机静态 IP 

该示例程序说明如何通过网口相机 IP 、子网掩码和默认网关设置网口相机静态 IP 。

#include "stdafx.h" 

#include "ForceIpDemo.h" 

#include "ForceIpDemoDlg.h" #ifdef _DEBUG 

#define new DEBUG_NEW 

#endif 

// CForceIpDemoApp 

BEGIN_MESSAGE_MAP(CForceIpDemoApp, CWinAppEx) 

ON_COMMAND(ID_HELP, &CWinApp::OnHelp) 

END_MESSAGE_MAP() 

// CForceIpDemoApp 构造 

CForceIpDemoApp::CForceIpDemoApp() 

{

// TODO: 在此处添加构造代码， 

// 将所有重要的初始化放置在 InitInstance 中

}

// 唯一的一个 CForceIpDemoApp 对象 

CForceIpDemoApp theApp ;

// CForceIpDemoApp 初始化 

BOOL CForceIpDemoApp::InitInstance() 

{

// 如果一个运行在 Windows XP 上的应用程序清单指定要 

// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， 

// 则需要 InitCommonControlsEx() 。否则，将无法创建窗口。 

INITCOMMONCONTROLSEX InitCtrls; 

InitCtrls.dwSize = sizeof(InitCtrls); 

// 将它设置为包括所有要在应用程序中使用的 

// 公共控件类。 

InitCtrls.dwICC = ICC_WIN95_CLASSES; 

InitCommonControlsEx(&InitCtrls); 

CWinAppEx::InitInstance(); AfxEnableControlContainer(); 

// 标准初始化 

// 如果未使用这些功能并希望减小 

// 最终可执行文件的大小，则应移除下列 

// 不需要的特定初始化例程 

// 更改用于存储设置的注册表项 

// TODO: 应适当修改该字符串， 

// 例如修改为公司或组织名 

SetRegistryKey(_T(" 应用程序向导生成的本地应用程序 ")); 

CForceIpDemoDlg dlg; 

m_pMainWnd = &dlg; 

INT_PTR nResponse = dlg.DoModal(); 

if (nResponse == IDOK) 

{

// TODO: 在此放置处理何时用 

// “确定 ”来关闭对话框的代码 

}

else if (nResponse == IDCANCEL) 

{

// TODO: 在此放置处理何时用 

// “取消 ”来关闭对话框的代码 

}

// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， 

// 而不是启动应用程序的消息泵。 

return FALSE; 

}

首页 

发版说明 

编程引导 

API 参考 

相机参数节点表 

示例程序概览 常见问题 

法律声明 

# ReconnectDemo.cpp 

相机重连 

该示例程序演示相机掉线后，在心跳时间内重新连接相机。 

// BasicDemo.cpp : 定义应用程序的类行为。 

// 

#include "stdafx.h" 

#include "ReconnectDemo.h" 

#include "ReconnectDemoDlg.h" 

#ifdef _DEBUG 

#define new DEBUG_NEW 

#endif 

// CBasicDemoApp 

BEGIN_MESSAGE_MAP(CBasicDemoApp, CWinAppEx) 

ON_COMMAND(ID_HELP, &CWinApp::OnHelp) 

END_MESSAGE_MAP() 

// CBasicDemoApp 构造 

CBasicDemoApp::CBasicDemoApp() 

{

// TODO: 在此处添加构造代码， 

// 将所有重要的初始化放置在 InitInstance 中

}

// 唯一的一个 CBasicDemoApp 对象 CBasicDemoApp theApp ;

// CBasicDemoApp 初始化 

BOOL CBasicDemoApp::InitInstance() 

{

// 如果一个运行在 Windows XP 上的应用程序清单指定要 

// 使用 ComCtl32.dll 版本 6 或更高版本来启用可视化方式， 

// 则需要 InitCommonControlsEx() 。否则，将无法创建窗口。 

INITCOMMONCONTROLSEX InitCtrls; 

InitCtrls.dwSize = sizeof(InitCtrls); 

// 将它设置为包括所有要在应用程序中使用的 

// 公共控件类。 

InitCtrls.dwICC = ICC_WIN95_CLASSES; 

InitCommonControlsEx(&InitCtrls); 

CWinAppEx::InitInstance(); 

AfxEnableControlContainer(); 

// 标准初始化 

// 如果未使用这些功能并希望减小 

// 最终可执行文件的大小，则应移除下列 

// 不需要的特定初始化例程 

// 更改用于存储设置的注册表项 

// TODO: 应适当修改该字符串， 

// 例如修改为公司或组织名 

SetRegistryKey(_T(" 应用程序向导生成的本地应用程序 ")); 

CBasicDemoDlg dlg; 

m_pMainWnd = &dlg; 

INT_PTR nResponse = dlg.DoModal(); 

if (nResponse == IDOK) 

{

// TODO: 在此放置处理何时用 

// “确定 ”来关闭对话框的代码 

}

else if (nResponse == IDCANCEL) 

{

// TODO: 在此放置处理何时用 

// “取消 ”来关闭对话框的代码 

}// 由于对话框已关闭，所以将返回 FALSE 以便退出应用程序， 

// 而不是启动应用程序的消息泵。 

return FALSE; 

}
